{
  "exitcode": 1,
  "summary": {
    "failed": 8,
    "passed": 3,
    "total": 11,
    "collected": 11
  },
  "collectors": [
    {
      "nodeid": "",
      "outcome": "passed",
      "result": [
        {
          "nodeid": ".",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::AuthenticatorTest",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::AuthenticatorTest::test_cleanup",
          "type": "TestCaseFunction",
          "lineno": 75
        },
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::AuthenticatorTest::test_get_chall_pref",
          "type": "TestCaseFunction",
          "lineno": 58
        },
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::AuthenticatorTest::test_more_info",
          "type": "TestCaseFunction",
          "lineno": 55
        },
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::AuthenticatorTest::test_parser_arguments",
          "type": "TestCaseFunction",
          "lineno": 61
        },
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::AuthenticatorTest::test_perform",
          "type": "TestCaseFunction",
          "lineno": 66
        }
      ]
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest::test_add_txt_record",
          "type": "TestCaseFunction",
          "lineno": 129
        },
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest::test_add_txt_record_fail_to_authenticate",
          "type": "TestCaseFunction",
          "lineno": 163
        },
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest::test_add_txt_record_fail_to_find_domain",
          "type": "TestCaseFunction",
          "lineno": 150
        },
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest::test_del_txt_record",
          "type": "TestCaseFunction",
          "lineno": 177
        },
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest::test_del_txt_record_fail_to_authenticate",
          "type": "TestCaseFunction",
          "lineno": 237
        },
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest::test_del_txt_record_fail_to_find_domain",
          "type": "TestCaseFunction",
          "lineno": 224
        }
      ]
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::AuthenticatorTest",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "certbot_dns_infomaniak",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "certbot_dns_infomaniak.egg-info",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": ".",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "certbot_dns_infomaniak",
          "type": "Package"
        },
        {
          "nodeid": "certbot_dns_infomaniak.egg-info",
          "type": "Dir"
        }
      ]
    }
  ],
  "tests": [
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::AuthenticatorTest::test_cleanup",
      "lineno": 75,
      "outcome": "failed",
      "keywords": [
        "test_cleanup",
        "AuthenticatorTest",
        "dns_infomaniak_test.py",
        "certbot_dns_infomaniak",
        "infomaniak@certbot-dns-infomaniak__33519931__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\infomaniak@certbot-dns-infomaniak__33519931__requests__treq\\.venv\\Lib\\site-packages\\twisted\\internet\\defer.py",
          "lineno": 1365,
          "message": "twisted.internet.defer.NotACoroutineError: <MagicMock name='mock.del_txt_record()' id='1825183307520'> is not a coroutine or a Deferred"
        },
        "traceback": [
          {
            "path": "certbot_dns_infomaniak\\dns_infomaniak_test.py",
            "lineno": 80,
            "message": ""
          },
          {
            "path": ".venv\\Lib\\site-packages\\certbot\\plugins\\dns_common.py",
            "lineno": 99,
            "message": "in cleanup"
          },
          {
            "path": "certbot_dns_infomaniak\\dns_infomaniak.py",
            "lineno": 72,
            "message": "in _cleanup"
          },
          {
            "path": ".venv\\Lib\\site-packages\\twisted\\internet\\defer.py",
            "lineno": 1365,
            "message": "NotACoroutineError"
          }
        ],
        "longrepr": "coro = <MagicMock name='mock.del_txt_record()' id='1825183307520'>\n\n    def ensureDeferred(\n        coro: Union[\n            Coroutine[Deferred[Any], Any, _T],\n            Generator[Deferred[Any], Any, _T],\n            Deferred[_T],\n        ]\n    ) -> Deferred[_T]:\n        \"\"\"\n        Schedule the execution of a coroutine that awaits/yields from L{Deferred}s,\n        wrapping it in a L{Deferred} that will fire on success/failure of the\n        coroutine. If a Deferred is passed to this function, it will be returned\n        directly (mimicking the L{asyncio.ensure_future} function).\n    \n        See L{Deferred.fromCoroutine} for examples of coroutines.\n    \n        @param coro: The coroutine object to schedule, or a L{Deferred}.\n        \"\"\"\n        if type(coro) in _DEFERRED_SUBCLASSES:\n            return coro  # type: ignore[return-value]\n        else:\n            try:\n>               return Deferred.fromCoroutine(coro)  # type: ignore[arg-type]\n\n.venv\\Lib\\site-packages\\twisted\\internet\\defer.py:1361: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <class 'twisted.internet.defer.Deferred'>\ncoro = <MagicMock name='mock.del_txt_record()' id='1825183307520'>\n\n    @classmethod\n    def fromCoroutine(\n        cls,\n        coro: Union[\n            Coroutine[Deferred[Any], Any, _T],\n            Generator[Deferred[Any], Any, _T],\n        ],\n    ) -> \"Deferred[_T]\":\n        \"\"\"\n        Schedule the execution of a coroutine that awaits on L{Deferred}s,\n        wrapping it in a L{Deferred} that will fire on success/failure of the\n        coroutine.\n    \n        Coroutine functions return a coroutine object, similar to how\n        generators work. This function turns that coroutine into a Deferred,\n        meaning that it can be used in regular Twisted code. For example::\n    \n            import treq\n            from twisted.internet.defer import Deferred\n            from twisted.internet.task import react\n    \n            async def crawl(pages):\n                results = {}\n                for page in pages:\n                    results[page] = await treq.content(await treq.get(page))\n                return results\n    \n            def main(reactor):\n                pages = [\n                    \"http://localhost:8080\"\n                ]\n                d = Deferred.fromCoroutine(crawl(pages))\n                d.addCallback(print)\n                return d\n    \n            react(main)\n    \n        @since: Twisted 21.2.0\n    \n        @param coro: The coroutine object to schedule.\n    \n        @raise ValueError: If C{coro} is not a coroutine or generator.\n        \"\"\"\n        # asyncio.iscoroutine <3.12 identifies generators as coroutines, too.\n        # for >=3.12 we need to check isgenerator also\n        # see https://github.com/python/cpython/issues/102748\n        if iscoroutine(coro) or inspect.isgenerator(coro):\n            return _cancellableInlineCallbacks(coro)\n>       raise NotACoroutineError(f\"{coro!r} is not a coroutine\")\nE       twisted.internet.defer.NotACoroutineError: <MagicMock name='mock.del_txt_record()' id='1825183307520'> is not a coroutine\n\n.venv\\Lib\\site-packages\\twisted\\internet\\defer.py:1329: NotACoroutineError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <certbot_dns_infomaniak.dns_infomaniak_test.AuthenticatorTest testMethod=test_cleanup>\n\n    def test_cleanup(self):\n        \"\"\"Tests the cleanup method to see if client method is called\"\"\"\n        # _attempt_cleanup | pylint: disable=protected-access\n        self.auth._attempt_cleanup = True\n>       self.auth.cleanup([self.achall])\n\ncertbot_dns_infomaniak\\dns_infomaniak_test.py:80: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\certbot\\plugins\\dns_common.py:99: in cleanup\n    self._cleanup(domain, validation_domain_name, validation)\ncertbot_dns_infomaniak\\dns_infomaniak.py:72: in _cleanup\n    ensureDeferred(self._api_client().del_txt_record(decoded_domain, validation_name, validation))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncoro = <MagicMock name='mock.del_txt_record()' id='1825183307520'>\n\n    def ensureDeferred(\n        coro: Union[\n            Coroutine[Deferred[Any], Any, _T],\n            Generator[Deferred[Any], Any, _T],\n            Deferred[_T],\n        ]\n    ) -> Deferred[_T]:\n        \"\"\"\n        Schedule the execution of a coroutine that awaits/yields from L{Deferred}s,\n        wrapping it in a L{Deferred} that will fire on success/failure of the\n        coroutine. If a Deferred is passed to this function, it will be returned\n        directly (mimicking the L{asyncio.ensure_future} function).\n    \n        See L{Deferred.fromCoroutine} for examples of coroutines.\n    \n        @param coro: The coroutine object to schedule, or a L{Deferred}.\n        \"\"\"\n        if type(coro) in _DEFERRED_SUBCLASSES:\n            return coro  # type: ignore[return-value]\n        else:\n            try:\n                return Deferred.fromCoroutine(coro)  # type: ignore[arg-type]\n            except NotACoroutineError:\n                # It's not a coroutine. Raise an exception, but say that it's also\n                # not a Deferred so the error makes sense.\n>               raise NotACoroutineError(f\"{coro!r} is not a coroutine or a Deferred\")\nE               twisted.internet.defer.NotACoroutineError: <MagicMock name='mock.del_txt_record()' id='1825183307520'> is not a coroutine or a Deferred\n\n.venv\\Lib\\site-packages\\twisted\\internet\\defer.py:1365: NotACoroutineError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::AuthenticatorTest::test_get_chall_pref",
      "lineno": 58,
      "outcome": "passed",
      "keywords": [
        "test_get_chall_pref",
        "AuthenticatorTest",
        "dns_infomaniak_test.py",
        "certbot_dns_infomaniak",
        "infomaniak@certbot-dns-infomaniak__33519931__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::AuthenticatorTest::test_more_info",
      "lineno": 55,
      "outcome": "passed",
      "keywords": [
        "test_more_info",
        "AuthenticatorTest",
        "dns_infomaniak_test.py",
        "certbot_dns_infomaniak",
        "infomaniak@certbot-dns-infomaniak__33519931__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::AuthenticatorTest::test_parser_arguments",
      "lineno": 61,
      "outcome": "passed",
      "keywords": [
        "test_parser_arguments",
        "AuthenticatorTest",
        "dns_infomaniak_test.py",
        "certbot_dns_infomaniak",
        "infomaniak@certbot-dns-infomaniak__33519931__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::AuthenticatorTest::test_perform",
      "lineno": 66,
      "outcome": "failed",
      "keywords": [
        "test_perform",
        "AuthenticatorTest",
        "dns_infomaniak_test.py",
        "certbot_dns_infomaniak",
        "infomaniak@certbot-dns-infomaniak__33519931__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\infomaniak@certbot-dns-infomaniak__33519931__requests__treq\\.venv\\Lib\\site-packages\\twisted\\internet\\defer.py",
          "lineno": 1365,
          "message": "twisted.internet.defer.NotACoroutineError: <MagicMock name='mock.add_txt_record()' id='1825183867504'> is not a coroutine or a Deferred"
        },
        "traceback": [
          {
            "path": "certbot_dns_infomaniak\\dns_infomaniak_test.py",
            "lineno": 69,
            "message": ""
          },
          {
            "path": ".venv\\Lib\\site-packages\\certbot\\plugins\\dns_common.py",
            "lineno": 80,
            "message": "in perform"
          },
          {
            "path": "certbot_dns_infomaniak\\dns_infomaniak.py",
            "lineno": 65,
            "message": "in _perform"
          },
          {
            "path": ".venv\\Lib\\site-packages\\twisted\\internet\\defer.py",
            "lineno": 1365,
            "message": "NotACoroutineError"
          }
        ],
        "longrepr": "coro = <MagicMock name='mock.add_txt_record()' id='1825183867504'>\n\n    def ensureDeferred(\n        coro: Union[\n            Coroutine[Deferred[Any], Any, _T],\n            Generator[Deferred[Any], Any, _T],\n            Deferred[_T],\n        ]\n    ) -> Deferred[_T]:\n        \"\"\"\n        Schedule the execution of a coroutine that awaits/yields from L{Deferred}s,\n        wrapping it in a L{Deferred} that will fire on success/failure of the\n        coroutine. If a Deferred is passed to this function, it will be returned\n        directly (mimicking the L{asyncio.ensure_future} function).\n    \n        See L{Deferred.fromCoroutine} for examples of coroutines.\n    \n        @param coro: The coroutine object to schedule, or a L{Deferred}.\n        \"\"\"\n        if type(coro) in _DEFERRED_SUBCLASSES:\n            return coro  # type: ignore[return-value]\n        else:\n            try:\n>               return Deferred.fromCoroutine(coro)  # type: ignore[arg-type]\n\n.venv\\Lib\\site-packages\\twisted\\internet\\defer.py:1361: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <class 'twisted.internet.defer.Deferred'>\ncoro = <MagicMock name='mock.add_txt_record()' id='1825183867504'>\n\n    @classmethod\n    def fromCoroutine(\n        cls,\n        coro: Union[\n            Coroutine[Deferred[Any], Any, _T],\n            Generator[Deferred[Any], Any, _T],\n        ],\n    ) -> \"Deferred[_T]\":\n        \"\"\"\n        Schedule the execution of a coroutine that awaits on L{Deferred}s,\n        wrapping it in a L{Deferred} that will fire on success/failure of the\n        coroutine.\n    \n        Coroutine functions return a coroutine object, similar to how\n        generators work. This function turns that coroutine into a Deferred,\n        meaning that it can be used in regular Twisted code. For example::\n    \n            import treq\n            from twisted.internet.defer import Deferred\n            from twisted.internet.task import react\n    \n            async def crawl(pages):\n                results = {}\n                for page in pages:\n                    results[page] = await treq.content(await treq.get(page))\n                return results\n    \n            def main(reactor):\n                pages = [\n                    \"http://localhost:8080\"\n                ]\n                d = Deferred.fromCoroutine(crawl(pages))\n                d.addCallback(print)\n                return d\n    \n            react(main)\n    \n        @since: Twisted 21.2.0\n    \n        @param coro: The coroutine object to schedule.\n    \n        @raise ValueError: If C{coro} is not a coroutine or generator.\n        \"\"\"\n        # asyncio.iscoroutine <3.12 identifies generators as coroutines, too.\n        # for >=3.12 we need to check isgenerator also\n        # see https://github.com/python/cpython/issues/102748\n        if iscoroutine(coro) or inspect.isgenerator(coro):\n            return _cancellableInlineCallbacks(coro)\n>       raise NotACoroutineError(f\"{coro!r} is not a coroutine\")\nE       twisted.internet.defer.NotACoroutineError: <MagicMock name='mock.add_txt_record()' id='1825183867504'> is not a coroutine\n\n.venv\\Lib\\site-packages\\twisted\\internet\\defer.py:1329: NotACoroutineError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <certbot_dns_infomaniak.dns_infomaniak_test.AuthenticatorTest testMethod=test_perform>\n\n    def test_perform(self):\n        \"\"\"Tests the perform function to see if client method is called\"\"\"\n>       self.auth.perform([self.achall])\n\ncertbot_dns_infomaniak\\dns_infomaniak_test.py:69: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\certbot\\plugins\\dns_common.py:80: in perform\n    self._perform(domain, validation_domain_name, validation)\ncertbot_dns_infomaniak\\dns_infomaniak.py:65: in _perform\n    ensureDeferred(self._api_client().add_txt_record(decoded_domain, validation_name, validation))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncoro = <MagicMock name='mock.add_txt_record()' id='1825183867504'>\n\n    def ensureDeferred(\n        coro: Union[\n            Coroutine[Deferred[Any], Any, _T],\n            Generator[Deferred[Any], Any, _T],\n            Deferred[_T],\n        ]\n    ) -> Deferred[_T]:\n        \"\"\"\n        Schedule the execution of a coroutine that awaits/yields from L{Deferred}s,\n        wrapping it in a L{Deferred} that will fire on success/failure of the\n        coroutine. If a Deferred is passed to this function, it will be returned\n        directly (mimicking the L{asyncio.ensure_future} function).\n    \n        See L{Deferred.fromCoroutine} for examples of coroutines.\n    \n        @param coro: The coroutine object to schedule, or a L{Deferred}.\n        \"\"\"\n        if type(coro) in _DEFERRED_SUBCLASSES:\n            return coro  # type: ignore[return-value]\n        else:\n            try:\n                return Deferred.fromCoroutine(coro)  # type: ignore[arg-type]\n            except NotACoroutineError:\n                # It's not a coroutine. Raise an exception, but say that it's also\n                # not a Deferred so the error makes sense.\n>               raise NotACoroutineError(f\"{coro!r} is not a coroutine or a Deferred\")\nE               twisted.internet.defer.NotACoroutineError: <MagicMock name='mock.add_txt_record()' id='1825183867504'> is not a coroutine or a Deferred\n\n.venv\\Lib\\site-packages\\twisted\\internet\\defer.py:1365: NotACoroutineError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest::test_add_txt_record",
      "lineno": 129,
      "outcome": "failed",
      "keywords": [
        "test_add_txt_record",
        "asyncio",
        "__wrapped__",
        "pytestmark",
        "APIDomainTest",
        "dns_infomaniak_test.py",
        "certbot_dns_infomaniak",
        "infomaniak@certbot-dns-infomaniak__33519931__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\infomaniak@certbot-dns-infomaniak__33519931__requests__treq\\certbot_dns_infomaniak\\dns_infomaniak_test.py",
          "lineno": 95,
          "message": "TypeError: StubTreq.__init__() missing 1 required positional argument: 'resource'"
        },
        "traceback": [
          {
            "path": "certbot_dns_infomaniak\\dns_infomaniak_test.py",
            "lineno": 95,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <certbot_dns_infomaniak.dns_infomaniak_test.APIDomainTest testMethod=test_add_txt_record>\n\n    def setUp(self):\n>       self.fake_api = StubTreq()\nE       TypeError: StubTreq.__init__() missing 1 required positional argument: 'resource'\n\ncertbot_dns_infomaniak\\dns_infomaniak_test.py:95: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest::test_add_txt_record_fail_to_authenticate",
      "lineno": 163,
      "outcome": "failed",
      "keywords": [
        "test_add_txt_record_fail_to_authenticate",
        "asyncio",
        "__wrapped__",
        "pytestmark",
        "APIDomainTest",
        "dns_infomaniak_test.py",
        "certbot_dns_infomaniak",
        "infomaniak@certbot-dns-infomaniak__33519931__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\infomaniak@certbot-dns-infomaniak__33519931__requests__treq\\certbot_dns_infomaniak\\dns_infomaniak_test.py",
          "lineno": 95,
          "message": "TypeError: StubTreq.__init__() missing 1 required positional argument: 'resource'"
        },
        "traceback": [
          {
            "path": "certbot_dns_infomaniak\\dns_infomaniak_test.py",
            "lineno": 95,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <certbot_dns_infomaniak.dns_infomaniak_test.APIDomainTest testMethod=test_add_txt_record_fail_to_authenticate>\n\n    def setUp(self):\n>       self.fake_api = StubTreq()\nE       TypeError: StubTreq.__init__() missing 1 required positional argument: 'resource'\n\ncertbot_dns_infomaniak\\dns_infomaniak_test.py:95: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest::test_add_txt_record_fail_to_find_domain",
      "lineno": 150,
      "outcome": "failed",
      "keywords": [
        "test_add_txt_record_fail_to_find_domain",
        "asyncio",
        "__wrapped__",
        "pytestmark",
        "APIDomainTest",
        "dns_infomaniak_test.py",
        "certbot_dns_infomaniak",
        "infomaniak@certbot-dns-infomaniak__33519931__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\infomaniak@certbot-dns-infomaniak__33519931__requests__treq\\certbot_dns_infomaniak\\dns_infomaniak_test.py",
          "lineno": 95,
          "message": "TypeError: StubTreq.__init__() missing 1 required positional argument: 'resource'"
        },
        "traceback": [
          {
            "path": "certbot_dns_infomaniak\\dns_infomaniak_test.py",
            "lineno": 95,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <certbot_dns_infomaniak.dns_infomaniak_test.APIDomainTest testMethod=test_add_txt_record_fail_to_find_domain>\n\n    def setUp(self):\n>       self.fake_api = StubTreq()\nE       TypeError: StubTreq.__init__() missing 1 required positional argument: 'resource'\n\ncertbot_dns_infomaniak\\dns_infomaniak_test.py:95: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest::test_del_txt_record",
      "lineno": 177,
      "outcome": "failed",
      "keywords": [
        "test_del_txt_record",
        "asyncio",
        "__wrapped__",
        "pytestmark",
        "APIDomainTest",
        "dns_infomaniak_test.py",
        "certbot_dns_infomaniak",
        "infomaniak@certbot-dns-infomaniak__33519931__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\infomaniak@certbot-dns-infomaniak__33519931__requests__treq\\certbot_dns_infomaniak\\dns_infomaniak_test.py",
          "lineno": 95,
          "message": "TypeError: StubTreq.__init__() missing 1 required positional argument: 'resource'"
        },
        "traceback": [
          {
            "path": "certbot_dns_infomaniak\\dns_infomaniak_test.py",
            "lineno": 95,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <certbot_dns_infomaniak.dns_infomaniak_test.APIDomainTest testMethod=test_del_txt_record>\n\n    def setUp(self):\n>       self.fake_api = StubTreq()\nE       TypeError: StubTreq.__init__() missing 1 required positional argument: 'resource'\n\ncertbot_dns_infomaniak\\dns_infomaniak_test.py:95: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest::test_del_txt_record_fail_to_authenticate",
      "lineno": 237,
      "outcome": "failed",
      "keywords": [
        "test_del_txt_record_fail_to_authenticate",
        "asyncio",
        "__wrapped__",
        "pytestmark",
        "APIDomainTest",
        "dns_infomaniak_test.py",
        "certbot_dns_infomaniak",
        "infomaniak@certbot-dns-infomaniak__33519931__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\infomaniak@certbot-dns-infomaniak__33519931__requests__treq\\certbot_dns_infomaniak\\dns_infomaniak_test.py",
          "lineno": 95,
          "message": "TypeError: StubTreq.__init__() missing 1 required positional argument: 'resource'"
        },
        "traceback": [
          {
            "path": "certbot_dns_infomaniak\\dns_infomaniak_test.py",
            "lineno": 95,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <certbot_dns_infomaniak.dns_infomaniak_test.APIDomainTest testMethod=test_del_txt_record_fail_to_authenticate>\n\n    def setUp(self):\n>       self.fake_api = StubTreq()\nE       TypeError: StubTreq.__init__() missing 1 required positional argument: 'resource'\n\ncertbot_dns_infomaniak\\dns_infomaniak_test.py:95: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "certbot_dns_infomaniak/dns_infomaniak_test.py::APIDomainTest::test_del_txt_record_fail_to_find_domain",
      "lineno": 224,
      "outcome": "failed",
      "keywords": [
        "test_del_txt_record_fail_to_find_domain",
        "asyncio",
        "__wrapped__",
        "pytestmark",
        "APIDomainTest",
        "dns_infomaniak_test.py",
        "certbot_dns_infomaniak",
        "infomaniak@certbot-dns-infomaniak__33519931__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\infomaniak@certbot-dns-infomaniak__33519931__requests__treq\\certbot_dns_infomaniak\\dns_infomaniak_test.py",
          "lineno": 95,
          "message": "TypeError: StubTreq.__init__() missing 1 required positional argument: 'resource'"
        },
        "traceback": [
          {
            "path": "certbot_dns_infomaniak\\dns_infomaniak_test.py",
            "lineno": 95,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <certbot_dns_infomaniak.dns_infomaniak_test.APIDomainTest testMethod=test_del_txt_record_fail_to_find_domain>\n\n    def setUp(self):\n>       self.fake_api = StubTreq()\nE       TypeError: StubTreq.__init__() missing 1 required positional argument: 'resource'\n\ncertbot_dns_infomaniak\\dns_infomaniak_test.py:95: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    }
  ]
}