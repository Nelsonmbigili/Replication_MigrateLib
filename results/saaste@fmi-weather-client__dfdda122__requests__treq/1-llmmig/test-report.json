{
  "exitcode": 1,
  "summary": {
    "passed": 6,
    "failed": 15,
    "total": 21,
    "collected": 21
  },
  "collectors": [
    {
      "nodeid": "",
      "outcome": "passed",
      "result": [
        {
          "nodeid": ".",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "fmi_weather_client/parsers",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "fmi_weather_client",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "fmi_weather_client/parsers",
          "type": "Package"
        }
      ]
    },
    {
      "nodeid": "fmi_weather_client.egg-info",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "test/test_data",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "test/test_http.py::HTTPTest",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "test/test_http.py::HTTPTest::test_create_params_invalid_request_type",
          "type": "TestCaseFunction",
          "lineno": 13
        },
        {
          "nodeid": "test/test_http.py::HTTPTest::test_create_params_missing_location",
          "type": "TestCaseFunction",
          "lineno": 9
        },
        {
          "nodeid": "test/test_http.py::HTTPTest::test_handle_errors_client_error_with_exception_text",
          "type": "TestCaseFunction",
          "lineno": 17
        }
      ]
    },
    {
      "nodeid": "test/test_http.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "test/test_http.py::HTTPTest",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_async_get_forecast_by_coordinates",
          "type": "TestCaseFunction",
          "lineno": 51
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_async_get_forecast_by_place_name",
          "type": "TestCaseFunction",
          "lineno": 40
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_async_get_weather_by_coordinates",
          "type": "TestCaseFunction",
          "lineno": 29
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_async_get_weather_by_place",
          "type": "TestCaseFunction",
          "lineno": 18
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_get_forecast_by_coordinates",
          "type": "TestCaseFunction",
          "lineno": 46
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_get_forecast_by_place_name",
          "type": "TestCaseFunction",
          "lineno": 35
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_get_weather_by_coordinates",
          "type": "TestCaseFunction",
          "lineno": 24
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_get_weather_by_place",
          "type": "TestCaseFunction",
          "lineno": 13
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_invalid_lat_lon_exception_response",
          "type": "TestCaseFunction",
          "lineno": 80
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_nil_forecast_response",
          "type": "TestCaseFunction",
          "lineno": 65
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_nil_weather_response",
          "type": "TestCaseFunction",
          "lineno": 58
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_no_data_available_exception_response",
          "type": "TestCaseFunction",
          "lineno": 85
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_no_location_exception_response",
          "type": "TestCaseFunction",
          "lineno": 75
        },
        {
          "nodeid": "test/test_init.py::FMIWeatherTest::test_server_error_response",
          "type": "TestCaseFunction",
          "lineno": 90
        }
      ]
    },
    {
      "nodeid": "test/test_init.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "test/test_init.py::FMIWeatherTest",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "test/test_models.py::ModelsTest",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "test/test_models.py::ModelsTest::test_fmi_place",
          "type": "TestCaseFunction",
          "lineno": 6
        },
        {
          "nodeid": "test/test_models.py::ModelsTest::test_value",
          "type": "TestCaseFunction",
          "lineno": 10
        }
      ]
    },
    {
      "nodeid": "test/test_models.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "test/test_models.py::ModelsTest",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "test/test_parsers_forecast.py::ForecastParserTest",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "test/test_parsers_forecast.py::ForecastParserTest::test_feels_like",
          "type": "TestCaseFunction",
          "lineno": 15
        },
        {
          "nodeid": "test/test_parsers_forecast.py::ForecastParserTest::test_float_or_none",
          "type": "TestCaseFunction",
          "lineno": 7
        }
      ]
    },
    {
      "nodeid": "test/test_parsers_forecast.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "test/test_parsers_forecast.py::ForecastParserTest",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "test",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "test/test_data",
          "type": "Package"
        },
        {
          "nodeid": "test/test_http.py",
          "type": "Module"
        },
        {
          "nodeid": "test/test_init.py",
          "type": "Module"
        },
        {
          "nodeid": "test/test_models.py",
          "type": "Module"
        },
        {
          "nodeid": "test/test_parsers_forecast.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": ".",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "fmi_weather_client",
          "type": "Package"
        },
        {
          "nodeid": "fmi_weather_client.egg-info",
          "type": "Dir"
        },
        {
          "nodeid": "test",
          "type": "Package"
        }
      ]
    }
  ],
  "tests": [
    {
      "nodeid": "test/test_http.py::HTTPTest::test_create_params_invalid_request_type",
      "lineno": 13,
      "outcome": "passed",
      "keywords": [
        "test_create_params_invalid_request_type",
        "HTTPTest",
        "test_http.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_http.py::HTTPTest::test_create_params_missing_location",
      "lineno": 9,
      "outcome": "passed",
      "keywords": [
        "test_create_params_missing_location",
        "HTTPTest",
        "test_http.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_http.py::HTTPTest::test_handle_errors_client_error_with_exception_text",
      "lineno": 17,
      "outcome": "failed",
      "keywords": [
        "test_handle_errors_client_error_with_exception_text",
        "HTTPTest",
        "test_http.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\case.py",
          "lineno": 200,
          "message": "AssertionError: ClientError not raised"
        },
        "traceback": [
          {
            "path": "test\\test_http.py",
            "lineno": 19,
            "message": "AssertionError"
          }
        ],
        "longrepr": "self = <test.test_http.HTTPTest testMethod=test_handle_errors_client_error_with_exception_text>\n\n    def test_handle_errors_client_error_with_exception_text(self):\n>       with self.assertRaises(ClientError):\nE       AssertionError: ClientError not raised\n\ntest\\test_http.py:19: AssertionError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_async_get_forecast_by_coordinates",
      "lineno": 51,
      "outcome": "failed",
      "keywords": [
        "test_async_get_forecast_by_coordinates",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 55,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 687,
            "message": "in run_until_complete"
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 110,
            "message": "in async_forecast_by_coordinates"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\concurrent\\futures\\thread.py",
            "lineno": 58,
            "message": "in run"
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 98,
            "message": "in forecast_by_coordinates"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_async_get_forecast_by_coordinates>\nmock_get = <MagicMock name='get' id='2232925597104'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_coordinate_forecast_response)\n    def test_async_get_forecast_by_coordinates(self, mock_get):\n        loop = asyncio.get_event_loop()\n>       forecast = loop.run_until_complete(fmi_weather_client.async_forecast_by_coordinates(67.583988, 29.742731))\n\ntest\\test_init.py:55: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:687: in run_until_complete\n    return future.result()\nfmi_weather_client\\__init__.py:110: in async_forecast_by_coordinates\n    return await loop.run_in_executor(None, forecast_by_coordinates, lat, lon, timestep_hours)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\concurrent\\futures\\thread.py:58: in run\n    result = self.fn(*self.args, **self.kwargs)\nfmi_weather_client\\__init__.py:98: in forecast_by_coordinates\n    return forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nxml_input = <coroutine object request_forecast_by_coordinates at 0x00000207E7A94B40>\nencoding = None\nexpat = <module 'xml.parsers.expat' from 'C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\xml\\\\parsers\\\\expat.py'>\nprocess_namespaces = False, namespace_separator = None, disable_entities = True\nprocess_comments = False, kwargs = {}\nhandler = <xmltodict._DictSAXHandler object at 0x00000207E68FA2A0>\nparser = <pyexpat.xmlparser object at 0x00000207E7A85780>\nfeature = 'http://apache.org/xml/features/disallow-doctype-decl'\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_async_get_forecast_by_place_name",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_async_get_forecast_by_place_name",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 44,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 687,
            "message": "in run_until_complete"
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 86,
            "message": "in async_forecast_by_place_name"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\concurrent\\futures\\thread.py",
            "lineno": 58,
            "message": "in run"
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 75,
            "message": "in forecast_by_place_name"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_async_get_forecast_by_place_name>\nmock_get = <MagicMock name='get' id='2232974857168'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_place_forecast_response)\n    def test_async_get_forecast_by_place_name(self, mock_get):\n        loop = asyncio.get_event_loop()\n>       forecast = loop.run_until_complete(fmi_weather_client.async_forecast_by_place_name('Iisalmi'))\n\ntest\\test_init.py:44: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:687: in run_until_complete\n    return future.result()\nfmi_weather_client\\__init__.py:86: in async_forecast_by_place_name\n    return await loop.run_in_executor(None, forecast_by_place_name, name, timestep_hours)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\concurrent\\futures\\thread.py:58: in run\n    result = self.fn(*self.args, **self.kwargs)\nfmi_weather_client\\__init__.py:75: in forecast_by_place_name\n    return forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nxml_input = <coroutine object request_forecast_by_place at 0x00000207E7BAC7C0>\nencoding = None\nexpat = <module 'xml.parsers.expat' from 'C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\xml\\\\parsers\\\\expat.py'>\nprocess_namespaces = False, namespace_separator = None, disable_entities = True\nprocess_comments = False, kwargs = {}\nhandler = <xmltodict._DictSAXHandler object at 0x00000207E7AC5130>\nparser = <pyexpat.xmlparser object at 0x00000207E7B55F60>\nfeature = 'http://apache.org/xml/features/disallow-doctype-decl'\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_async_get_weather_by_coordinates",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_async_get_weather_by_coordinates",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 33,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 687,
            "message": "in run_until_complete"
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 37,
            "message": "in async_weather_by_coordinates"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\concurrent\\futures\\thread.py",
            "lineno": 58,
            "message": "in run"
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 19,
            "message": "in weather_by_coordinates"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_async_get_weather_by_coordinates>\nmock_get = <MagicMock name='get' id='2232974856208'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_coordinate_forecast_response)\n    def test_async_get_weather_by_coordinates(self, mock_get):\n        loop = asyncio.get_event_loop()\n>       weather = loop.run_until_complete(fmi_weather_client.async_weather_by_coordinates(63.14343, 27.31317))\n\ntest\\test_init.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:687: in run_until_complete\n    return future.result()\nfmi_weather_client\\__init__.py:37: in async_weather_by_coordinates\n    return await loop.run_in_executor(None, weather_by_coordinates, lat, lon)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\concurrent\\futures\\thread.py:58: in run\n    result = self.fn(*self.args, **self.kwargs)\nfmi_weather_client\\__init__.py:19: in weather_by_coordinates\n    forecast = forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nxml_input = <coroutine object request_weather_by_coordinates at 0x00000207E7BACA90>\nencoding = None\nexpat = <module 'xml.parsers.expat' from 'C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\xml\\\\parsers\\\\expat.py'>\nprocess_namespaces = False, namespace_separator = None, disable_entities = True\nprocess_comments = False, kwargs = {}\nhandler = <xmltodict._DictSAXHandler object at 0x00000207E7AC7020>\nparser = <pyexpat.xmlparser object at 0x00000207E7B57AC0>\nfeature = 'http://apache.org/xml/features/disallow-doctype-decl'\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_async_get_weather_by_place",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_async_get_weather_by_place",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 687,
            "message": "in run_until_complete"
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 64,
            "message": "in async_weather_by_place_name"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\concurrent\\futures\\thread.py",
            "lineno": 58,
            "message": "in run"
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 48,
            "message": "in weather_by_place_name"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_async_get_weather_by_place>\nmock_get = <MagicMock name='get' id='2232974404560'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_place_forecast_response)\n    def test_async_get_weather_by_place(self, mock_get):\n        loop = asyncio.get_event_loop()\n>       weather = loop.run_until_complete(fmi_weather_client.async_weather_by_place_name('Iisalmi'))\n\ntest\\test_init.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:687: in run_until_complete\n    return future.result()\nfmi_weather_client\\__init__.py:64: in async_weather_by_place_name\n    return await loop.run_in_executor(None, weather_by_place_name, name)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\concurrent\\futures\\thread.py:58: in run\n    result = self.fn(*self.args, **self.kwargs)\nfmi_weather_client\\__init__.py:48: in weather_by_place_name\n    forecast = forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nxml_input = <coroutine object request_weather_by_place at 0x00000207E7A89C40>\nencoding = None\nexpat = <module 'xml.parsers.expat' from 'C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\xml\\\\parsers\\\\expat.py'>\nprocess_namespaces = False, namespace_separator = None, disable_entities = True\nprocess_comments = False, kwargs = {}\nhandler = <xmltodict._DictSAXHandler object at 0x00000207E7A56C00>\nparser = <pyexpat.xmlparser object at 0x00000207E7B411E0>\nfeature = 'http://apache.org/xml/features/disallow-doctype-decl'\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_get_forecast_by_coordinates",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_get_forecast_by_coordinates",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 98,
            "message": "in forecast_by_coordinates"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_get_forecast_by_coordinates>\nmock_get = <MagicMock name='get' id='2232974863696'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_coordinate_forecast_response)\n    def test_get_forecast_by_coordinates(self, mock_get):\n>       forecast = fmi_weather_client.forecast_by_coordinates(29.742731, 67.583988)\n\ntest\\test_init.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nfmi_weather_client\\__init__.py:98: in forecast_by_coordinates\n    return forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nxml_input = <coroutine object request_forecast_by_coordinates at 0x00000207E7A95240>\nencoding = None\nexpat = <module 'xml.parsers.expat' from 'C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\xml\\\\parsers\\\\expat.py'>\nprocess_namespaces = False, namespace_separator = None, disable_entities = True\nprocess_comments = False, kwargs = {}\nhandler = <xmltodict._DictSAXHandler object at 0x00000207E7AC6270>\nparser = <pyexpat.xmlparser object at 0x00000207E7B43460>\nfeature = 'http://apache.org/xml/features/disallow-doctype-decl'\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_get_forecast_by_place_name",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_get_forecast_by_place_name",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 38,
            "message": ""
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 75,
            "message": "in forecast_by_place_name"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_get_forecast_by_place_name>\nmock_get = <MagicMock name='get' id='2232975016256'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_place_forecast_response)\n    def test_get_forecast_by_place_name(self, mock_get):\n>       forecast = fmi_weather_client.forecast_by_place_name('Iisalmi')\n\ntest\\test_init.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nfmi_weather_client\\__init__.py:75: in forecast_by_place_name\n    return forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nxml_input = <coroutine object request_forecast_by_place at 0x00000207E7BACC70>\nencoding = None\nexpat = <module 'xml.parsers.expat' from 'C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\xml\\\\parsers\\\\expat.py'>\nprocess_namespaces = False, namespace_separator = None, disable_entities = True\nprocess_comments = False, kwargs = {}\nhandler = <xmltodict._DictSAXHandler object at 0x00000207E7AEC110>\nparser = <pyexpat.xmlparser object at 0x00000207E7B42680>\nfeature = 'http://apache.org/xml/features/disallow-doctype-decl'\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_get_weather_by_coordinates",
      "lineno": 24,
      "outcome": "failed",
      "keywords": [
        "test_get_weather_by_coordinates",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 27,
            "message": ""
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 19,
            "message": "in weather_by_coordinates"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_get_weather_by_coordinates>\nmock_get = <MagicMock name='get' id='2232974857888'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_coordinate_forecast_response)\n    def test_get_weather_by_coordinates(self, mock_get):\n>       weather = fmi_weather_client.weather_by_coordinates(63.14343, 27.31317)\n\ntest\\test_init.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nfmi_weather_client\\__init__.py:19: in weather_by_coordinates\n    forecast = forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nxml_input = <coroutine object request_weather_by_coordinates at 0x00000207E7BAC6D0>\nencoding = None\nexpat = <module 'xml.parsers.expat' from 'C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\xml\\\\parsers\\\\expat.py'>\nprocess_namespaces = False, namespace_separator = None, disable_entities = True\nprocess_comments = False, kwargs = {}\nhandler = <xmltodict._DictSAXHandler object at 0x00000207E7AC56D0>\nparser = <pyexpat.xmlparser object at 0x00000207E7B40340>\nfeature = 'http://apache.org/xml/features/disallow-doctype-decl'\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_get_weather_by_place",
      "lineno": 13,
      "outcome": "failed",
      "keywords": [
        "test_get_weather_by_place",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 16,
            "message": ""
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 48,
            "message": "in weather_by_place_name"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_get_weather_by_place>\nmock_get = <MagicMock name='get' id='2232974403216'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_place_forecast_response)\n    def test_get_weather_by_place(self, mock_get):\n>       weather = fmi_weather_client.weather_by_place_name('Iisalmi')\n\ntest\\test_init.py:16: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nfmi_weather_client\\__init__.py:48: in weather_by_place_name\n    forecast = forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nxml_input = <coroutine object request_weather_by_place at 0x00000207E7A8A7A0>\nencoding = None\nexpat = <module 'xml.parsers.expat' from 'C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\xml\\\\parsers\\\\expat.py'>\nprocess_namespaces = False, namespace_separator = None, disable_entities = True\nprocess_comments = False, kwargs = {}\nhandler = <xmltodict._DictSAXHandler object at 0x00000207E7A56600>\nparser = <pyexpat.xmlparser object at 0x00000207E7B436A0>\nfeature = 'http://apache.org/xml/features/disallow-doctype-decl'\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_invalid_lat_lon_exception_response",
      "lineno": 80,
      "outcome": "failed",
      "keywords": [
        "test_invalid_lat_lon_exception_response",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 84,
            "message": ""
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 19,
            "message": "in weather_by_coordinates"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_invalid_lat_lon_exception_response>\nmock_get = <MagicMock name='get' id='2232975023600'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_invalid_lat_lon_exception_response)\n    def test_invalid_lat_lon_exception_response(self, mock_get):\n        with self.assertRaises(ClientError):\n>           fmi_weather_client.weather_by_coordinates(27.31317, 63.14343)\n\ntest\\test_init.py:84: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nfmi_weather_client\\__init__.py:19: in weather_by_coordinates\n    forecast = forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_nil_forecast_response",
      "lineno": 65,
      "outcome": "failed",
      "keywords": [
        "test_nil_forecast_response",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 68,
            "message": ""
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 98,
            "message": "in forecast_by_coordinates"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_nil_forecast_response>\nmock_get = <MagicMock name='get' id='2232975031040'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_nan_response)\n    def test_nil_forecast_response(self, mock_get):\n>       forecast_coord = fmi_weather_client.forecast_by_coordinates(25.46816, 65.01236, 24)\n\ntest\\test_init.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nfmi_weather_client\\__init__.py:98: in forecast_by_coordinates\n    return forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nxml_input = <coroutine object request_forecast_by_coordinates at 0x00000207E7A97140>\nencoding = None\nexpat = <module 'xml.parsers.expat' from 'C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\xml\\\\parsers\\\\expat.py'>\nprocess_namespaces = False, namespace_separator = None, disable_entities = True\nprocess_comments = False, kwargs = {}\nhandler = <xmltodict._DictSAXHandler object at 0x00000207E7AEDE20>\nparser = <pyexpat.xmlparser object at 0x00000207E7AE1CC0>\nfeature = 'http://apache.org/xml/features/disallow-doctype-decl'\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_nil_weather_response",
      "lineno": 58,
      "outcome": "failed",
      "keywords": [
        "test_nil_weather_response",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 61,
            "message": ""
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 19,
            "message": "in weather_by_coordinates"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_nil_weather_response>\nmock_get = <MagicMock name='get' id='2232975026096'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_nan_response)\n    def test_nil_weather_response(self, mock_get):\n>       weather_coord = fmi_weather_client.weather_by_coordinates(25.46816, 65.01236)\n\ntest\\test_init.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nfmi_weather_client\\__init__.py:19: in weather_by_coordinates\n    forecast = forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nxml_input = <coroutine object request_weather_by_coordinates at 0x00000207E7BAC7C0>\nencoding = None\nexpat = <module 'xml.parsers.expat' from 'C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python312\\\\Lib\\\\xml\\\\parsers\\\\expat.py'>\nprocess_namespaces = False, namespace_separator = None, disable_entities = True\nprocess_comments = False, kwargs = {}\nhandler = <xmltodict._DictSAXHandler object at 0x00000207E7AEE7E0>\nparser = <pyexpat.xmlparser object at 0x00000207E7B40400>\nfeature = 'http://apache.org/xml/features/disallow-doctype-decl'\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_no_data_available_exception_response",
      "lineno": 85,
      "outcome": "failed",
      "keywords": [
        "test_no_data_available_exception_response",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 89,
            "message": ""
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 19,
            "message": "in weather_by_coordinates"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_no_data_available_exception_response>\nmock_get = <MagicMock name='get' id='2232974404512'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_no_data_available_exception_response)\n    def test_no_data_available_exception_response(self, mock_get):\n        with self.assertRaises(ClientError):\n>           fmi_weather_client.weather_by_coordinates(27.31317, 63.14343)\n\ntest\\test_init.py:89: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nfmi_weather_client\\__init__.py:19: in weather_by_coordinates\n    forecast = forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_no_location_exception_response",
      "lineno": 75,
      "outcome": "failed",
      "keywords": [
        "test_no_location_exception_response",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 79,
            "message": ""
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 19,
            "message": "in weather_by_coordinates"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_no_location_exception_response>\nmock_get = <MagicMock name='get' id='2232974991120'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_no_location_exception_response)\n    def test_no_location_exception_response(self, mock_get):\n        with self.assertRaises(ClientError):\n>           fmi_weather_client.weather_by_coordinates(27.31317, 63.14343)\n\ntest\\test_init.py:79: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nfmi_weather_client\\__init__.py:19: in weather_by_coordinates\n    forecast = forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_init.py::FMIWeatherTest::test_server_error_response",
      "lineno": 90,
      "outcome": "failed",
      "keywords": [
        "test_server_error_response",
        "__wrapped__",
        "patchings",
        "FMIWeatherTest",
        "test_init.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\.venv\\Lib\\site-packages\\xmltodict.py",
          "lineno": 359,
          "message": "TypeError: a bytes-like object is required, not 'coroutine'"
        },
        "traceback": [
          {
            "path": "test\\test_init.py",
            "lineno": 94,
            "message": ""
          },
          {
            "path": "fmi_weather_client\\__init__.py",
            "lineno": 19,
            "message": "in weather_by_coordinates"
          },
          {
            "path": "fmi_weather_client\\parsers\\forecast.py",
            "lineno": 19,
            "message": "in parse_forecast"
          },
          {
            "path": ".venv\\Lib\\site-packages\\xmltodict.py",
            "lineno": 359,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test.test_init.FMIWeatherTest testMethod=test_server_error_response>\nmock_get = <MagicMock name='get' id='2232974996784'>\n\n    @mock.patch('requests.get', side_effect=test_data.mock_server_error_response)\n    def test_server_error_response(self, mock_get):\n        with self.assertRaises(ServerError):\n>           fmi_weather_client.weather_by_coordinates(27.31317, 63.14343)\n\ntest\\test_init.py:94: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nfmi_weather_client\\__init__.py:19: in weather_by_coordinates\n    forecast = forecast_parser.parse_forecast(response)\nfmi_weather_client\\parsers\\forecast.py:19: in parse_forecast\n    data = xmltodict.parse(body)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,\n              namespace_separator=':', disable_entities=True, process_comments=False, **kwargs):\n        \"\"\"Parse the given XML input and convert it into a dictionary.\n    \n        `xml_input` can either be a `string`, a file-like object, or a generator of strings.\n    \n        If `xml_attribs` is `True`, element attributes are put in the dictionary\n        among regular child elements, using `@` as a prefix to avoid collisions. If\n        set to `False`, they are just ignored.\n    \n        Simple example::\n    \n            >>> import xmltodict\n            >>> doc = xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\n            ... \\\"\\\"\\\")\n            >>> doc['a']['@prop']\n            u'x'\n            >>> doc['a']['b']\n            [u'1', u'2']\n    \n        If `item_depth` is `0`, the function returns a dictionary for the root\n        element (default behavior). Otherwise, it calls `item_callback` every time\n        an item at the specified depth is found and returns `None` in the end\n        (streaming mode).\n    \n        The callback function receives two parameters: the `path` from the document\n        root to the item (name-attribs pairs), and the `item` (dict). If the\n        callback's return value is false-ish, parsing will be stopped with the\n        :class:`ParsingInterrupted` exception.\n    \n        Streaming example::\n    \n            >>> def handle(path, item):\n            ...     print('path:%s item:%s' % (path, item))\n            ...     return True\n            ...\n            >>> xmltodict.parse(\\\"\\\"\\\"\n            ... <a prop=\"x\">\n            ...   <b>1</b>\n            ...   <b>2</b>\n            ... </a>\\\"\\\"\\\", item_depth=2, item_callback=handle)\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:1\n            path:[(u'a', {u'prop': u'x'}), (u'b', None)] item:2\n    \n        The optional argument `postprocessor` is a function that takes `path`,\n        `key` and `value` as positional arguments and returns a new `(key, value)`\n        pair where both `key` and `value` may have changed. Usage example::\n    \n            >>> def postprocessor(path, key, value):\n            ...     try:\n            ...         return key + ':int', int(value)\n            ...     except (ValueError, TypeError):\n            ...         return key, value\n            >>> xmltodict.parse('<a><b>1</b><b>2</b><b>x</b></a>',\n            ...                 postprocessor=postprocessor)\n            {'a': {'b:int': [1, 2], 'b': 'x'}}\n    \n        You can pass an alternate version of `expat` (such as `defusedexpat`) by\n        using the `expat` parameter. E.g:\n    \n            >>> import defusedexpat\n            >>> xmltodict.parse('<a>hello</a>', expat=defusedexpat.pyexpat)\n            {'a': 'hello'}\n    \n        You can use the force_list argument to force lists to be created even\n        when there is only a single child of a given level of hierarchy. The\n        force_list argument is a tuple of keys. If the key for a given level\n        of hierarchy is in the force_list argument, that level of hierarchy\n        will have a list as a child (even if there is only one sub-element).\n        The index_keys operation takes precedence over this. This is applied\n        after any user-supplied postprocessor has already run.\n    \n            For example, given this input:\n            <servers>\n              <server>\n                <name>host1</name>\n                <os>Linux</os>\n                <interfaces>\n                  <interface>\n                    <name>em0</name>\n                    <ip_address>10.0.0.1</ip_address>\n                  </interface>\n                </interfaces>\n              </server>\n            </servers>\n    \n            If called with force_list=('interface',), it will produce\n            this dictionary:\n            {'servers':\n              {'server':\n                {'name': 'host1',\n                 'os': 'Linux'},\n                 'interfaces':\n                  {'interface':\n                    [ {'name': 'em0', 'ip_address': '10.0.0.1' } ] } } }\n    \n            `force_list` can also be a callable that receives `path`, `key` and\n            `value`. This is helpful in cases where the logic that decides whether\n            a list should be forced is more complex.\n    \n    \n            If `process_comment` is `True` then comment will be added with comment_key\n            (default=`'#comment'`) to then tag which contains comment\n    \n                For example, given this input:\n                <a>\n                  <b>\n                    <!-- b comment -->\n                    <c>\n                        <!-- c comment -->\n                        1\n                    </c>\n                    <d>2</d>\n                  </b>\n                </a>\n    \n                If called with process_comment=True, it will produce\n                this dictionary:\n                'a': {\n                    'b': {\n                        '#comment': 'b comment',\n                        'c': {\n    \n                            '#comment': 'c comment',\n                            '#text': '1',\n                        },\n                        'd': '2',\n                    },\n                }\n        \"\"\"\n        handler = _DictSAXHandler(namespace_separator=namespace_separator,\n                                  **kwargs)\n        if isinstance(xml_input, str):\n            encoding = encoding or 'utf-8'\n            xml_input = xml_input.encode(encoding)\n        if not process_namespaces:\n            namespace_separator = None\n        parser = expat.ParserCreate(\n            encoding,\n            namespace_separator\n        )\n        try:\n            parser.ordered_attributes = True\n        except AttributeError:\n            # Jython's expat does not support ordered_attributes\n            pass\n        parser.StartNamespaceDeclHandler = handler.startNamespaceDecl\n        parser.StartElementHandler = handler.startElement\n        parser.EndElementHandler = handler.endElement\n        parser.CharacterDataHandler = handler.characters\n        if process_comments:\n            parser.CommentHandler = handler.comments\n        parser.buffer_text = True\n        if disable_entities:\n            try:\n                # Attempt to disable DTD in Jython's expat parser (Xerces-J).\n                feature = \"http://apache.org/xml/features/disallow-doctype-decl\"\n                parser._reader.setFeature(feature, True)\n            except AttributeError:\n                # For CPython / expat parser.\n                # Anything not handled ends up here and entities aren't expanded.\n                parser.DefaultHandler = lambda x: None\n                # Expects an integer return; zero means failure -> expat.ExpatError.\n                parser.ExternalEntityRefHandler = lambda *x: 1\n        if hasattr(xml_input, 'read'):\n            parser.ParseFile(xml_input)\n        elif isgenerator(xml_input):\n            for chunk in xml_input:\n                parser.Parse(chunk, False)\n            parser.Parse(b'', True)\n        else:\n>           parser.Parse(xml_input, True)\nE           TypeError: a bytes-like object is required, not 'coroutine'\n\n.venv\\Lib\\site-packages\\xmltodict.py:359: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_models.py::ModelsTest::test_fmi_place",
      "lineno": 6,
      "outcome": "passed",
      "keywords": [
        "test_fmi_place",
        "ModelsTest",
        "test_models.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_models.py::ModelsTest::test_value",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_value",
        "ModelsTest",
        "test_models.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_parsers_forecast.py::ForecastParserTest::test_feels_like",
      "lineno": 15,
      "outcome": "passed",
      "keywords": [
        "test_feels_like",
        "ForecastParserTest",
        "test_parsers_forecast.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "test/test_parsers_forecast.py::ForecastParserTest::test_float_or_none",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_float_or_none",
        "ForecastParserTest",
        "test_parsers_forecast.py",
        "test",
        "saaste@fmi-weather-client__dfdda122__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    }
  ],
  "warnings": [
    {
      "message": "coroutine '_handle_errors' was never awaited",
      "category": "RuntimeWarning",
      "when": "runtest",
      "filename": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\test\\test_http.py",
      "lineno": 29
    },
    {
      "message": "There is no current event loop",
      "category": "DeprecationWarning",
      "when": "runtest",
      "filename": "D:\\repos\\saaste@fmi-weather-client__dfdda122__requests__treq\\test\\test_init.py",
      "lineno": 54
    },
    {
      "message": "coroutine 'request_weather_by_coordinates' was never awaited",
      "category": "RuntimeWarning",
      "when": "runtest",
      "filename": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py",
      "lineno": 241
    },
    {
      "message": "coroutine 'request_weather_by_coordinates' was never awaited",
      "category": "RuntimeWarning",
      "when": "runtest",
      "filename": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py",
      "lineno": 241
    },
    {
      "message": "coroutine 'request_weather_by_coordinates' was never awaited",
      "category": "RuntimeWarning",
      "when": "runtest",
      "filename": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py",
      "lineno": 241
    },
    {
      "message": "coroutine 'request_weather_by_coordinates' was never awaited",
      "category": "RuntimeWarning",
      "when": "runtest",
      "filename": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py",
      "lineno": 241
    }
  ]
}