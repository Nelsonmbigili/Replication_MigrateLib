{
  "exitcode": 1,
  "summary": {
    "passed": 471,
    "failed": 528,
    "total": 999,
    "collected": 999
  },
  "collectors": [
    {
      "nodeid": "",
      "outcome": "passed",
      "result": [
        {
          "nodeid": ".",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "docs/src/api",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "docs/src",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "docs/src/api",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "docs",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "docs/src",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "pycamunda",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "pycamunda.egg-info",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/activityinst/test_activityinstance.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/activityinst/test_activityinstance.py::test_activity_instance_load",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/activityinst/test_activityinstance.py::test_activity_instance_load_raises_keyerror",
          "type": "Function",
          "lineno": 57
        }
      ]
    },
    {
      "nodeid": "tests/activityinst/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/activityinst/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/activityinst/test_transitioninstance.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/activityinst/test_transitioninstance.py::test_transition_instance_load",
          "type": "Function",
          "lineno": 16
        },
        {
          "nodeid": "tests/activityinst/test_transitioninstance.py::test_transition_instance_load_raises_keyerror",
          "type": "Function",
          "lineno": 34
        }
      ]
    },
    {
      "nodeid": "tests/activityinst",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/activityinst/test_activityinstance.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/activityinst/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/activityinst/test_transitioninstance.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/auth/test_authorization.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/auth/test_authorization.py::test_authorization_load",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/auth/test_authorization.py::test_authorization_load_raises_keyerror",
          "type": "Function",
          "lineno": 25
        }
      ]
    },
    {
      "nodeid": "tests/auth/test_check.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/auth/test_check.py::test_check_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/auth/test_check.py::test_check_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/auth/test_check.py::test_check_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/auth/test_check.py::test_check_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/auth/test_check.py::test_check_returns_permission",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/auth/test_count.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/auth/test_count.py::test_count_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/auth/test_count.py::test_count_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/auth/test_count.py::test_count_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/auth/test_count.py::test_count_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/auth/test_count.py::test_count_returns_authorizations",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/auth/test_create.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/auth/test_create.py::test_create_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/auth/test_create.py::test_create_raises_assert",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/auth/test_create.py::test_create_calls_requests",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/auth/test_create.py::test_create_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 39
        },
        {
          "nodeid": "tests/auth/test_create.py::test_create_raises_for_status",
          "type": "Function",
          "lineno": 46
        },
        {
          "nodeid": "tests/auth/test_create.py::test_create_returns_authorization",
          "type": "Function",
          "lineno": 56
        }
      ]
    },
    {
      "nodeid": "tests/auth/test_delete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/auth/test_delete.py::test_delete_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/auth/test_delete.py::test_delete_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/auth/test_delete.py::test_delete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/auth/test_delete.py::test_delete_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/auth/test_delete.py::test_delete_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/auth/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/auth/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/auth/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/auth/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/auth/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/auth/test_get.py::test_get_returns_authorizations",
          "type": "Function",
          "lineno": 46
        }
      ]
    },
    {
      "nodeid": "tests/auth/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/auth/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/auth/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/auth/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/auth/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/auth/test_getlist.py::test_getlist_returns_authorizations",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/auth/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/auth/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/auth/test_options.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/auth/test_options.py::test_options_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/auth/test_options.py::test_options_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/auth/test_options.py::test_options_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/auth/test_options.py::test_options_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/auth/test_options.py::test_options_returns_resource_options",
          "type": "Function",
          "lineno": 46
        }
      ]
    },
    {
      "nodeid": "tests/auth/test_update.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/auth/test_update.py::test_update_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/auth/test_update.py::test_update_raises_assert",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/auth/test_update.py::test_update_calls_requests",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/auth/test_update.py::test_update_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/auth/test_update.py::test_update_raises_for_status",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/auth/test_update.py::test_update_returns_none",
          "type": "Function",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/auth",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/auth/test_authorization.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/auth/test_check.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/auth/test_count.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/auth/test_create.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/auth/test_delete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/auth/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/auth/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/auth/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/auth/test_options.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/auth/test_update.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/base/test_camundarequest.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/base/test_camundarequest.py::test_camundarequest_keeps_query_params",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/base/test_camundarequest.py::test_camundarequest_keeps_body_params",
          "type": "Function",
          "lineno": 13
        },
        {
          "nodeid": "tests/base/test_camundarequest.py::test_camundarequest_converts_bool_query_params",
          "type": "Function",
          "lineno": 21
        },
        {
          "nodeid": "tests/base/test_camundarequest.py::test_camundarequest_converts_datetime_params",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/base/test_camundarequest.py::test_camundarequest_session",
          "type": "Function",
          "lineno": 38
        }
      ]
    },
    {
      "nodeid": "tests/base",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/base/test_camundarequest.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/batch/test_activatesuspend.py::test_activate_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/batch/test_activatesuspend.py::test_activate_path",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/batch/test_activatesuspend.py::test_activate_calls_requests",
          "type": "Function",
          "lineno": 25
        },
        {
          "nodeid": "tests/batch/test_activatesuspend.py::test_activate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/batch/test_activatesuspend.py::test_activate_raises_for_status",
          "type": "Function",
          "lineno": 41
        },
        {
          "nodeid": "tests/batch/test_activatesuspend.py::test_activate_returns_none",
          "type": "Function",
          "lineno": 50
        },
        {
          "nodeid": "tests/batch/test_activatesuspend.py::test_suspend_params",
          "type": "Function",
          "lineno": 58
        },
        {
          "nodeid": "tests/batch/test_activatesuspend.py::test_suspend_path",
          "type": "Function",
          "lineno": 66
        },
        {
          "nodeid": "tests/batch/test_activatesuspend.py::test_suspend_calls_requests",
          "type": "Function",
          "lineno": 72
        },
        {
          "nodeid": "tests/batch/test_activatesuspend.py::test_suspend_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 80
        },
        {
          "nodeid": "tests/batch/test_activatesuspend.py::test_suspend_raises_for_status",
          "type": "Function",
          "lineno": 87
        },
        {
          "nodeid": "tests/batch/test_activatesuspend.py::test_suspend_returns_none",
          "type": "Function",
          "lineno": 96
        }
      ]
    },
    {
      "nodeid": "tests/batch/test_batch.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/batch/test_batch.py::test_batch_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/batch/test_batch.py::test_batch_load_raises_keyerror",
          "type": "Function",
          "lineno": 24
        }
      ]
    },
    {
      "nodeid": "tests/batch/test_batchstatistics.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/batch/test_batchstatistics.py::test_batchstats_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/batch/test_batchstatistics.py::test_batchstats_load_raises_keyerror",
          "type": "Function",
          "lineno": 27
        }
      ]
    },
    {
      "nodeid": "tests/batch/test_count.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/batch/test_count.py::test_count_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/batch/test_count.py::test_count_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/batch/test_count.py::test_count_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/batch/test_count.py::test_count_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/batch/test_count.py::test_count_returns_int",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/batch/test_countstats.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/batch/test_countstats.py::test_countstats_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/batch/test_countstats.py::test_countstats_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/batch/test_countstats.py::test_countstats_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/batch/test_countstats.py::test_countstats_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/batch/test_countstats.py::test_countstats_returns_int",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/batch/test_delete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/batch/test_delete.py::test_delete_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/batch/test_delete.py::test_delete_path",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/batch/test_delete.py::test_delete_calls_requests",
          "type": "Function",
          "lineno": 24
        },
        {
          "nodeid": "tests/batch/test_delete.py::test_delete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/batch/test_delete.py::test_delete_raises_for_status",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/batch/test_delete.py::test_delete_returns_none",
          "type": "Function",
          "lineno": 49
        }
      ]
    },
    {
      "nodeid": "tests/batch/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/batch/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/batch/test_get.py::test_get_path",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/batch/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 24
        },
        {
          "nodeid": "tests/batch/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/batch/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/batch/test_get.py::test_get_returns_batch",
          "type": "Function",
          "lineno": 50
        }
      ]
    },
    {
      "nodeid": "tests/batch/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/batch/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/batch/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/batch/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/batch/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/batch/test_getlist.py::test_getlist_returns_batches",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/batch/test_getstats.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/batch/test_getstats.py::test_getstats_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/batch/test_getstats.py::test_getstats_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/batch/test_getstats.py::test_getstats_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/batch/test_getstats.py::test_getstats_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/batch/test_getstats.py::test_getstats_returns_batchstats",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/batch/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/batch/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/batch",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/batch/test_activatesuspend.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/batch/test_batch.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/batch/test_batchstatistics.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/batch/test_count.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/batch/test_countstats.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/batch/test_delete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/batch/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/batch/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/batch/test_getstats.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/batch/test_module.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/casedef/test_casedefinition.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/casedef/test_casedefinition.py::test_case_definition_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/casedef/test_casedefinition.py::test_case_definition_load_raises_keyerror",
          "type": "Function",
          "lineno": 21
        }
      ]
    },
    {
      "nodeid": "tests/casedef/test_count.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/casedef/test_count.py::test_count_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/casedef/test_count.py::test_count_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/casedef/test_count.py::test_count_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/casedef/test_count.py::test_count_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/casedef/test_count.py::test_count_returns_response_content",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/casedef/test_createinstance.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/casedef/test_createinstance.py::test_createinstance_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/casedef/test_createinstance.py::test_createinstance_path",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/casedef/test_createinstance.py::test_createinstance_calls_requests",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/casedef/test_createinstance.py::test_createinstance_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 53
        },
        {
          "nodeid": "tests/casedef/test_createinstance.py::test_createinstance_raises_for_status",
          "type": "Function",
          "lineno": 60
        },
        {
          "nodeid": "tests/casedef/test_createinstance.py::test_createinstance_returns_caseinstance",
          "type": "Function",
          "lineno": 70
        }
      ]
    },
    {
      "nodeid": "tests/casedef/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/casedef/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/casedef/test_get.py::test_get_path",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/casedef/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/casedef/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/casedef/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/casedef/test_get.py::test_get_returns_casedefinition",
          "type": "Function",
          "lineno": 54
        }
      ]
    },
    {
      "nodeid": "tests/casedef/test_getdiagram.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/casedef/test_getdiagram.py::test_getdiagram_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/casedef/test_getdiagram.py::test_getdiagram_path",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/casedef/test_getdiagram.py::test_getdiagram_calls_requests",
          "type": "Function",
          "lineno": 31
        },
        {
          "nodeid": "tests/casedef/test_getdiagram.py::test_getdiagram_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/casedef/test_getdiagram.py::test_getdiagram_raises_for_status",
          "type": "Function",
          "lineno": 47
        },
        {
          "nodeid": "tests/casedef/test_getdiagram.py::test_getdiagram_returns_response_content",
          "type": "Function",
          "lineno": 56
        }
      ]
    },
    {
      "nodeid": "tests/casedef/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/casedef/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/casedef/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/casedef/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/casedef/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/casedef/test_getlist.py::test_getlist_returns_response_content",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/casedef/test_getxml.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/casedef/test_getxml.py::test_getxml_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/casedef/test_getxml.py::test_getxml_path",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/casedef/test_getxml.py::test_getxml_calls_requests",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/casedef/test_getxml.py::test_getxml_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/casedef/test_getxml.py::test_getxml_raises_for_status",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/casedef/test_getxml.py::test_getxml_returns_str",
          "type": "Function",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/casedef/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/casedef/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/casedef/test_updatehistorytimetolive.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/casedef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/casedef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_path",
          "type": "Function",
          "lineno": 21
        },
        {
          "nodeid": "tests/casedef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_calls_requests",
          "type": "Function",
          "lineno": 39
        },
        {
          "nodeid": "tests/casedef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 50
        },
        {
          "nodeid": "tests/casedef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_raises_for_status",
          "type": "Function",
          "lineno": 59
        },
        {
          "nodeid": "tests/casedef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_returns_none",
          "type": "Function",
          "lineno": 70
        }
      ]
    },
    {
      "nodeid": "tests/casedef",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/casedef/test_casedefinition.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/casedef/test_count.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/casedef/test_createinstance.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/casedef/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/casedef/test_getdiagram.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/casedef/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/casedef/test_getxml.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/casedef/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/casedef/test_updatehistorytimetolive.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/caseinst/test_caseinstance.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/caseinst/test_caseinstance.py::test_caseinstance_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/caseinst/test_caseinstance.py::test_caseinstance_load_raises_keyerror",
          "type": "Function",
          "lineno": 17
        }
      ]
    },
    {
      "nodeid": "tests/caseinst/test_close.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/caseinst/test_close.py::test_close_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/caseinst/test_close.py::test_close_calls_requests",
          "type": "Function",
          "lineno": 26
        },
        {
          "nodeid": "tests/caseinst/test_close.py::test_close_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/caseinst/test_close.py::test_close_raises_for_status",
          "type": "Function",
          "lineno": 42
        },
        {
          "nodeid": "tests/caseinst/test_close.py::test_close_returns_none",
          "type": "Function",
          "lineno": 51
        }
      ]
    },
    {
      "nodeid": "tests/caseinst/test_complete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/caseinst/test_complete.py::test_complete_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/caseinst/test_complete.py::test_complete_calls_requests",
          "type": "Function",
          "lineno": 26
        },
        {
          "nodeid": "tests/caseinst/test_complete.py::test_complete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/caseinst/test_complete.py::test_complete_raises_for_status",
          "type": "Function",
          "lineno": 42
        },
        {
          "nodeid": "tests/caseinst/test_complete.py::test_complete_returns_none",
          "type": "Function",
          "lineno": 51
        }
      ]
    },
    {
      "nodeid": "tests/caseinst/test_count.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/caseinst/test_count.py::test_count_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/caseinst/test_count.py::test_count_variable_params",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/caseinst/test_count.py::test_count_calls_requests",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/caseinst/test_count.py::test_count_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/caseinst/test_count.py::test_count_raises_for_status",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/caseinst/test_count.py::test_count_returns_int",
          "type": "Function",
          "lineno": 54
        }
      ]
    },
    {
      "nodeid": "tests/caseinst/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/caseinst/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/caseinst/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/caseinst/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/caseinst/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/caseinst/test_get.py::test_get_returns_casedefinition",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/caseinst/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/caseinst/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/caseinst/test_getlist.py::test_getlist_variable_params",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/caseinst/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/caseinst/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/caseinst/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/caseinst/test_getlist.py::test_getlist_returns_case_instances",
          "type": "Function",
          "lineno": 54
        }
      ]
    },
    {
      "nodeid": "tests/caseinst/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/caseinst/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/caseinst/test_terminate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/caseinst/test_terminate.py::test_terminate_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/caseinst/test_terminate.py::test_terminate_calls_requests",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/caseinst/test_terminate.py::test_terminate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/caseinst/test_terminate.py::test_terminate_raises_for_status",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/caseinst/test_terminate.py::test_terminate_returns_none",
          "type": "Function",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/caseinst",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/caseinst/test_caseinstance.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/caseinst/test_close.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/caseinst/test_complete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/caseinst/test_count.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/caseinst/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/caseinst/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/caseinst/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/caseinst/test_terminate.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/condition/test_correlate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/condition/test_correlate.py::test_evaluate_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/condition/test_correlate.py::test_evaluate_method_params",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/condition/test_correlate.py::test_evaluate_calls_requests",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/condition/test_correlate.py::test_evaluate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/condition/test_correlate.py::test_correlatesingle_raises_for_status",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/condition/test_correlate.py::test_evaluate_returns_processinstance",
          "type": "Function",
          "lineno": 54
        }
      ]
    },
    {
      "nodeid": "tests/condition/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/condition/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/condition",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/condition/test_correlate.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/condition/test_module.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/decisiondef/test_count.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/decisiondef/test_count.py::test_count_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/decisiondef/test_count.py::test_count_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/decisiondef/test_count.py::test_count_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/decisiondef/test_count.py::test_count_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/decisiondef/test_count.py::test_count_returns_response_content",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/decisiondef/test_decisiondefinition.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/decisiondef/test_decisiondefinition.py::test_decision_definition_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/decisiondef/test_decisiondefinition.py::test_decision_definition_load_raises_keyerror",
          "type": "Function",
          "lineno": 30
        }
      ]
    },
    {
      "nodeid": "tests/decisiondef/test_evaluate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/decisiondef/test_evaluate.py::test_evaluate_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/decisiondef/test_evaluate.py::test_evaluate_path",
          "type": "Function",
          "lineno": 22
        },
        {
          "nodeid": "tests/decisiondef/test_evaluate.py::test_evaluate_calls_requests",
          "type": "Function",
          "lineno": 39
        },
        {
          "nodeid": "tests/decisiondef/test_evaluate.py::test_evaluate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 48
        },
        {
          "nodeid": "tests/decisiondef/test_evaluate.py::test_evaluate_raises_for_status",
          "type": "Function",
          "lineno": 55
        },
        {
          "nodeid": "tests/decisiondef/test_evaluate.py::test_evaluate_returns_tuple",
          "type": "Function",
          "lineno": 67
        }
      ]
    },
    {
      "nodeid": "tests/decisiondef/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/decisiondef/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/decisiondef/test_get.py::test_get_path",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/decisiondef/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 32
        },
        {
          "nodeid": "tests/decisiondef/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 41
        },
        {
          "nodeid": "tests/decisiondef/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 48
        },
        {
          "nodeid": "tests/decisiondef/test_get.py::test_get_returns_decisiondefinition",
          "type": "Function",
          "lineno": 58
        }
      ]
    },
    {
      "nodeid": "tests/decisiondef/test_getdiagram.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/decisiondef/test_getdiagram.py::test_getdiagram_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/decisiondef/test_getdiagram.py::test_getdiagram_path",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/decisiondef/test_getdiagram.py::test_getdiagram_calls_requests",
          "type": "Function",
          "lineno": 32
        },
        {
          "nodeid": "tests/decisiondef/test_getdiagram.py::test_getdiagram_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 41
        },
        {
          "nodeid": "tests/decisiondef/test_getdiagram.py::test_getdiagram_raises_for_status",
          "type": "Function",
          "lineno": 48
        },
        {
          "nodeid": "tests/decisiondef/test_getdiagram.py::test_getdiagram_returns_response_content",
          "type": "Function",
          "lineno": 57
        }
      ]
    },
    {
      "nodeid": "tests/decisiondef/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/decisiondef/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/decisiondef/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/decisiondef/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/decisiondef/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/decisiondef/test_getlist.py::test_getlist_returns_response_content",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/decisiondef/test_getxml.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/decisiondef/test_getxml.py::test_getxml_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/decisiondef/test_getxml.py::test_getxml_path",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/decisiondef/test_getxml.py::test_getxml_calls_requests",
          "type": "Function",
          "lineno": 30
        },
        {
          "nodeid": "tests/decisiondef/test_getxml.py::test_getxml_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 39
        },
        {
          "nodeid": "tests/decisiondef/test_getxml.py::test_getxml_raises_for_status",
          "type": "Function",
          "lineno": 46
        },
        {
          "nodeid": "tests/decisiondef/test_getxml.py::test_getxml_returns_str",
          "type": "Function",
          "lineno": 55
        }
      ]
    },
    {
      "nodeid": "tests/decisiondef/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/decisiondef/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/decisiondef",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/decisiondef/test_count.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/decisiondef/test_decisiondefinition.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/decisiondef/test_evaluate.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/decisiondef/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/decisiondef/test_getdiagram.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/decisiondef/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/decisiondef/test_getxml.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/decisiondef/test_module.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/decisionreqdef/test_decisionrequirementsdefinition.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/decisionreqdef/test_decisionrequirementsdefinition.py::test_decision_requirements_definition_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/decisionreqdef/test_decisionrequirementsdefinition.py::test_decision_requirements_definition_load_raises_keyerror",
          "type": "Function",
          "lineno": 22
        }
      ]
    },
    {
      "nodeid": "tests/decisionreqdef/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/decisionreqdef/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/decisionreqdef",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/decisionreqdef/test_decisionrequirementsdefinition.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/decisionreqdef/test_module.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/deployment/test_create.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/deployment/test_create.py::test_create_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/deployment/test_create.py::test_create_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/deployment/test_create.py::test_create_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/deployment/test_create.py::test_create_raises_for_status",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/deployment/test_create.py::test_create_returns_deployment_with_definitions",
          "type": "Function",
          "lineno": 50
        }
      ]
    },
    {
      "nodeid": "tests/deployment/test_delete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/deployment/test_delete.py::test_delete_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/deployment/test_delete.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 22
        },
        {
          "nodeid": "tests/deployment/test_delete.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 31
        },
        {
          "nodeid": "tests/deployment/test_delete.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 38
        },
        {
          "nodeid": "tests/deployment/test_delete.py::test_get_returns_none",
          "type": "Function",
          "lineno": 47
        }
      ]
    },
    {
      "nodeid": "tests/deployment/test_deployment.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/deployment/test_deployment.py::test_deployment_load",
          "type": "Function",
          "lineno": 9
        },
        {
          "nodeid": "tests/deployment/test_deployment.py::test_deployment_load_raises_keyerror",
          "type": "Function",
          "lineno": 21
        }
      ]
    },
    {
      "nodeid": "tests/deployment/test_deploymentwithdefinitions.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/deployment/test_deploymentwithdefinitions.py::test_deployment_with_definitions_load",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/deployment/test_deploymentwithdefinitions.py::test_deployment_with_definitions_load_raises_keyerror",
          "type": "Function",
          "lineno": 35
        }
      ]
    },
    {
      "nodeid": "tests/deployment/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/deployment/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/deployment/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/deployment/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/deployment/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/deployment/test_get.py::test_get_returns_response_content",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/deployment/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/deployment/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/deployment/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/deployment/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/deployment/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/deployment/test_getlist.py::test_getlist_returns_response_content",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/deployment/test_getresource.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/deployment/test_getresource.py::test_getresource_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/deployment/test_getresource.py::test_getresource_binary_params",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/deployment/test_getresource.py::test_getresource_calls_requests",
          "type": "Function",
          "lineno": 30
        },
        {
          "nodeid": "tests/deployment/test_getresource.py::test_getresource_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 41
        },
        {
          "nodeid": "tests/deployment/test_getresource.py::test_getresource_raises_for_status",
          "type": "Function",
          "lineno": 50
        },
        {
          "nodeid": "tests/deployment/test_getresource.py::test_getresources_returns_resource",
          "type": "Function",
          "lineno": 62
        },
        {
          "nodeid": "tests/deployment/test_getresource.py::test_getresources_binary_returns_content",
          "type": "Function",
          "lineno": 72
        }
      ]
    },
    {
      "nodeid": "tests/deployment/test_getresources.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/deployment/test_getresources.py::test_getresources_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/deployment/test_getresources.py::test_getresources_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/deployment/test_getresources.py::test_getresources_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/deployment/test_getresources.py::test_getresources_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/deployment/test_getresources.py::test_getresources_returns_resources",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/deployment/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/deployment/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/deployment/test_resource.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/deployment/test_resource.py::test_resource_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/deployment/test_resource.py::test_resource_load_raises_keyerror",
          "type": "Function",
          "lineno": 17
        }
      ]
    },
    {
      "nodeid": "tests/deployment",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/deployment/test_create.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/deployment/test_delete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/deployment/test_deployment.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/deployment/test_deploymentwithdefinitions.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/deployment/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/deployment/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/deployment/test_getresource.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/deployment/test_getresources.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/deployment/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/deployment/test_resource.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/execution/test_execution.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/execution/test_execution.py::test_execution_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/execution/test_execution.py::test_execution_load_raises_keyerror",
          "type": "Function",
          "lineno": 16
        }
      ]
    },
    {
      "nodeid": "tests/execution/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/execution/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/execution",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/execution/test_execution.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/execution/test_module.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_complete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_complete.py::test_complete_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/externaltask/test_complete.py::test_complete_calls_requests",
          "type": "Function",
          "lineno": 26
        },
        {
          "nodeid": "tests/externaltask/test_complete.py::test_complete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/externaltask/test_complete.py::test_complete_raises_for_status",
          "type": "Function",
          "lineno": 42
        },
        {
          "nodeid": "tests/externaltask/test_complete.py::test_complete_returns_none",
          "type": "Function",
          "lineno": 51
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_count.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_count.py::test_count_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/externaltask/test_count.py::test_count_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/externaltask/test_count.py::test_count_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/externaltask/test_count.py::test_count_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/externaltask/test_count.py::test_count_returns_int",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_extendlock.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_extendlock.py::test_extendlock_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/externaltask/test_extendlock.py::test_extendlock_calls_requests",
          "type": "Function",
          "lineno": 23
        },
        {
          "nodeid": "tests/externaltask/test_extendlock.py::test_extendlock_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/externaltask/test_extendlock.py::test_extendlock_raises_for_status",
          "type": "Function",
          "lineno": 43
        },
        {
          "nodeid": "tests/externaltask/test_extendlock.py::test_extendlock_returns_none",
          "type": "Function",
          "lineno": 54
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_externaltask.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_externaltask.py::test_externaltask_load_definition",
          "type": "Function",
          "lineno": 9
        },
        {
          "nodeid": "tests/externaltask/test_externaltask.py::test_externaltask_load_definition_without_error_details",
          "type": "Function",
          "lineno": 38
        },
        {
          "nodeid": "tests/externaltask/test_externaltask.py::test_externaltask_load_raises_keyerror",
          "type": "Function",
          "lineno": 46
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_fetchandlock.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_fetchandlock.py::test_fetchandlock_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/externaltask/test_fetchandlock.py::test_fetchandlock_calls_requests",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/externaltask/test_fetchandlock.py::test_fetchandlock_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/externaltask/test_fetchandlock.py::test_fetchandlock_raises_for_status",
          "type": "Function",
          "lineno": 53
        },
        {
          "nodeid": "tests/externaltask/test_fetchandlock.py::test_fetchandlock_returns_tuple",
          "type": "Function",
          "lineno": 65
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/externaltask/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/externaltask/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/externaltask/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/externaltask/test_get.py::test_get_returns_none",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/externaltask/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/externaltask/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 30
        },
        {
          "nodeid": "tests/externaltask/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/externaltask/test_getlist.py::test_getlist_returns_tuple",
          "type": "Function",
          "lineno": 47
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_handlebpmnerror.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_handlebpmnerror.py::test_handlebpmnerror_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/externaltask/test_handlebpmnerror.py::test_handlebpmnerror_calls_requests",
          "type": "Function",
          "lineno": 30
        },
        {
          "nodeid": "tests/externaltask/test_handlebpmnerror.py::test_handlebpmnerror_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 41
        },
        {
          "nodeid": "tests/externaltask/test_handlebpmnerror.py::test_handlebpmnerror_raises_for_status",
          "type": "Function",
          "lineno": 50
        },
        {
          "nodeid": "tests/externaltask/test_handlebpmnerror.py::test_handlebpmnerror_returns_none",
          "type": "Function",
          "lineno": 61
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_handlefailure.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_handlefailure.py::test_handlefailure_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/externaltask/test_handlefailure.py::test_handlefailure_calls_requests",
          "type": "Function",
          "lineno": 32
        },
        {
          "nodeid": "tests/externaltask/test_handlefailure.py::test_handlefailure_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 49
        },
        {
          "nodeid": "tests/externaltask/test_handlefailure.py::test_handlefailure_raises_for_status",
          "type": "Function",
          "lineno": 64
        },
        {
          "nodeid": "tests/externaltask/test_handlefailure.py::test_handlefailure_returns_none",
          "type": "Function",
          "lineno": 81
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_setpriority.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_setpriority.py::test_setpriority_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/externaltask/test_setpriority.py::test_setpriority_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/externaltask/test_setpriority.py::test_setpriority_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/externaltask/test_setpriority.py::test_setpriority_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/externaltask/test_setpriority.py::test_setpriority_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_setretries.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_setretries.py::test_setretries_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/externaltask/test_setretries.py::test_setretries_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/externaltask/test_setretries.py::test_setretries_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/externaltask/test_setretries.py::test_setretries_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/externaltask/test_setretries.py::test_setretries_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_setretriesasync.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_setretriesasync.py::test_setretriesasync_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/externaltask/test_setretriesasync.py::test_setretriesasync_calls_requests",
          "type": "Function",
          "lineno": 32
        },
        {
          "nodeid": "tests/externaltask/test_setretriesasync.py::test_setretriesasync_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 43
        },
        {
          "nodeid": "tests/externaltask/test_setretriesasync.py::test_setretriesasync_raises_for_status",
          "type": "Function",
          "lineno": 52
        },
        {
          "nodeid": "tests/externaltask/test_setretriesasync.py::test_setretriesasync_returns_batch",
          "type": "Function",
          "lineno": 64
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_setretriessync.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_setretriessync.py::test_setretriessync_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/externaltask/test_setretriessync.py::test_setretriessync_calls_requests",
          "type": "Function",
          "lineno": 31
        },
        {
          "nodeid": "tests/externaltask/test_setretriessync.py::test_setretriessync_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 42
        },
        {
          "nodeid": "tests/externaltask/test_setretriessync.py::test_setretriessync_raises_for_status",
          "type": "Function",
          "lineno": 51
        },
        {
          "nodeid": "tests/externaltask/test_setretriessync.py::test_setretriessync_returns_none",
          "type": "Function",
          "lineno": 62
        }
      ]
    },
    {
      "nodeid": "tests/externaltask/test_unlock.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_unlock.py::test_unlock_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/externaltask/test_unlock.py::test_unlock_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/externaltask/test_unlock.py::test_unlock_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/externaltask/test_unlock.py::test_unlock_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/externaltask/test_unlock.py::test_unlock_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/externaltask",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/externaltask/test_complete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_count.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_extendlock.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_externaltask.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_fetchandlock.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_handlebpmnerror.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_handlefailure.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_setpriority.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_setretries.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_setretriesasync.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_setretriessync.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/externaltask/test_unlock.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/filter/test_count.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_count.py::test_count_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/filter/test_count.py::test_count_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/filter/test_count.py::test_count_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/filter/test_count.py::test_count_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/filter/test_count.py::test_count_returns_int",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/filter/test_create.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_create.py::test_create_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/filter/test_create.py::test_create_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/filter/test_create.py::test_create_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/filter/test_create.py::test_create_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/filter/test_create.py::test_create_returns_filter",
          "type": "Function",
          "lineno": 46
        }
      ]
    },
    {
      "nodeid": "tests/filter/test_criteria.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_criteria.py::test_criteria_params_process_instance_criteria",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/filter/test_criteria.py::test_criteria_params_process_definition_criteria",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/filter/test_criteria.py::test_criteria_params_case_instance_criteria",
          "type": "Function",
          "lineno": 32
        },
        {
          "nodeid": "tests/filter/test_criteria.py::test_criteria_params_case_definition_criteria",
          "type": "Function",
          "lineno": 43
        },
        {
          "nodeid": "tests/filter/test_criteria.py::test_criteria_params_other_criteria",
          "type": "Function",
          "lineno": 55
        },
        {
          "nodeid": "tests/filter/test_criteria.py::test_criteria_params_user_criteria",
          "type": "Function",
          "lineno": 66
        },
        {
          "nodeid": "tests/filter/test_criteria.py::test_criteria_params_task_criteria",
          "type": "Function",
          "lineno": 89
        },
        {
          "nodeid": "tests/filter/test_criteria.py::test_criteria_params_datetime_criteria",
          "type": "Function",
          "lineno": 120
        }
      ]
    },
    {
      "nodeid": "tests/filter/test_delete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_delete.py::test_delete_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/filter/test_delete.py::test_delete_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/filter/test_delete.py::test_delete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/filter/test_delete.py::test_delete_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/filter/test_delete.py::test_delete_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/filter/test_execute.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_execute.py::test_execute_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/filter/test_execute.py::test_execute_params_single_reuslt",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/filter/test_execute.py::test_execute_calls_requests",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/filter/test_execute.py::test_execute_calls_requests_post",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/filter/test_execute.py::test_execute_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 45
        },
        {
          "nodeid": "tests/filter/test_execute.py::test_execute_raises_for_status",
          "type": "Function",
          "lineno": 52
        },
        {
          "nodeid": "tests/filter/test_execute.py::test_execute_returns_tasks",
          "type": "Function",
          "lineno": 62
        },
        {
          "nodeid": "tests/filter/test_execute.py::test_execute_returns_task",
          "type": "Function",
          "lineno": 71
        }
      ]
    },
    {
      "nodeid": "tests/filter/test_executecount.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_executecount.py::test_executecount_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/filter/test_executecount.py::test_executecount_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/filter/test_executecount.py::test_executecount_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/filter/test_executecount.py::test_executecount_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/filter/test_executecount.py::test_executecount_returns_int",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/filter/test_filter.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_filter.py::test_filter_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/filter/test_filter.py::test_incident_load_raises_keyerror",
          "type": "Function",
          "lineno": 19
        }
      ]
    },
    {
      "nodeid": "tests/filter/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/filter/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/filter/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/filter/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/filter/test_get.py::test_get_returns_filter",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/filter/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/filter/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/filter/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/filter/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/filter/test_getlist.py::test_getlist_returns_filter_tuple",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/filter/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/filter/test_options.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_options.py::test_options_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/filter/test_options.py::test_options_calls_requests",
          "type": "Function",
          "lineno": 24
        },
        {
          "nodeid": "tests/filter/test_options.py::test_options_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/filter/test_options.py::test_options_raises_for_status",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/filter/test_options.py::test_options_returns_resource_options",
          "type": "Function",
          "lineno": 50
        }
      ]
    },
    {
      "nodeid": "tests/filter/test_update.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_update.py::test_update_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/filter/test_update.py::test_update_calls_requests",
          "type": "Function",
          "lineno": 22
        },
        {
          "nodeid": "tests/filter/test_update.py::test_update_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/filter/test_update.py::test_update_raises_for_status",
          "type": "Function",
          "lineno": 42
        },
        {
          "nodeid": "tests/filter/test_update.py::test_update_returns_none",
          "type": "Function",
          "lineno": 54
        }
      ]
    },
    {
      "nodeid": "tests/filter",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/filter/test_count.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/filter/test_create.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/filter/test_criteria.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/filter/test_delete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/filter/test_execute.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/filter/test_executecount.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/filter/test_filter.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/filter/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/filter/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/filter/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/filter/test_options.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/filter/test_update.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/group/test_create.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/group/test_create.py::test_create_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/group/test_create.py::test_create_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/group/test_create.py::test_create_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/group/test_create.py::test_create_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/group/test_create.py::test_create_returns_none",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/group/test_delete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/group/test_delete.py::test_delete_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/group/test_delete.py::test_delete_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/group/test_delete.py::test_delete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/group/test_delete.py::test_delete_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/group/test_delete.py::test_delete_returns_group",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/group/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/group/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/group/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/group/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/group/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/group/test_get.py::test_get_returns_group",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/group/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/group/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/group/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/group/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/group/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/group/test_getlist.py::test_getlist_returns_incident",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/group/test_group.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/group/test_group.py::test_group_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/group/test_group.py::test_group_load_raises_keyerror",
          "type": "Function",
          "lineno": 15
        }
      ]
    },
    {
      "nodeid": "tests/group/test_membercreate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/group/test_membercreate.py::test_membercreate_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/group/test_membercreate.py::test_membercreate_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/group/test_membercreate.py::test_membercreate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/group/test_membercreate.py::test_membercreate_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/group/test_membercreate.py::test_membercreate_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/group/test_memberdelete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/group/test_memberdelete.py::test_memberdelete_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/group/test_memberdelete.py::test_memberdelete_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/group/test_memberdelete.py::test_memberdelete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/group/test_memberdelete.py::test_memberdelete_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/group/test_memberdelete.py::test_memberdelete_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/group/test_memberoptions.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/group/test_memberoptions.py::test_memberoptions_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/group/test_memberoptions.py::test_memberoptions_calls_requests",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/group/test_memberoptions.py::test_memberoptions_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/group/test_memberoptions.py::test_memberoptions_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/group/test_memberoptions.py::test_memberoptions_returns_none",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/group/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/group/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/group/test_options.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/group/test_options.py::test_options_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/group/test_options.py::test_options_calls_requests",
          "type": "Function",
          "lineno": 23
        },
        {
          "nodeid": "tests/group/test_options.py::test_options_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/group/test_options.py::test_options_raises_for_status",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/group/test_options.py::test_options_returns_group",
          "type": "Function",
          "lineno": 50
        }
      ]
    },
    {
      "nodeid": "tests/group/test_update.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/group/test_update.py::test_update_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/group/test_update.py::test_update_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/group/test_update.py::test_update_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/group/test_update.py::test_update_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/group/test_update.py::test_update_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/group",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/group/test_create.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/group/test_delete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/group/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/group/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/group/test_group.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/group/test_membercreate.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/group/test_memberdelete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/group/test_memberoptions.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/group/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/group/test_options.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/group/test_update.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/identity/test_authstatus.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/identity/test_authstatus.py::test_authstatus_load",
          "type": "Function",
          "lineno": 9
        },
        {
          "nodeid": "tests/identity/test_authstatus.py::test_authstatus_load_raises_keyerror",
          "type": "Function",
          "lineno": 16
        }
      ]
    },
    {
      "nodeid": "tests/identity/test_getgroups.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/identity/test_getgroups.py::test_getgroups_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/identity/test_getgroups.py::test_getgroups_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/identity/test_getgroups.py::test_getgroups_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/identity/test_getgroups.py::test_getgroups_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/identity/test_getgroups.py::test_getgroups_returns_usersgroups",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/identity/test_getpasswordpolicy.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/identity/test_getpasswordpolicy.py::test_getpasswordpolicy_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/identity/test_getpasswordpolicy.py::test_getpasswordpolicy_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/identity/test_getpasswordpolicy.py::test_getpasswordpolicy_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/identity/test_getpasswordpolicy.py::test_getpasswordpolicy_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/identity/test_getpasswordpolicy.py::test_getpasswordpolicy_returns_tuple",
          "type": "Function",
          "lineno": 46
        }
      ]
    },
    {
      "nodeid": "tests/identity/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/identity/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/identity/test_passwordpolicy.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/identity/test_passwordpolicy.py::test_passwordpolicy_load",
          "type": "Function",
          "lineno": 9
        },
        {
          "nodeid": "tests/identity/test_passwordpolicy.py::test_passwordpolicy_load_raises_keyerror",
          "type": "Function",
          "lineno": 16
        }
      ]
    },
    {
      "nodeid": "tests/identity/test_passwordpolicycompliance.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/identity/test_passwordpolicycompliance.py::test_passwordpolicycompliance_load",
          "type": "Function",
          "lineno": 9
        },
        {
          "nodeid": "tests/identity/test_passwordpolicycompliance.py::test_passwordpolicycompliance_load_raises_keyerror",
          "type": "Function",
          "lineno": 17
        }
      ]
    },
    {
      "nodeid": "tests/identity/test_usersgroups.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/identity/test_usersgroups.py::test_group_load",
          "type": "Function",
          "lineno": 9
        },
        {
          "nodeid": "tests/identity/test_usersgroups.py::test_group_load_raises_keyerror",
          "type": "Function",
          "lineno": 16
        }
      ]
    },
    {
      "nodeid": "tests/identity/test_validatepassword.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/identity/test_validatepassword.py::test_validatepassword_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/identity/test_validatepassword.py::test_validatepassword_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/identity/test_validatepassword.py::test_validatepassword_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/identity/test_validatepassword.py::test_validatepassword_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/identity/test_validatepassword.py::test_validatepassword_returns_tuple",
          "type": "Function",
          "lineno": 46
        }
      ]
    },
    {
      "nodeid": "tests/identity/test_verifyuser.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/identity/test_verifyuser.py::test_verifyuser_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/identity/test_verifyuser.py::test_verifyuser_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/identity/test_verifyuser.py::test_verifyuser_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/identity/test_verifyuser.py::test_verifyuser_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/identity/test_verifyuser.py::test_verifyuser_returns_authstatus",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/identity",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/identity/test_authstatus.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/identity/test_getgroups.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/identity/test_getpasswordpolicy.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/identity/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/identity/test_passwordpolicy.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/identity/test_passwordpolicycompliance.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/identity/test_usersgroups.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/identity/test_validatepassword.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/identity/test_verifyuser.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/incident/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/incident/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/incident/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/incident/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/incident/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/incident/test_get.py::test_get_returns_incident",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/incident/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/incident/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/incident/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/incident/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/incident/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/incident/test_getlist.py::test_getlist_returns_incidents_tuple",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/incident/test_incident.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/incident/test_incident.py::test_incident_load",
          "type": "Function",
          "lineno": 9
        },
        {
          "nodeid": "tests/incident/test_incident.py::test_incident_load_raises_keyerror",
          "type": "Function",
          "lineno": 31
        }
      ]
    },
    {
      "nodeid": "tests/incident/test_incidenttypecount.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/incident/test_incidenttypecount.py::test_incident_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/incident/test_incidenttypecount.py::test_incident_load_raises_keyerror",
          "type": "Function",
          "lineno": 16
        }
      ]
    },
    {
      "nodeid": "tests/incident/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/incident/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/incident/test_resolve.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/incident/test_resolve.py::test_resolve_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/incident/test_resolve.py::test_resolve_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/incident/test_resolve.py::test_resolve_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/incident/test_resolve.py::test_resolve_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/incident/test_resolve.py::test_resolve_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/incident",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/incident/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/incident/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/incident/test_incident.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/incident/test_incidenttypecount.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/incident/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/incident/test_resolve.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/instruction/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/instruction/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/instruction",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/instruction/test_module.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/message/test_correlate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/message/test_correlate.py::test_correlatesingle_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/message/test_correlate.py::test_correlatesingle_method_params",
          "type": "Function",
          "lineno": 24
        },
        {
          "nodeid": "tests/message/test_correlate.py::test_correlatesingle_calls_requests",
          "type": "Function",
          "lineno": 48
        },
        {
          "nodeid": "tests/message/test_correlate.py::test_correlatesingle_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 58
        },
        {
          "nodeid": "tests/message/test_correlate.py::test_correlatesingle_raises_for_status",
          "type": "Function",
          "lineno": 65
        },
        {
          "nodeid": "tests/message/test_correlate.py::test_correlatesingle_returns_messagecorrelationresult",
          "type": "Function",
          "lineno": 75
        },
        {
          "nodeid": "tests/message/test_correlate.py::test_correlateall_params",
          "type": "Function",
          "lineno": 85
        },
        {
          "nodeid": "tests/message/test_correlate.py::test_correlateall_method_params",
          "type": "Function",
          "lineno": 99
        },
        {
          "nodeid": "tests/message/test_correlate.py::test_correlateall_calls_requests",
          "type": "Function",
          "lineno": 123
        },
        {
          "nodeid": "tests/message/test_correlate.py::test_correlateall_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 132
        },
        {
          "nodeid": "tests/message/test_correlate.py::test_correlateall_raises_for_status",
          "type": "Function",
          "lineno": 139
        },
        {
          "nodeid": "tests/message/test_correlate.py::test_correlateall_returns_messagecorrelationresult",
          "type": "Function",
          "lineno": 149
        }
      ]
    },
    {
      "nodeid": "tests/message/test_messagecorrelationresult.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/message/test_messagecorrelationresult.py::test_messagecorrelationresult_load_definition",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/message/test_messagecorrelationresult.py::test_messagecorrelationresult_load_execution",
          "type": "Function",
          "lineno": 25
        },
        {
          "nodeid": "tests/message/test_messagecorrelationresult.py::test_messagecorrelationresult_load_raises_keyerror",
          "type": "Function",
          "lineno": 40
        }
      ]
    },
    {
      "nodeid": "tests/message/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/message/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/message",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/message/test_correlate.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/message/test_messagecorrelationresult.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/message/test_module.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/migration/test_execute.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/migration/test_execute.py::test_execute_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/migration/test_execute.py::test_execute_from_migration_plan_params",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/migration/test_execute.py::test_execute_async_params",
          "type": "Function",
          "lineno": 77
        },
        {
          "nodeid": "tests/migration/test_execute.py::test_execute_calls_requests",
          "type": "Function",
          "lineno": 91
        },
        {
          "nodeid": "tests/migration/test_execute.py::test_execute_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 108
        },
        {
          "nodeid": "tests/migration/test_execute.py::test_execute_raises_for_status",
          "type": "Function",
          "lineno": 123
        },
        {
          "nodeid": "tests/migration/test_execute.py::test_execute_returns_none",
          "type": "Function",
          "lineno": 140
        },
        {
          "nodeid": "tests/migration/test_execute.py::test_execute_async_returns_batch",
          "type": "Function",
          "lineno": 156
        }
      ]
    },
    {
      "nodeid": "tests/migration/test_generate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/migration/test_generate.py::test_generate_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/migration/test_generate.py::test_generate_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/migration/test_generate.py::test_generate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/migration/test_generate.py::test_generate_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/migration/test_generate.py::test_generate_returns_migrationplan",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/migration/test_instructionreport.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/migration/test_instructionreport.py::test_instructionreport_load_definition",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/migration/test_instructionreport.py::test_instructionreport_load_raises_key_error",
          "type": "Function",
          "lineno": 17
        }
      ]
    },
    {
      "nodeid": "tests/migration/test_migrationinstruction.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/migration/test_migrationinstruction.py::test_migrationinstruction_load_definition",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/migration/test_migrationinstruction.py::test_migrationinstruction_load_raises_key_error",
          "type": "Function",
          "lineno": 16
        }
      ]
    },
    {
      "nodeid": "tests/migration/test_migrationplan.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/migration/test_migrationplan.py::test_migrationplan_load_definition",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/migration/test_migrationplan.py::test_migrationplan_load_raises_key_error",
          "type": "Function",
          "lineno": 19
        }
      ]
    },
    {
      "nodeid": "tests/migration/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/migration/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/migration/test_validate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/migration/test_validate.py::test_validate_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/migration/test_validate.py::test_validate_from_migration_plan_params",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/migration/test_validate.py::test_validate_calls_requests",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/migration/test_validate.py::test_validate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 58
        },
        {
          "nodeid": "tests/migration/test_validate.py::test_validate_raises_for_status",
          "type": "Function",
          "lineno": 68
        },
        {
          "nodeid": "tests/migration/test_validate.py::test_validate_returns_migrationplan",
          "type": "Function",
          "lineno": 81
        }
      ]
    },
    {
      "nodeid": "tests/migration",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/migration/test_execute.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/migration/test_generate.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/migration/test_instructionreport.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/migration/test_migrationinstruction.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/migration/test_migrationplan.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/migration/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/migration/test_validate.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_activatesuspend.py::test_activate_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/processdef/test_activatesuspend.py::test_activate_path",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/processdef/test_activatesuspend.py::test_activate_calls_requests",
          "type": "Function",
          "lineno": 42
        },
        {
          "nodeid": "tests/processdef/test_activatesuspend.py::test_activate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 51
        },
        {
          "nodeid": "tests/processdef/test_activatesuspend.py::test_activate_raises_for_status",
          "type": "Function",
          "lineno": 58
        },
        {
          "nodeid": "tests/processdef/test_activatesuspend.py::test_activate_returns_none",
          "type": "Function",
          "lineno": 67
        },
        {
          "nodeid": "tests/processdef/test_activatesuspend.py::test_suspend_params",
          "type": "Function",
          "lineno": 75
        },
        {
          "nodeid": "tests/processdef/test_activatesuspend.py::test_suspend_path",
          "type": "Function",
          "lineno": 92
        },
        {
          "nodeid": "tests/processdef/test_activatesuspend.py::test_suspend_calls_requests",
          "type": "Function",
          "lineno": 105
        },
        {
          "nodeid": "tests/processdef/test_activatesuspend.py::test_suspend_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 113
        },
        {
          "nodeid": "tests/processdef/test_activatesuspend.py::test_suspend_raises_for_status",
          "type": "Function",
          "lineno": 120
        },
        {
          "nodeid": "tests/processdef/test_activatesuspend.py::test_suspend_returns_none",
          "type": "Function",
          "lineno": 129
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_activitystats.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_activitystats.py::test_activitystats_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/processdef/test_activitystats.py::test_activitystats_load_raises_keyerror",
          "type": "Function",
          "lineno": 15
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_count.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_count.py::test_count_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/processdef/test_count.py::test_count_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/processdef/test_count.py::test_count_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/processdef/test_count.py::test_count_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/processdef/test_count.py::test_count_returns_response_content",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_delete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_delete.py::test_delete_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/processdef/test_delete.py::test_delete_path",
          "type": "Function",
          "lineno": 23
        },
        {
          "nodeid": "tests/processdef/test_delete.py::test_delete_calls_requests",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/processdef/test_delete.py::test_delete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 45
        },
        {
          "nodeid": "tests/processdef/test_delete.py::test_delete_raises_for_status",
          "type": "Function",
          "lineno": 52
        },
        {
          "nodeid": "tests/processdef/test_delete.py::test_delete_returns_none",
          "type": "Function",
          "lineno": 61
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/processdef/test_get.py::test_get_path",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/processdef/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/processdef/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 38
        },
        {
          "nodeid": "tests/processdef/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 45
        },
        {
          "nodeid": "tests/processdef/test_get.py::test_get_returns_processdefinition",
          "type": "Function",
          "lineno": 55
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_getactivityinstancestats.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_getactivityinstancestats.py::test_getactivityinstancestats_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/processdef/test_getactivityinstancestats.py::test_getactivityinstancestats_path",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/processdef/test_getactivityinstancestats.py::test_getactivityinstancestats_calls_requests",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/processdef/test_getactivityinstancestats.py::test_getactivityinstancestats_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 46
        },
        {
          "nodeid": "tests/processdef/test_getactivityinstancestats.py::test_getactivityinstancestats_raises_for_status",
          "type": "Function",
          "lineno": 53
        },
        {
          "nodeid": "tests/processdef/test_getactivityinstancestats.py::test_getactivityinstancestats_returns_activitystats",
          "type": "Function",
          "lineno": 63
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/processdef/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/processdef/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/processdef/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/processdef/test_getlist.py::test_getlist_returns_response_content",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_getprocessdiagram.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_getprocessdiagram.py::test_getprocessdiagram_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/processdef/test_getprocessdiagram.py::test_getprocessdiagram_path",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/processdef/test_getprocessdiagram.py::test_getprocessdiagram_calls_requests",
          "type": "Function",
          "lineno": 31
        },
        {
          "nodeid": "tests/processdef/test_getprocessdiagram.py::test_getprocessdiagram_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/processdef/test_getprocessdiagram.py::test_getprocessdiagram_raises_for_status",
          "type": "Function",
          "lineno": 47
        },
        {
          "nodeid": "tests/processdef/test_getprocessdiagram.py::test_getprocessdiagram_returns_response_content",
          "type": "Function",
          "lineno": 57
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_getprocessinstancestats.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagram_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagram_path",
          "type": "Function",
          "lineno": 21
        },
        {
          "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagramm_raises_exception_on_invalid_inputs",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagram_calls_requests",
          "type": "Function",
          "lineno": 70
        },
        {
          "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagram_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 79
        },
        {
          "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagram_raises_for_status",
          "type": "Function",
          "lineno": 86
        },
        {
          "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagram_returns_response_content",
          "type": "Function",
          "lineno": 96
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_getxml.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_getxml.py::test_getxml_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/processdef/test_getxml.py::test_getxml_path",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/processdef/test_getxml.py::test_getxml_calls_requests",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/processdef/test_getxml.py::test_getxml_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/processdef/test_getxml.py::test_getxml_raises_for_status",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/processdef/test_getxml.py::test_getxml_returns_bpmn20Xml",
          "type": "Function",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_processdef.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_processdef.py::test_processdefinition_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/processdef/test_processdef.py::test_processdefinition_load_raises_keyerror",
          "type": "Function",
          "lineno": 27
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_processinstancestats.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_processinstancestats.py::test_processinstancestats_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/processdef/test_processinstancestats.py::test_processinstancestats_load_raises_keyerror",
          "type": "Function",
          "lineno": 19
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_restartprocessinstance.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_restartprocessinstance.py::test_restartprocessinstance_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/processdef/test_restartprocessinstance.py::test_restartprocessinstance_calls_requests",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/processdef/test_restartprocessinstance.py::test_restartprocessinstance_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 55
        },
        {
          "nodeid": "tests/processdef/test_restartprocessinstance.py::test_restartprocessinstance_raises_for_status",
          "type": "Function",
          "lineno": 64
        },
        {
          "nodeid": "tests/processdef/test_restartprocessinstance.py::test_restartprocessinstance_returns_none",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/processdef/test_restartprocessinstance.py::test_restartprocessinstance_async_returns_batch",
          "type": "Function",
          "lineno": 86
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_startinstance.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_startinstance.py::test_startinstance_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/processdef/test_startinstance.py::test_startinstance_path",
          "type": "Function",
          "lineno": 39
        },
        {
          "nodeid": "tests/processdef/test_startinstance.py::test_startinstance_calls_requests",
          "type": "Function",
          "lineno": 56
        },
        {
          "nodeid": "tests/processdef/test_startinstance.py::test_startinstance_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 65
        },
        {
          "nodeid": "tests/processdef/test_startinstance.py::test_startinstance_raises_for_status",
          "type": "Function",
          "lineno": 72
        },
        {
          "nodeid": "tests/processdef/test_startinstance.py::test_startinstance_returns_activitystats",
          "type": "Function",
          "lineno": 82
        }
      ]
    },
    {
      "nodeid": "tests/processdef/test_updatehistorytimetolive.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/processdef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_path",
          "type": "Function",
          "lineno": 21
        },
        {
          "nodeid": "tests/processdef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_calls_requests",
          "type": "Function",
          "lineno": 39
        },
        {
          "nodeid": "tests/processdef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 50
        },
        {
          "nodeid": "tests/processdef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_raises_for_status",
          "type": "Function",
          "lineno": 59
        },
        {
          "nodeid": "tests/processdef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_returns_none",
          "type": "Function",
          "lineno": 70
        }
      ]
    },
    {
      "nodeid": "tests/processdef",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processdef/test_activatesuspend.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_activitystats.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_count.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_delete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_getactivityinstancestats.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_getprocessdiagram.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_getprocessinstancestats.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_getxml.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_processdef.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_processinstancestats.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_restartprocessinstance.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_startinstance.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processdef/test_updatehistorytimetolive.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_activatesuspend.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_activatesuspend.py::test_activate_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/processinst/test_activatesuspend.py::test_activate_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/processinst/test_activatesuspend.py::test_activate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/processinst/test_activatesuspend.py::test_activate_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/processinst/test_activatesuspend.py::test_activate_returns_none",
          "type": "Function",
          "lineno": 43
        },
        {
          "nodeid": "tests/processinst/test_activatesuspend.py::test_suspend_params",
          "type": "Function",
          "lineno": 51
        },
        {
          "nodeid": "tests/processinst/test_activatesuspend.py::test_suspend_calls_requests",
          "type": "Function",
          "lineno": 59
        },
        {
          "nodeid": "tests/processinst/test_activatesuspend.py::test_suspend_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 67
        },
        {
          "nodeid": "tests/processinst/test_activatesuspend.py::test_suspend_raises_for_status",
          "type": "Function",
          "lineno": 74
        },
        {
          "nodeid": "tests/processinst/test_activatesuspend.py::test_suspend_returns_none",
          "type": "Function",
          "lineno": 83
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_delete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_delete.py::test_delete_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/processinst/test_delete.py::test_delete_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/processinst/test_delete.py::test_delete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/processinst/test_delete.py::test_delete_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/processinst/test_delete.py::test_delete_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/processinst/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/processinst/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/processinst/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/processinst/test_get.py::test_get_returns_none",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_getactivityinstance.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_getactivityinstance.py::test_getactivityinstance_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/processinst/test_getactivityinstance.py::test_getactivityinstance_calls_requests",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/processinst/test_getactivityinstance.py::test_getactivityinstance_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/processinst/test_getactivityinstance.py::test_getactivityinstance_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/processinst/test_getactivityinstance.py::test_getactivityinstance_returns_none",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/processinst/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/processinst/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/processinst/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/processinst/test_getlist.py::test_getlist_returns_none",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_modify.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_params_default",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_params_non_default",
          "type": "Function",
          "lineno": 23
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_params_async",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_params_before_activity_instruction",
          "type": "Function",
          "lineno": 52
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_params_after_activity_instruction",
          "type": "Function",
          "lineno": 63
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_params_cancel_instruction",
          "type": "Function",
          "lineno": 74
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_params_transition_instruction",
          "type": "Function",
          "lineno": 85
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_params_cancel_activity_instance_instruction",
          "type": "Function",
          "lineno": 96
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_params_cancel_transition_instance_instruction",
          "type": "Function",
          "lineno": 107
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_params_start_before_ancestor_instance_instruction",
          "type": "Function",
          "lineno": 118
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_params_start_after_ancestor_instance_instruction",
          "type": "Function",
          "lineno": 134
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_params_cancel_ancestor_instance_instruction",
          "type": "Function",
          "lineno": 150
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_calls_requests",
          "type": "Function",
          "lineno": 162
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 171
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_raises_for_status",
          "type": "Function",
          "lineno": 178
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_returns_none",
          "type": "Function",
          "lineno": 187
        },
        {
          "nodeid": "tests/processinst/test_modify.py::test_modify_async_returns_batch",
          "type": "Function",
          "lineno": 195
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_processinst.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_processinst.py::test_processinstance_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/processinst/test_processinst.py::test_processinstance_load_raises_keyerror",
          "type": "Function",
          "lineno": 19
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_variablesdelete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_variablesdelete.py::test_variablesdelete_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/processinst/test_variablesdelete.py::test_variablesdelete_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/processinst/test_variablesdelete.py::test_variablesdelete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 31
        },
        {
          "nodeid": "tests/processinst/test_variablesdelete.py::test_variablesdelete_raises_for_status",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/processinst/test_variablesdelete.py::test_variablesdelete_returns_none",
          "type": "Function",
          "lineno": 51
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_variablesget.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_variablesget.py::test_variablesget_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/processinst/test_variablesget.py::test_variablesget_binary_params",
          "type": "Function",
          "lineno": 21
        },
        {
          "nodeid": "tests/processinst/test_variablesget.py::test_variablesget_calls_requests",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/processinst/test_variablesget.py::test_variablesget_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/processinst/test_variablesget.py::test_variablesget_raises_for_status",
          "type": "Function",
          "lineno": 53
        },
        {
          "nodeid": "tests/processinst/test_variablesget.py::test_variablesget_returns_variable",
          "type": "Function",
          "lineno": 65
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_variablesgetlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_variablesgetlist.py::test_variablesgetlist_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/processinst/test_variablesgetlist.py::test_variablesgetlist_calls_requests",
          "type": "Function",
          "lineno": 21
        },
        {
          "nodeid": "tests/processinst/test_variablesgetlist.py::test_variablesgetlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 32
        },
        {
          "nodeid": "tests/processinst/test_variablesgetlist.py::test_variablesgetlist_raises_for_status",
          "type": "Function",
          "lineno": 41
        },
        {
          "nodeid": "tests/processinst/test_variablesgetlist.py::test_variablesgetlist_returns_dict",
          "type": "Function",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_variablesmodify.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_variablesmodify.py::test_variablesmodify_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/processinst/test_variablesmodify.py::test_variablesmodify_calls_requests",
          "type": "Function",
          "lineno": 24
        },
        {
          "nodeid": "tests/processinst/test_variablesmodify.py::test_variablesmodify_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/processinst/test_variablesmodify.py::test_variablesmodify_raises_for_status",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/processinst/test_variablesmodify.py::test_variablesmodify_returns_none",
          "type": "Function",
          "lineno": 49
        }
      ]
    },
    {
      "nodeid": "tests/processinst/test_variablesupdate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_binary_params",
          "type": "Function",
          "lineno": 26
        },
        {
          "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_calls_requests",
          "type": "Function",
          "lineno": 50
        },
        {
          "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_binary_calls_requests",
          "type": "Function",
          "lineno": 66
        },
        {
          "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 80
        },
        {
          "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_binary_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 94
        },
        {
          "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_raises_for_status",
          "type": "Function",
          "lineno": 107
        },
        {
          "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_returns_none",
          "type": "Function",
          "lineno": 123
        }
      ]
    },
    {
      "nodeid": "tests/processinst",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/processinst/test_activatesuspend.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processinst/test_delete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processinst/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processinst/test_getactivityinstance.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processinst/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processinst/test_modify.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processinst/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processinst/test_processinst.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processinst/test_variablesdelete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processinst/test_variablesget.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processinst/test_variablesgetlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processinst/test_variablesmodify.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/processinst/test_variablesupdate.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/resource/test_link.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/resource/test_link.py::test_link_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/resource/test_link.py::test_link_load_raises_keyerror",
          "type": "Function",
          "lineno": 15
        }
      ]
    },
    {
      "nodeid": "tests/resource/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/resource/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/resource/test_resourceoptions.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/resource/test_resourceoptions.py::test_resourceoptions_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/resource/test_resourceoptions.py::test_link_load_raises_keyerror",
          "type": "Function",
          "lineno": 15
        }
      ]
    },
    {
      "nodeid": "tests/resource",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/resource/test_link.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/resource/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/resource/test_resourceoptions.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/signal/test_event.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/signal/test_event.py::test_eventall_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/signal/test_event.py::test_eventall_variables_params",
          "type": "Function",
          "lineno": 25
        },
        {
          "nodeid": "tests/signal/test_event.py::test_eventall_calls_requests",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/signal/test_event.py::test_eventall_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 43
        },
        {
          "nodeid": "tests/signal/test_event.py::test_eventall_raises_for_status",
          "type": "Function",
          "lineno": 50
        },
        {
          "nodeid": "tests/signal/test_event.py::test_eventall_returns_none",
          "type": "Function",
          "lineno": 59
        },
        {
          "nodeid": "tests/signal/test_event.py::test_eventsingle_params",
          "type": "Function",
          "lineno": 67
        },
        {
          "nodeid": "tests/signal/test_event.py::test_eventsingle_variables_params",
          "type": "Function",
          "lineno": 79
        },
        {
          "nodeid": "tests/signal/test_event.py::test_eventsingle_calls_requests",
          "type": "Function",
          "lineno": 88
        },
        {
          "nodeid": "tests/signal/test_event.py::test_eventsingle_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 97
        },
        {
          "nodeid": "tests/signal/test_event.py::test_eventsingle_raises_for_status",
          "type": "Function",
          "lineno": 104
        },
        {
          "nodeid": "tests/signal/test_event.py::test_eventsingle_returns_none",
          "type": "Function",
          "lineno": 113
        }
      ]
    },
    {
      "nodeid": "tests/signal/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/signal/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/signal",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/signal/test_event.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/signal/test_module.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/task/test_claim.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_claim.py::test_claim_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_claim.py::test_claim_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/task/test_claim.py::test_claim_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/task/test_claim.py::test_claim_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/task/test_claim.py::test_claim_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/task/test_comment.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_comment.py::test_comment_load",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/task/test_comment.py::test_comment_load_raises_key_error",
          "type": "Function",
          "lineno": 14
        }
      ]
    },
    {
      "nodeid": "tests/task/test_commentcreate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_commentcreate.py::test_commentcreate_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_commentcreate.py::test_commentcreate_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/task/test_commentcreate.py::test_commentcreate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 32
        },
        {
          "nodeid": "tests/task/test_commentcreate.py::test_commentcreate_raises_for_status",
          "type": "Function",
          "lineno": 41
        },
        {
          "nodeid": "tests/task/test_commentcreate.py::test_commentcreate_returns_comment",
          "type": "Function",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/task/test_commentget.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_commentget.py::test_commentget_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_commentget.py::test_commentget_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/task/test_commentget.py::test_commentget_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/task/test_commentget.py::test_commentget_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/task/test_commentget.py::test_commentget_returns_comment",
          "type": "Function",
          "lineno": 46
        }
      ]
    },
    {
      "nodeid": "tests/task/test_commentgetlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_commentgetlist.py::test_commentgetlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_commentgetlist.py::test_commentgetlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/task/test_commentgetlist.py::test_commentgetlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/task/test_commentgetlist.py::test_commentgetlist_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/task/test_commentgetlist.py::test_commentgetlist_returns_comment",
          "type": "Function",
          "lineno": 46
        }
      ]
    },
    {
      "nodeid": "tests/task/test_complete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_complete.py::test_complete_params",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/task/test_complete.py::test_complete_calls_requests",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/task/test_complete.py::test_complete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 42
        },
        {
          "nodeid": "tests/task/test_complete.py::test_complete_raises_for_status",
          "type": "Function",
          "lineno": 49
        },
        {
          "nodeid": "tests/task/test_complete.py::test_complete_returns_none",
          "type": "Function",
          "lineno": 58
        },
        {
          "nodeid": "tests/task/test_complete.py::test_complete_returns_variables",
          "type": "Function",
          "lineno": 66
        }
      ]
    },
    {
      "nodeid": "tests/task/test_countbycandidategroup.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_countbycandidategroup.py::test_countbycandidategroup_load",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/task/test_countbycandidategroup.py::test_countbycandidategroup_load_raises_key_error",
          "type": "Function",
          "lineno": 14
        }
      ]
    },
    {
      "nodeid": "tests/task/test_create.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_create.py::test_create_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_create.py::test_create_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/task/test_create.py::test_create_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/task/test_create.py::test_create_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/task/test_create.py::test_create_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/task/test_delegate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_delegate.py::test_delegate_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_delegate.py::test_delegate_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/task/test_delegate.py::test_delegate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/task/test_delegate.py::test_delegate_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/task/test_delegate.py::test_delegate_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/task/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/task/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/task/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/task/test_get.py::test_get_returns_task",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/task/test_getcountbycandidategroup.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_getcountbycandidategroup.py::test_getcountbycandidategroup_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_getcountbycandidategroup.py::test_getcountbycandidategroup_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/task/test_getcountbycandidategroup.py::test_getcountbycandidategroup_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/task/test_getcountbycandidategroup.py::test_getcountbycandidategroup_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/task/test_getcountbycandidategroup.py::test_getcountbycandidategroup_returns_coundbycandidategroup",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/task/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/task/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/task/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/task/test_getlist.py::test_getlist_returns_group",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/task/test_identitylink.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_identitylink.py::test_identitylink_load",
          "type": "Function",
          "lineno": 9
        },
        {
          "nodeid": "tests/task/test_identitylink.py::test_identitylink_load_raises_key_error",
          "type": "Function",
          "lineno": 18
        }
      ]
    },
    {
      "nodeid": "tests/task/test_identitylinksadd.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_identitylinksadd.py::test_identitylinksadd_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_identitylinksadd.py::test_identitylinksadd_raises_assertion_error",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/task/test_identitylinksadd.py::test_identitylinksadd_calls_requests",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/task/test_identitylinksadd.py::test_identitylinksadd_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 38
        },
        {
          "nodeid": "tests/task/test_identitylinksadd.py::test_identitylinksadd_raises_for_status",
          "type": "Function",
          "lineno": 47
        },
        {
          "nodeid": "tests/task/test_identitylinksadd.py::test_identitylinksadd_returns_group",
          "type": "Function",
          "lineno": 58
        }
      ]
    },
    {
      "nodeid": "tests/task/test_identitylinksdelete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_identitylinksdelete.py::test_identitylinksdelete_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_identitylinksdelete.py::test_identitylinksdelete_raises_assertion_error",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/task/test_identitylinksdelete.py::test_identitylinksdelete_calls_requests",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/task/test_identitylinksdelete.py::test_identitylinksdelete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 38
        },
        {
          "nodeid": "tests/task/test_identitylinksdelete.py::test_identitylinksdelete_raises_for_status",
          "type": "Function",
          "lineno": 47
        },
        {
          "nodeid": "tests/task/test_identitylinksdelete.py::test_identitylinksdelete_returns_group",
          "type": "Function",
          "lineno": 58
        }
      ]
    },
    {
      "nodeid": "tests/task/test_identitylinksgetlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_identitylinksgetlist.py::test_identitylinksgetlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_identitylinksgetlist.py::test_identitylinksgetlist_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/task/test_identitylinksgetlist.py::test_identitylinksgetlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/task/test_identitylinksgetlist.py::test_identitylinksgetlist_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/task/test_identitylinksgetlist.py::test_identitylinksgetlist_returns_group",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/task/test_localvariablesdelete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_localvariablesdelete.py::test_localvariablesdelete_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_localvariablesdelete.py::test_localvariablesdelete_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/task/test_localvariablesdelete.py::test_localvariablesdelete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 31
        },
        {
          "nodeid": "tests/task/test_localvariablesdelete.py::test_localvariablesdelete_raises_for_status",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/task/test_localvariablesdelete.py::test_localvariablesdelete_returns_none",
          "type": "Function",
          "lineno": 51
        }
      ]
    },
    {
      "nodeid": "tests/task/test_localvariablesget.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_localvariablesget.py::test_localvariablesget_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/task/test_localvariablesget.py::test_localvariablesget_binary_params",
          "type": "Function",
          "lineno": 21
        },
        {
          "nodeid": "tests/task/test_localvariablesget.py::test_localvariablesget_calls_requests",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/task/test_localvariablesget.py::test_localvariablesget_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 38
        },
        {
          "nodeid": "tests/task/test_localvariablesget.py::test_localvariablesget_raises_for_status",
          "type": "Function",
          "lineno": 45
        },
        {
          "nodeid": "tests/task/test_localvariablesget.py::test_localvariablesget_returns_variable",
          "type": "Function",
          "lineno": 55
        }
      ]
    },
    {
      "nodeid": "tests/task/test_localvariablesgetlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_localvariablesgetlist.py::test_localvariablesgetlist_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/task/test_localvariablesgetlist.py::test_localvariablesgetlist_calls_requests",
          "type": "Function",
          "lineno": 21
        },
        {
          "nodeid": "tests/task/test_localvariablesgetlist.py::test_localvariablesgetlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 32
        },
        {
          "nodeid": "tests/task/test_localvariablesgetlist.py::test_localvariablesgetlist_raises_for_status",
          "type": "Function",
          "lineno": 41
        },
        {
          "nodeid": "tests/task/test_localvariablesgetlist.py::test_localvariablesgetlist_returns_dict",
          "type": "Function",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/task/test_localvariablesmodify.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_localvariablesmodify.py::test_localvariablesmodify_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_localvariablesmodify.py::test_localvariablesmodify_calls_requests",
          "type": "Function",
          "lineno": 24
        },
        {
          "nodeid": "tests/task/test_localvariablesmodify.py::test_localvariablesmodify_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/task/test_localvariablesmodify.py::test_localvariablesmodify_raises_for_status",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/task/test_localvariablesmodify.py::test_localvariablesmodify_returns_none",
          "type": "Function",
          "lineno": 49
        }
      ]
    },
    {
      "nodeid": "tests/task/test_localvariablesupdate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_binary_params",
          "type": "Function",
          "lineno": 21
        },
        {
          "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_calls_requests",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_binary_calls_requests",
          "type": "Function",
          "lineno": 48
        },
        {
          "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 58
        },
        {
          "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_binary_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 67
        },
        {
          "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_raises_for_status",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_returns_none",
          "type": "Function",
          "lineno": 87
        }
      ]
    },
    {
      "nodeid": "tests/task/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/task/test_resolve.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_resolve.py::test_resolve_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/task/test_resolve.py::test_resolve_calls_requests",
          "type": "Function",
          "lineno": 22
        },
        {
          "nodeid": "tests/task/test_resolve.py::test_resolve_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 31
        },
        {
          "nodeid": "tests/task/test_resolve.py::test_resolve_raises_for_status",
          "type": "Function",
          "lineno": 38
        },
        {
          "nodeid": "tests/task/test_resolve.py::test_resolve_returns_none",
          "type": "Function",
          "lineno": 47
        }
      ]
    },
    {
      "nodeid": "tests/task/test_setassignee.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_setassignee.py::test_setassignee_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/task/test_setassignee.py::test_setassignee_calls_requests",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/task/test_setassignee.py::test_setassignee_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/task/test_setassignee.py::test_setassignee_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/task/test_setassignee.py::test_setassignee_returns_none",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/task/test_task.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_task.py::test_task_load",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/task/test_task.py::test_task_load_raises_key_error",
          "type": "Function",
          "lineno": 14
        }
      ]
    },
    {
      "nodeid": "tests/task/test_unclaim.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_unclaim.py::test_unclaim_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_unclaim.py::test_unclaim_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/task/test_unclaim.py::test_unclaim_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/task/test_unclaim.py::test_unclaim_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/task/test_unclaim.py::test_unclaim_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/task/test_update.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_update.py::test_update_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/task/test_update.py::test_update_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/task/test_update.py::test_update_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/task/test_update.py::test_update_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/task/test_update.py::test_update_returns_none",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/task",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/task/test_claim.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_comment.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_commentcreate.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_commentget.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_commentgetlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_complete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_countbycandidategroup.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_create.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_delegate.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_getcountbycandidategroup.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_identitylink.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_identitylinksadd.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_identitylinksdelete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_identitylinksgetlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_localvariablesdelete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_localvariablesget.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_localvariablesgetlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_localvariablesmodify.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_localvariablesupdate.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_resolve.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_setassignee.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_task.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_unclaim.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/task/test_update.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/telemetry/test_configure.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/telemetry/test_configure.py::test_configure_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/telemetry/test_configure.py::test_configure_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/telemetry/test_configure.py::test_configure_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/telemetry/test_configure.py::test_configure_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/telemetry/test_configure.py::test_configure_returns_none",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/telemetry/test_fetch.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/telemetry/test_fetch.py::test_fetch_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/telemetry/test_fetch.py::test_fetch_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/telemetry/test_fetch.py::test_fetch_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/telemetry/test_fetch.py::test_fetch_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/telemetry/test_fetch.py::test_fetch_returns_bool",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/telemetry/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/telemetry/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/telemetry",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/telemetry/test_configure.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/telemetry/test_fetch.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/telemetry/test_module.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_count.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_count.py::test_count_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/tenant/test_count.py::test_count_calls_requests",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/tenant/test_count.py::test_count_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/tenant/test_count.py::test_count_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/tenant/test_count.py::test_count_returns_integer",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_create.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_create.py::test_create_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/tenant/test_create.py::test_create_calls_requests",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/tenant/test_create.py::test_create_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/tenant/test_create.py::test_create_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/tenant/test_create.py::test_create_returns_none",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_delete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_delete.py::test_delete_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/tenant/test_delete.py::test_delete_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/tenant/test_delete.py::test_delete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/tenant/test_delete.py::test_delete_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/tenant/test_delete.py::test_delete_returns_none",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/tenant/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/tenant/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/tenant/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/tenant/test_get.py::test_get_returns_tenant",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/tenant/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/tenant/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/tenant/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 35
        },
        {
          "nodeid": "tests/tenant/test_getlist.py::test_getlist_returns_tenants",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_groupmembercreate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_groupmembercreate.py::test_groupmembercreate_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/tenant/test_groupmembercreate.py::test_groupmembercreate_calls_requests",
          "type": "Function",
          "lineno": 21
        },
        {
          "nodeid": "tests/tenant/test_groupmembercreate.py::test_groupmembercreate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 32
        },
        {
          "nodeid": "tests/tenant/test_groupmembercreate.py::test_groupmembercreate_raises_for_status",
          "type": "Function",
          "lineno": 42
        },
        {
          "nodeid": "tests/tenant/test_groupmembercreate.py::test_groupmembercreate_returns_none",
          "type": "Function",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_groupmemberdelete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_groupmemberdelete.py::test_groupmemberdelete_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/tenant/test_groupmemberdelete.py::test_groupmemberdelete_calls_requests",
          "type": "Function",
          "lineno": 21
        },
        {
          "nodeid": "tests/tenant/test_groupmemberdelete.py::test_groupmemberdelete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 32
        },
        {
          "nodeid": "tests/tenant/test_groupmemberdelete.py::test_groupmemberdelete_raises_for_status",
          "type": "Function",
          "lineno": 42
        },
        {
          "nodeid": "tests/tenant/test_groupmemberdelete.py::test_groupmemberdelete_returns_none",
          "type": "Function",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_groupmemberoptions.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_groupmemberoptions.py::test_groupmemberoptions_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/tenant/test_groupmemberoptions.py::test_groupmemberoptions_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/tenant/test_groupmemberoptions.py::test_groupmemberoptions_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/tenant/test_groupmemberoptions.py::test_groupmemberoptions_raises_for_status",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/tenant/test_groupmemberoptions.py::test_groupmemberoptions_returns_resource_options",
          "type": "Function",
          "lineno": 47
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_options.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_options.py::test_options_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/tenant/test_options.py::test_options_calls_requests",
          "type": "Function",
          "lineno": 24
        },
        {
          "nodeid": "tests/tenant/test_options.py::test_options_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/tenant/test_options.py::test_options_raises_for_status",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/tenant/test_options.py::test_options_returns_resource_options",
          "type": "Function",
          "lineno": 50
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_tenant.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_tenant.py::test_tenant_load",
          "type": "Function",
          "lineno": 9
        },
        {
          "nodeid": "tests/tenant/test_tenant.py::test_tenant_load_raises_key_error",
          "type": "Function",
          "lineno": 17
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_update.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_update.py::test_update_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/tenant/test_update.py::test_update_calls_requests",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/tenant/test_update.py::test_update_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/tenant/test_update.py::test_update_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/tenant/test_update.py::test_update_returns_none",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_usermembercreate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_usermembercreate.py::test_usermembercreate_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/tenant/test_usermembercreate.py::test_usermembercreate_calls_requests",
          "type": "Function",
          "lineno": 19
        },
        {
          "nodeid": "tests/tenant/test_usermembercreate.py::test_usermembercreate_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 28
        },
        {
          "nodeid": "tests/tenant/test_usermembercreate.py::test_usermembercreate_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/tenant/test_usermembercreate.py::test_usermembercreate_returns_none",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_usermemberdelete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_usermemberdelete.py::test_usermemberdelete_params",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/tenant/test_usermemberdelete.py::test_usermemberdelete_calls_requests",
          "type": "Function",
          "lineno": 21
        },
        {
          "nodeid": "tests/tenant/test_usermemberdelete.py::test_usermemberdelete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 32
        },
        {
          "nodeid": "tests/tenant/test_usermemberdelete.py::test_usermemberdelete_raises_for_status",
          "type": "Function",
          "lineno": 42
        },
        {
          "nodeid": "tests/tenant/test_usermemberdelete.py::test_usermemberdelete_returns_none",
          "type": "Function",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/tenant/test_usermemberoptions.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_usermemberoptions.py::test_usermemberoptions_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/tenant/test_usermemberoptions.py::test_usermemberoptions_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/tenant/test_usermemberoptions.py::test_usermemberoptions_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/tenant/test_usermemberoptions.py::test_usermemberoptions_raises_for_status",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/tenant/test_usermemberoptions.py::test_usermemberoptions_returns_resource_options",
          "type": "Function",
          "lineno": 47
        }
      ]
    },
    {
      "nodeid": "tests/tenant",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/tenant/test_count.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_create.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_delete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_groupmembercreate.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_groupmemberdelete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_groupmemberoptions.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_options.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_tenant.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_update.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_usermembercreate.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_usermemberdelete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/tenant/test_usermemberoptions.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/user/test_count.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/user/test_count.py::test_count_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/user/test_count.py::test_count_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/user/test_count.py::test_count_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/user/test_count.py::test_count_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/user/test_count.py::test_count_returns_int",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/user/test_create.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/user/test_create.py::test_create_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/user/test_create.py::test_create_calls_requests",
          "type": "Function",
          "lineno": 30
        },
        {
          "nodeid": "tests/user/test_create.py::test_create_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 39
        },
        {
          "nodeid": "tests/user/test_create.py::test_create_raises_for_status",
          "type": "Function",
          "lineno": 46
        },
        {
          "nodeid": "tests/user/test_create.py::test_create_returns_none",
          "type": "Function",
          "lineno": 55
        }
      ]
    },
    {
      "nodeid": "tests/user/test_delete.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/user/test_delete.py::test_delete_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/user/test_delete.py::test_delete_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/user/test_delete.py::test_delete_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/user/test_delete.py::test_delete_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/user/test_delete.py::test_delete_returns_none",
          "type": "Function",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/user/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/user/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/user/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/user/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/user/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/user/test_getlist.py::test_getlist_returns_users",
          "type": "Function",
          "lineno": 46
        }
      ]
    },
    {
      "nodeid": "tests/user/test_getprofile.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/user/test_getprofile.py::test_getprofile_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/user/test_getprofile.py::test_getprofile_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/user/test_getprofile.py::test_getprofile_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/user/test_getprofile.py::test_getprofile_raises_for_status",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/user/test_getprofile.py::test_getprofile_returns_user",
          "type": "Function",
          "lineno": 46
        }
      ]
    },
    {
      "nodeid": "tests/user/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/user/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/user/test_options.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/user/test_options.py::test_options_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/user/test_options.py::test_options_calls_requests",
          "type": "Function",
          "lineno": 24
        },
        {
          "nodeid": "tests/user/test_options.py::test_options_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/user/test_options.py::test_options_raises_for_status",
          "type": "Function",
          "lineno": 40
        },
        {
          "nodeid": "tests/user/test_options.py::test_options_returns_resource_options",
          "type": "Function",
          "lineno": 50
        }
      ]
    },
    {
      "nodeid": "tests/user/test_unlock.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/user/test_unlock.py::test_unlock_user_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/user/test_unlock.py::test_unlock_calls_requests",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/user/test_unlock.py::test_unlock_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 29
        },
        {
          "nodeid": "tests/user/test_unlock.py::test_unlock_raises_for_status",
          "type": "Function",
          "lineno": 37
        },
        {
          "nodeid": "tests/user/test_unlock.py::test_unlock_returns_none",
          "type": "Function",
          "lineno": 46
        }
      ]
    },
    {
      "nodeid": "tests/user/test_update_credentials.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/user/test_update_credentials.py::test_update_credentials_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/user/test_update_credentials.py::test_update_credentials_calls_requests",
          "type": "Function",
          "lineno": 25
        },
        {
          "nodeid": "tests/user/test_update_credentials.py::test_update_credentials_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/user/test_update_credentials.py::test_update_credentials_raises_for_status",
          "type": "Function",
          "lineno": 45
        },
        {
          "nodeid": "tests/user/test_update_credentials.py::test_update_credentials_returns_none",
          "type": "Function",
          "lineno": 56
        }
      ]
    },
    {
      "nodeid": "tests/user/test_update_profile.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/user/test_update_profile.py::test_update_profile_params",
          "type": "Function",
          "lineno": 12
        },
        {
          "nodeid": "tests/user/test_update_profile.py::test_update_profile_calls_requests",
          "type": "Function",
          "lineno": 24
        },
        {
          "nodeid": "tests/user/test_update_profile.py::test_update_profile_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 33
        },
        {
          "nodeid": "tests/user/test_update_profile.py::test_update_profile_raises_for_status",
          "type": "Function",
          "lineno": 41
        },
        {
          "nodeid": "tests/user/test_update_profile.py::test_update_profile_returns_none",
          "type": "Function",
          "lineno": 50
        }
      ]
    },
    {
      "nodeid": "tests/user/test_user.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/user/test_user.py::test_user_load",
          "type": "Function",
          "lineno": 9
        },
        {
          "nodeid": "tests/user/test_user.py::test_user_load_raises_key_error",
          "type": "Function",
          "lineno": 19
        }
      ]
    },
    {
      "nodeid": "tests/user",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/user/test_count.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/user/test_create.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/user/test_delete.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/user/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/user/test_getprofile.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/user/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/user/test_options.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/user/test_unlock.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/user/test_update_credentials.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/user/test_update_profile.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/user/test_user.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/variable/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/variable/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/variable/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/variable/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/variable/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/variable/test_get.py::test_get_returns_variableinstance",
          "type": "Function",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/variable/test_getlist.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/variable/test_getlist.py::test_getlist_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/variable/test_getlist.py::test_getlist_params_add_equal_value_filter",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/variable/test_getlist.py::test_getlist_params_add_not_equal_value_filter",
          "type": "Function",
          "lineno": 25
        },
        {
          "nodeid": "tests/variable/test_getlist.py::test_getlist_params_add_greater_than_value_filter",
          "type": "Function",
          "lineno": 32
        },
        {
          "nodeid": "tests/variable/test_getlist.py::test_getlist_params_add_less_than_value_filter",
          "type": "Function",
          "lineno": 39
        },
        {
          "nodeid": "tests/variable/test_getlist.py::test_getlist_params_add_like_value_filter",
          "type": "Function",
          "lineno": 46
        },
        {
          "nodeid": "tests/variable/test_getlist.py::test_getlist_calls_requests",
          "type": "Function",
          "lineno": 53
        },
        {
          "nodeid": "tests/variable/test_getlist.py::test_getlist_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 62
        },
        {
          "nodeid": "tests/variable/test_getlist.py::test_getlist_raises_for_status",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/variable/test_getlist.py::test_getlist_returns_variableinstances",
          "type": "Function",
          "lineno": 79
        }
      ]
    },
    {
      "nodeid": "tests/variable/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/variable/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/variable/test_variable.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/variable/test_variable.py::test_variable_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/variable/test_variable.py::test_variable_load_raises_keyerror",
          "type": "Function",
          "lineno": 18
        }
      ]
    },
    {
      "nodeid": "tests/variable/test_variableinstance.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/variable/test_variableinstance.py::test_variableinstance_load",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/variable/test_variableinstance.py::test_variableinstance_load_raises_keyerror",
          "type": "Function",
          "lineno": 25
        }
      ]
    },
    {
      "nodeid": "tests/variable",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/variable/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/variable/test_getlist.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/variable/test_module.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/variable/test_variable.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/variable/test_variableinstance.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/version/test_get.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/version/test_get.py::test_get_params",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/version/test_get.py::test_get_calls_requests",
          "type": "Function",
          "lineno": 18
        },
        {
          "nodeid": "tests/version/test_get.py::test_get_raises_pycamunda_exception",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/version/test_get.py::test_get_raises_for_status",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/version/test_get.py::test_get_returns_string",
          "type": "Function",
          "lineno": 43
        }
      ]
    },
    {
      "nodeid": "tests/version/test_module.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/version/test_module.py::test_all_contains_only_valid_names",
          "type": "Function",
          "lineno": 3
        }
      ]
    },
    {
      "nodeid": "tests/version",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/version/test_get.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/version/test_module.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/activityinst",
          "type": "Package"
        },
        {
          "nodeid": "tests/auth",
          "type": "Package"
        },
        {
          "nodeid": "tests/base",
          "type": "Package"
        },
        {
          "nodeid": "tests/batch",
          "type": "Package"
        },
        {
          "nodeid": "tests/casedef",
          "type": "Package"
        },
        {
          "nodeid": "tests/caseinst",
          "type": "Package"
        },
        {
          "nodeid": "tests/condition",
          "type": "Package"
        },
        {
          "nodeid": "tests/decisiondef",
          "type": "Package"
        },
        {
          "nodeid": "tests/decisionreqdef",
          "type": "Package"
        },
        {
          "nodeid": "tests/deployment",
          "type": "Package"
        },
        {
          "nodeid": "tests/execution",
          "type": "Package"
        },
        {
          "nodeid": "tests/externaltask",
          "type": "Package"
        },
        {
          "nodeid": "tests/filter",
          "type": "Package"
        },
        {
          "nodeid": "tests/group",
          "type": "Package"
        },
        {
          "nodeid": "tests/identity",
          "type": "Package"
        },
        {
          "nodeid": "tests/incident",
          "type": "Package"
        },
        {
          "nodeid": "tests/instruction",
          "type": "Package"
        },
        {
          "nodeid": "tests/message",
          "type": "Package"
        },
        {
          "nodeid": "tests/migration",
          "type": "Package"
        },
        {
          "nodeid": "tests/processdef",
          "type": "Package"
        },
        {
          "nodeid": "tests/processinst",
          "type": "Package"
        },
        {
          "nodeid": "tests/resource",
          "type": "Package"
        },
        {
          "nodeid": "tests/signal",
          "type": "Package"
        },
        {
          "nodeid": "tests/task",
          "type": "Package"
        },
        {
          "nodeid": "tests/telemetry",
          "type": "Package"
        },
        {
          "nodeid": "tests/tenant",
          "type": "Package"
        },
        {
          "nodeid": "tests/user",
          "type": "Package"
        },
        {
          "nodeid": "tests/variable",
          "type": "Package"
        },
        {
          "nodeid": "tests/version",
          "type": "Package"
        }
      ]
    },
    {
      "nodeid": ".",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "docs",
          "type": "Dir"
        },
        {
          "nodeid": "pycamunda",
          "type": "Package"
        },
        {
          "nodeid": "pycamunda.egg-info",
          "type": "Dir"
        },
        {
          "nodeid": "tests",
          "type": "Package"
        }
      ]
    }
  ],
  "tests": [
    {
      "nodeid": "tests/activityinst/test_activityinstance.py::test_activity_instance_load",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_activity_instance_load",
        "__wrapped__",
        "patchings",
        "test_activityinstance.py",
        "activityinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/activityinst/test_activityinstance.py::test_activity_instance_load_raises_keyerror",
      "lineno": 57,
      "outcome": "passed",
      "keywords": [
        "test_activity_instance_load_raises_keyerror",
        "__wrapped__",
        "patchings",
        "test_activityinstance.py",
        "activityinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/activityinst/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "activityinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/activityinst/test_transitioninstance.py::test_transition_instance_load",
      "lineno": 16,
      "outcome": "passed",
      "keywords": [
        "test_transition_instance_load",
        "__wrapped__",
        "patchings",
        "test_transitioninstance.py",
        "activityinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/activityinst/test_transitioninstance.py::test_transition_instance_load_raises_keyerror",
      "lineno": 34,
      "outcome": "passed",
      "keywords": [
        "test_transition_instance_load_raises_keyerror",
        "test_transitioninstance.py",
        "activityinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_authorization.py::test_authorization_load",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_authorization_load",
        "test_authorization.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_authorization.py::test_authorization_load_raises_keyerror",
      "lineno": 25,
      "outcome": "passed",
      "keywords": [
        "test_authorization_load_raises_keyerror",
        "test_authorization.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_check.py::test_check_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_check_params",
        "test_check.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_check.py::test_check_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_check_calls_requests",
        "__wrapped__",
        "patchings",
        "test_check.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2260 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_check.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 269,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Check(url='http://localhost/engine-rest/auth/check', permission_name='READ', permission_value=1, resource_name='USER', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B80B290>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B80B3D0>\nquery_string = 'permissionName=READ&permissionValue=1&resourceName=USER&resourceType=1&resourceId=demo'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2260 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200209838608'>\nengine_url = 'http://localhost/engine-rest'\ncheck_input = {'permission_name': 'READ', 'permission_value': 1, 'resource_id': 'demo', 'resource_name': 'USER', ...}\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_check_calls_requests(mock, engine_url, check_input):\n        check_authorization = pycamunda.auth.Check(url=engine_url, **check_input)\n>       check_authorization()\n\ntests\\auth\\test_check.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:269: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Check(url='http://localhost/engine-rest/auth/check', permission_name='READ', permission_value=1, resource_name='USER', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B80B290>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B80B3D0>\nquery_string = 'permissionName=READ&permissionValue=1&resourceName=USER&resourceType=1&resourceId=demo'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2260 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_check.py::test_check_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_check_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_check.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_check.py::test_check_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_check_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_check.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_check.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 269,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Check(url='http://localhost/engine-rest/auth/check', permission_name='READ', permission_value=1, resource_name='USER', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B861440>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B862200>\nquery_string = 'permissionName=READ&permissionValue=1&resourceName=USER&resourceType=1&resourceId=demo'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212163504'>\nengine_url = 'http://localhost/engine-rest'\ncheck_input = {'permission_name': 'READ', 'permission_value': 1, 'resource_id': 'demo', 'resource_name': 'USER', ...}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.auth.Permission', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_check_raises_for_status(mock, engine_url, check_input):\n        check_authorization = pycamunda.auth.Check(url=engine_url, **check_input)\n>       check_authorization()\n\ntests\\auth\\test_check.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:269: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Check(url='http://localhost/engine-rest/auth/check', permission_name='READ', permission_value=1, resource_name='USER', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B861440>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B862200>\nquery_string = 'permissionName=READ&permissionValue=1&resourceName=USER&resourceType=1&resourceId=demo'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_check.py::test_check_returns_permission",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_check_returns_permission",
        "__wrapped__",
        "patchings",
        "test_check.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2267 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_check.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 269,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Check(url='http://localhost/engine-rest/auth/check', permission_name='READ', permission_value=1, resource_name='USER', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B862F70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B863470>\nquery_string = 'permissionName=READ&permissionValue=1&resourceName=USER&resourceType=1&resourceId=demo'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2267 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\ncheck_input = {'permission_name': 'READ', 'permission_value': 1, 'resource_id': 'demo', 'resource_name': 'USER', ...}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_check_returns_permission(engine_url, check_input):\n        check_authorization = pycamunda.auth.Check(url=engine_url, **check_input)\n>       permission = check_authorization()\n\ntests\\auth\\test_check.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:269: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Check(url='http://localhost/engine-rest/auth/check', permission_name='READ', permission_value=1, resource_name='USER', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B862F70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B863470>\nquery_string = 'permissionName=READ&permissionValue=1&resourceName=USER&resourceType=1&resourceId=demo'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2267 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_count.py::test_count_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_count_params",
        "test_count.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_count.py::test_count_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_count_calls_requests",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2256 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_count.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 209,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/auth/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B850090>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B8500E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2256 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200212167968'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_count_calls_requests(mock, engine_url):\n        get_count = pycamunda.auth.Count(url=engine_url)\n>       get_count()\n\ntests\\auth\\test_count.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:209: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/auth/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B850090>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B8500E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2256 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_count.py::test_count_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_count_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_count.py::test_count_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_count_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2253 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_count.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 209,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/auth/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B851710>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B851580>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2253 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212668240'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_count_raises_for_status(mock, engine_url):\n        get_count = pycamunda.auth.Count(url=engine_url)\n>       get_count()\n\ntests\\auth\\test_count.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:209: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/auth/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B851710>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B851580>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2253 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_count.py::test_count_returns_authorizations",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_count_returns_authorizations",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_count.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 209,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/auth/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B851990>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B8519E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', count_response_mock)\n    def test_count_returns_authorizations(engine_url):\n        get_count = pycamunda.auth.Count(url=engine_url)\n>       count = get_count()\n\ntests\\auth\\test_count.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:209: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/auth/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B851990>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B8519E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_create.py::test_create_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_create_params",
        "test_create.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_create.py::test_create_raises_assert",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_create_raises_assert",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_create.py::test_create_calls_requests",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_create_calls_requests",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 50,
          "message": "TypeError: functions are not supported for this option"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_create.py",
            "lineno": 34,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 342,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 50,
            "message": "TypeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200212811504'>\nengine_url = <MagicMock name='Authorization' id='3200194690176'>\ncreate_input = {'permissions': ['CREATE'], 'resource_id': 'demo', 'resource_type': 1, 'type_': 0, ...}\n\n    @unittest.mock.patch('pycamunda.auth.Authorization')\n    @unittest.mock.patch('requests.Session.request')\n    def test_create_calls_requests(mock, engine_url, create_input):\n        create_authorization = pycamunda.auth.Create(url=engine_url, **create_input)\n>       create_authorization()\n\ntests\\auth\\test_create.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:342: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url=<MagicMock name='Authorization.__add__().__add__().format().rstrip()' id='3200206970640'>, type_=0, permissions=['CREATE'], user_id='anId', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B850180>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B850040>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n>           curl.setopt(pycurl.URL, self.url)\nE           TypeError: functions are not supported for this option\n\npycamunda\\base.py:50: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_create.py::test_create_raises_pycamunda_exception",
      "lineno": 39,
      "outcome": "passed",
      "keywords": [
        "test_create_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_create.py::test_create_raises_for_status",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_create_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_create.py",
            "lineno": 52,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 342,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/auth/create', type_=0, permissions=['CREATE'], user_id='anId', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B89CEF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B89CB30>\nbody = '{\"type\": 0, \"permissions\": [\"CREATE\"], \"userId\": \"anId\", \"resourceType\": 1, \"resourceId\": \"demo\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212166576'>\nengine_url = 'http://localhost/engine-rest'\ncreate_input = {'permissions': ['CREATE'], 'resource_id': 'demo', 'resource_type': 1, 'type_': 0, ...}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.auth.Authorization', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_create_raises_for_status(mock, engine_url, create_input):\n        create_authorization = pycamunda.auth.Create(url=engine_url, **create_input)\n>       create_authorization()\n\ntests\\auth\\test_create.py:52: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:342: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/auth/create', type_=0, permissions=['CREATE'], user_id='anId', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B89CEF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B89CB30>\nbody = '{\"type\": 0, \"permissions\": [\"CREATE\"], \"userId\": \"anId\", \"resourceType\": 1, \"resourceId\": \"demo\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_create.py::test_create_returns_authorization",
      "lineno": 56,
      "outcome": "failed",
      "keywords": [
        "test_create_returns_authorization",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_create.py",
            "lineno": 62,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 342,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/auth/create', type_=0, permissions=['CREATE'], user_id='anId', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B89D5D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B89D580>\nbody = '{\"type\": 0, \"permissions\": [\"CREATE\"], \"userId\": \"anId\", \"resourceType\": 1, \"resourceId\": \"demo\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\ncreate_input = {'permissions': ['CREATE'], 'resource_id': 'demo', 'resource_type': 1, 'type_': 0, ...}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.resource.ResourceType', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    def test_create_returns_authorization(engine_url, create_input):\n        create_authorization = pycamunda.auth.Create(url=engine_url, **create_input)\n>       authorization = create_authorization()\n\ntests\\auth\\test_create.py:62: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:342: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/auth/create', type_=0, permissions=['CREATE'], user_id='anId', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B89D5D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B89D580>\nbody = '{\"type\": 0, \"permissions\": [\"CREATE\"], \"userId\": \"anId\", \"resourceType\": 1, \"resourceId\": \"demo\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_delete.py::test_delete_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_delete_params",
        "test_delete.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_delete.py::test_delete_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_delete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_delete.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 408,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/auth/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD2B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B89F010>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B89E250>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200213200304'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_delete_calls_requests(mock, engine_url):\n        delete_authorization = pycamunda.auth.Delete(url=engine_url, id_='anId')\n>       delete_authorization()\n\ntests\\auth\\test_delete.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:408: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/auth/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD2B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B89F010>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B89E250>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_delete.py::test_delete_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_delete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_delete.py::test_delete_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_delete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_delete.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 408,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/auth/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B919490>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B9194E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200213194256'>\nengine_url = 'http://localhost/engine-rest'\ncreate_input = {'permissions': ['CREATE'], 'resource_id': 'demo', 'resource_type': 1, 'type_': 0, ...}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_delete_raises_for_status(mock, engine_url, create_input):\n        delete_authorization = pycamunda.auth.Delete(url=engine_url, id_='anId')\n>       delete_authorization()\n\ntests\\auth\\test_delete.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:408: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/auth/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B919490>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B9194E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_delete.py::test_delete_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_delete_returns_none",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_delete.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 408,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/auth/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B9191C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B918270>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_delete_returns_none(engine_url):\n        delete_authorization = pycamunda.auth.Delete(url=engine_url, id_='anId')\n>       result = delete_authorization()\n\ntests\\auth\\test_delete.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:408: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/auth/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B9191C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B918270>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_get.py::test_get_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_get.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 229,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/auth/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B91A160>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B919030>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200213426992'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    @unittest.mock.patch('pycamunda.resource.ResourceType', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    def test_get_calls_requests(mock, engine_url):\n        get_authorization = pycamunda.auth.Get(url=engine_url, id_='anId')\n>       get_authorization()\n\ntests\\auth\\test_get.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:229: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/auth/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B91A160>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B919030>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_get.py::test_get_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2249 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_get.py",
            "lineno": 42,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 229,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/auth/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B91B5B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B91A980>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2249 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200213426800'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.auth.Authorization', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_authorization = pycamunda.auth.Get(url=engine_url, id_='anId')\n>       get_authorization()\n\ntests\\auth\\test_get.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:229: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/auth/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B91B5B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B91A980>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2249 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_get.py::test_get_returns_authorizations",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_authorizations",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_get.py",
            "lineno": 52,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 229,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/auth/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B91BCE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B91B880>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.resource.ResourceType', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    def test_get_returns_authorizations(engine_url):\n        get_authorization = pycamunda.auth.Get(url=engine_url, id_='anId')\n>       authorizations = get_authorization()\n\ntests\\auth\\test_get.py:52: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:229: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/auth/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B91BCE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B91B880>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_getlist.py::test_getlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_getlist.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 161,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/auth')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B95C7C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B95C9F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200213432944'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_authorizations = pycamunda.auth.GetList(url=engine_url)\n>       get_authorizations()\n\ntests\\auth\\test_getlist.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:161: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/auth')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B95C7C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B95C9F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_getlist.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 161,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/auth')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B95CF90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B95CF40>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200213420560'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.auth.Authorization', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_authorizations = pycamunda.auth.GetList(url=engine_url)\n>       get_authorizations()\n\ntests\\auth\\test_getlist.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:161: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/auth')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B95CF90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B95CF40>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_getlist.py::test_getlist_returns_authorizations",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_authorizations",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_getlist.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 161,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/auth')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B95E4D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B95F0B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getlist_returns_authorizations(engine_url):\n        get_authorizations = pycamunda.auth.GetList(url=engine_url)\n>       authorizations = get_authorizations()\n\ntests\\auth\\test_getlist.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:161: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/auth')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B95E4D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B95F0B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_options.py::test_options_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_options_params",
        "test_options.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_options.py::test_options_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_options_calls_requests",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2294 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_options.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 294,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/auth')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B9684A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B968360>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2294 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200212943504'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_options_calls_requests(mock, engine_url):\n        get_options = pycamunda.auth.Options(url=engine_url)\n>       get_options()\n\ntests\\auth\\test_options.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:294: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/auth')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B9684A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B968360>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2294 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_options.py::test_options_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_options_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_options.py::test_options_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_options_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2274 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_options.py",
            "lineno": 42,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 294,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/auth')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B968E00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B96A570>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2274 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212161488'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.resource.ResourceOptions', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_options_raises_for_status(mock, engine_url):\n        get_options = pycamunda.auth.Options(url=engine_url)\n>       get_options()\n\ntests\\auth\\test_options.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:294: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/auth')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B968E00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B96A570>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2274 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_options.py::test_options_returns_resource_options",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_options_returns_resource_options",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_options.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 294,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/auth')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B9691C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B969300>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_options_returns_resource_options(engine_url):\n        get_options = pycamunda.auth.Options(url=engine_url)\n>       resource_options = get_options()\n\ntests\\auth\\test_options.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:294: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/auth')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B9691C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B969300>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_update.py::test_update_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_update_params",
        "test_update.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_update.py::test_update_raises_assert",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_update_raises_assert",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_update.py::test_update_calls_requests",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_update_calls_requests",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_update.py",
            "lineno": 32,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 390,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/auth/anId', id_='anId', permissions=['CREATE'], user_id='anId', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B96B150>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B96B1A0>\nbody = '{\"permissions\": [\"CREATE\"], \"userId\": \"anId\", \"resourceType\": 1, \"resourceId\": \"demo\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200212956992'>\nengine_url = 'http://localhost/engine-rest'\nupdate_input = {'id_': 'anId', 'permissions': ['CREATE'], 'resource_id': 'demo', 'resource_type': 1, ...}\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_update_calls_requests(mock, engine_url, update_input):\n        update_authorization = pycamunda.auth.Update(url=engine_url, **update_input)\n>       update_authorization()\n\ntests\\auth\\test_update.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:390: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/auth/anId', id_='anId', permissions=['CREATE'], user_id='anId', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B96B150>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B96B1A0>\nbody = '{\"permissions\": [\"CREATE\"], \"userId\": \"anId\", \"resourceType\": 1, \"resourceId\": \"demo\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_update.py::test_update_raises_pycamunda_exception",
      "lineno": 37,
      "outcome": "passed",
      "keywords": [
        "test_update_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_update.py::test_update_raises_for_status",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_update_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2253 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_update.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 390,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/auth/anId', id_='anId', permissions=['CREATE'], user_id='anId', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B878090>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B8785E0>\nbody = '{\"permissions\": [\"CREATE\"], \"userId\": \"anId\", \"resourceType\": 1, \"resourceId\": \"demo\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2253 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212883200'>\nengine_url = 'http://localhost/engine-rest'\nupdate_input = {'id_': 'anId', 'permissions': ['CREATE'], 'resource_id': 'demo', 'resource_type': 1, ...}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_update_raises_for_status(mock, engine_url, update_input):\n        update_authorization = pycamunda.auth.Update(url=engine_url, **update_input)\n>       update_authorization()\n\ntests\\auth\\test_update.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:390: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/auth/anId', id_='anId', permissions=['CREATE'], user_id='anId', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B878090>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B8785E0>\nbody = '{\"permissions\": [\"CREATE\"], \"userId\": \"anId\", \"resourceType\": 1, \"resourceId\": \"demo\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2253 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/auth/test_update.py::test_update_returns_none",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_update_returns_none",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "auth",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\auth\\test_update.py",
            "lineno": 58,
            "message": ""
          },
          {
            "path": "pycamunda\\auth.py",
            "lineno": 390,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/auth/anId', id_='anId', permissions=['CREATE'], user_id='anId', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B8789F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B878A40>\nbody = '{\"permissions\": [\"CREATE\"], \"userId\": \"anId\", \"resourceType\": 1, \"resourceId\": \"demo\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\nupdate_input = {'id_': 'anId', 'permissions': ['CREATE'], 'resource_id': 'demo', 'resource_type': 1, ...}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    def test_update_returns_none(engine_url, update_input):\n        update_authorization = pycamunda.auth.Update(url=engine_url, **update_input)\n>       result = update_authorization()\n\ntests\\auth\\test_update.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\auth.py:390: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/auth/anId', id_='anId', permissions=['CREATE'], user_id='anId', resource_type=1, resource_id='demo')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B8789F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B878A40>\nbody = '{\"permissions\": [\"CREATE\"], \"userId\": \"anId\", \"resourceType\": 1, \"resourceId\": \"demo\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/base/test_camundarequest.py::test_camundarequest_keeps_query_params",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_camundarequest_keeps_query_params",
        "test_camundarequest.py",
        "base",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/base/test_camundarequest.py::test_camundarequest_keeps_body_params",
      "lineno": 13,
      "outcome": "passed",
      "keywords": [
        "test_camundarequest_keeps_body_params",
        "test_camundarequest.py",
        "base",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/base/test_camundarequest.py::test_camundarequest_converts_bool_query_params",
      "lineno": 21,
      "outcome": "passed",
      "keywords": [
        "test_camundarequest_converts_bool_query_params",
        "test_camundarequest.py",
        "base",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/base/test_camundarequest.py::test_camundarequest_converts_datetime_params",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_camundarequest_converts_datetime_params",
        "test_camundarequest.py",
        "base",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/base/test_camundarequest.py::test_camundarequest_session",
      "lineno": 38,
      "outcome": "failed",
      "keywords": [
        "test_camundarequest_session",
        "__wrapped__",
        "patchings",
        "test_camundarequest.py",
        "base",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\mock.py",
          "lineno": 1586,
          "message": "TypeError: cannot set 'perform' attribute of immutable type 'pycurl.Curl'"
        },
        "traceback": [
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\mock.py",
            "lineno": 1387,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\contextlib.py",
            "lineno": 137,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\mock.py",
            "lineno": 1369,
            "message": "in decoration_helper"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\contextlib.py",
            "lineno": 526,
            "message": "in enter_context"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\mock.py",
            "lineno": 1580,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\mock.py",
            "lineno": 1586,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <unittest.mock._patch object at 0x000002E91975C0E0>\n\n    def __enter__(self):\n        \"\"\"Perform the patch.\"\"\"\n        new, spec, spec_set = self.new, self.spec, self.spec_set\n        autospec, kwargs = self.autospec, self.kwargs\n        new_callable = self.new_callable\n        self.target = self.getter()\n    \n        # normalise False to None\n        if spec is False:\n            spec = None\n        if spec_set is False:\n            spec_set = None\n        if autospec is False:\n            autospec = None\n    \n        if spec is not None and autospec is not None:\n            raise TypeError(\"Can't specify spec and autospec\")\n        if ((spec is not None or autospec is not None) and\n            spec_set not in (True, None)):\n            raise TypeError(\"Can't provide explicit spec_set *and* spec or autospec\")\n    \n        original, local = self.get_original()\n    \n        if new is DEFAULT and autospec is None:\n            inherit = False\n            if spec is True:\n                # set spec to the object we are replacing\n                spec = original\n                if spec_set is True:\n                    spec_set = original\n                    spec = None\n            elif spec is not None:\n                if spec_set is True:\n                    spec_set = spec\n                    spec = None\n            elif spec_set is True:\n                spec_set = original\n    \n            if spec is not None or spec_set is not None:\n                if original is DEFAULT:\n                    raise TypeError(\"Can't use 'spec' with create=True\")\n                if isinstance(original, type):\n                    # If we're patching out a class and there is a spec\n                    inherit = True\n            if spec is None and _is_async_obj(original):\n                Klass = AsyncMock\n            else:\n                Klass = MagicMock\n            _kwargs = {}\n            if new_callable is not None:\n                Klass = new_callable\n            elif spec is not None or spec_set is not None:\n                this_spec = spec\n                if spec_set is not None:\n                    this_spec = spec_set\n                if _is_list(this_spec):\n                    not_callable = '__call__' not in this_spec\n                else:\n                    not_callable = not callable(this_spec)\n                if _is_async_obj(this_spec):\n                    Klass = AsyncMock\n                elif not_callable:\n                    Klass = NonCallableMagicMock\n    \n            if spec is not None:\n                _kwargs['spec'] = spec\n            if spec_set is not None:\n                _kwargs['spec_set'] = spec_set\n    \n            # add a name to mocks\n            if (isinstance(Klass, type) and\n                issubclass(Klass, NonCallableMock) and self.attribute):\n                _kwargs['name'] = self.attribute\n    \n            _kwargs.update(kwargs)\n            new = Klass(**_kwargs)\n    \n            if inherit and _is_instance_mock(new):\n                # we can only tell if the instance should be callable if the\n                # spec is not a list\n                this_spec = spec\n                if spec_set is not None:\n                    this_spec = spec_set\n                if (not _is_list(this_spec) and not\n                    _instance_callable(this_spec)):\n                    Klass = NonCallableMagicMock\n    \n                _kwargs.pop('name')\n                new.return_value = Klass(_new_parent=new, _new_name='()',\n                                         **_kwargs)\n        elif autospec is not None:\n            # spec is ignored, new *must* be default, spec_set is treated\n            # as a boolean. Should we check spec is not None and that spec_set\n            # is a bool?\n            if new is not DEFAULT:\n                raise TypeError(\n                    \"autospec creates the mock for you. Can't specify \"\n                    \"autospec and new.\"\n                )\n            if original is DEFAULT:\n                raise TypeError(\"Can't use 'autospec' with create=True\")\n            spec_set = bool(spec_set)\n            if autospec is True:\n                autospec = original\n    \n            if _is_instance_mock(self.target):\n                raise InvalidSpecError(\n                    f'Cannot autospec attr {self.attribute!r} as the patch '\n                    f'target has already been mocked out. '\n                    f'[target={self.target!r}, attr={autospec!r}]')\n            if _is_instance_mock(autospec):\n                target_name = getattr(self.target, '__name__', self.target)\n                raise InvalidSpecError(\n                    f'Cannot autospec attr {self.attribute!r} from target '\n                    f'{target_name!r} as it has already been mocked out. '\n                    f'[target={self.target!r}, attr={autospec!r}]')\n    \n            new = create_autospec(autospec, spec_set=spec_set,\n                                  _name=self.attribute, **kwargs)\n        elif kwargs:\n            # can't set keyword args when we aren't creating the mock\n            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)\n            raise TypeError(\"Can't pass kwargs to a mock we aren't creating\")\n    \n        new_attr = new\n    \n        self.temp_original = original\n        self.is_local = local\n        self._exit_stack = contextlib.ExitStack()\n        try:\n>           setattr(self.target, self.attribute, new_attr)\nE           TypeError: cannot set 'perform' attribute of immutable type 'pycurl.Curl'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\mock.py:1567: TypeError\n\nDuring handling of the above exception, another exception occurred:\n\nargs = ()\nkeywargs = {'MyRequest': <class 'tests.base.conftest.MyRequest.<locals>._MyRequest'>, 'engine_url': 'http://localhost/engine-rest'}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n>       with self.decoration_helper(patched,\n                                    args,\n                                    keywargs) as (newargs, newkeywargs):\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\mock.py:1387: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\contextlib.py:137: in __enter__\n    return next(self.gen)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\mock.py:1369: in decoration_helper\n    arg = exit_stack.enter_context(patching)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\contextlib.py:526: in enter_context\n    result = _enter(cm)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\mock.py:1580: in __enter__\n    if not self.__exit__(*sys.exc_info()):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unittest.mock._patch object at 0x000002E91975C0E0>\nexc_info = (<class 'TypeError'>, TypeError(\"cannot set 'perform' attribute of immutable type 'pycurl.Curl'\"), <traceback object at 0x000002E91B874380>)\n\n    def __exit__(self, *exc_info):\n        \"\"\"Undo the patch.\"\"\"\n        if self.is_local and self.temp_original is not DEFAULT:\n>           setattr(self.target, self.attribute, self.temp_original)\nE           TypeError: cannot set 'perform' attribute of immutable type 'pycurl.Curl'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\mock.py:1586: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py::test_activate_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_activate_params",
        "test_activatesuspend.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py::test_activate_path",
      "lineno": 19,
      "outcome": "passed",
      "keywords": [
        "test_activate_path",
        "test_activatesuspend.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py::test_activate_calls_requests",
      "lineno": 25,
      "outcome": "failed",
      "keywords": [
        "test_activate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2424 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_activatesuspend.py",
            "lineno": 29,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 230,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Activate(url='http://localhost/engine-rest/batch/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9EE9D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9EEA70>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2424 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200230638416'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_activate_calls_requests(mock, engine_url):\n        activate_batch = pycamunda.batch.Activate(url=engine_url, id_='anId')\n>       activate_batch()\n\ntests\\batch\\test_activatesuspend.py:29: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:230: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Activate(url='http://localhost/engine-rest/batch/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9EE9D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9EEA70>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2424 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py::test_activate_raises_pycamunda_exception",
      "lineno": 34,
      "outcome": "passed",
      "keywords": [
        "test_activate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py::test_activate_raises_for_status",
      "lineno": 41,
      "outcome": "failed",
      "keywords": [
        "test_activate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_activatesuspend.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 230,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Activate(url='http://localhost/engine-rest/batch/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB8AB60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB8B4C0>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200230645856'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_activate_raises_for_status(mock, engine_url):\n        activate_batch = pycamunda.batch.Activate(url=engine_url, id_='anId')\n>       activate_batch()\n\ntests\\batch\\test_activatesuspend.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:230: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Activate(url='http://localhost/engine-rest/batch/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB8AB60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB8B4C0>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py::test_activate_returns_none",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_activate_returns_none",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2553 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_activatesuspend.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 230,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Activate(url='http://localhost/engine-rest/batch/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB8BB00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB8B8D0>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2553 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_activate_returns_none(engine_url):\n        activate_batch = pycamunda.batch.Activate(url=engine_url, id_='anId')\n>       result = activate_batch()\n\ntests\\batch\\test_activatesuspend.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:230: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Activate(url='http://localhost/engine-rest/batch/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB8BB00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB8B8D0>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2553 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py::test_suspend_params",
      "lineno": 58,
      "outcome": "passed",
      "keywords": [
        "test_suspend_params",
        "test_activatesuspend.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py::test_suspend_path",
      "lineno": 66,
      "outcome": "passed",
      "keywords": [
        "test_suspend_path",
        "test_activatesuspend.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py::test_suspend_calls_requests",
      "lineno": 72,
      "outcome": "failed",
      "keywords": [
        "test_suspend_calls_requests",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_activatesuspend.py",
            "lineno": 76,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 230,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Suspend(url='http://localhost/engine-rest/batch/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C94CC70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C94CCC0>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200230647728'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_suspend_calls_requests(mock, engine_url):\n        suspend_batch = pycamunda.batch.Suspend(url=engine_url, id_='anId')\n>       suspend_batch()\n\ntests\\batch\\test_activatesuspend.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:230: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Suspend(url='http://localhost/engine-rest/batch/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C94CC70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C94CCC0>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py::test_suspend_raises_pycamunda_exception",
      "lineno": 80,
      "outcome": "passed",
      "keywords": [
        "test_suspend_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py::test_suspend_raises_for_status",
      "lineno": 87,
      "outcome": "failed",
      "keywords": [
        "test_suspend_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_activatesuspend.py",
            "lineno": 92,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 230,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Suspend(url='http://localhost/engine-rest/batch/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C94CE50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C94CFE0>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212161776'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_suspend_raises_for_status(mock, engine_url):\n        suspend_batch = pycamunda.batch.Suspend(url=engine_url, id_='anId')\n>       suspend_batch()\n\ntests\\batch\\test_activatesuspend.py:92: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:230: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Suspend(url='http://localhost/engine-rest/batch/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C94CE50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C94CFE0>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_activatesuspend.py::test_suspend_returns_none",
      "lineno": 96,
      "outcome": "failed",
      "keywords": [
        "test_suspend_returns_none",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2406 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_activatesuspend.py",
            "lineno": 100,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 230,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Suspend(url='http://localhost/engine-rest/batch/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C94E160>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C94E110>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2406 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_suspend_returns_none(engine_url):\n        suspend_batch = pycamunda.batch.Suspend(url=engine_url, id_='anId')\n>       result = suspend_batch()\n\ntests\\batch\\test_activatesuspend.py:100: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:230: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Suspend(url='http://localhost/engine-rest/batch/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C94E160>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C94E110>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2406 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_batch.py::test_batch_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_batch_load",
        "test_batch.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_batch.py::test_batch_load_raises_keyerror",
      "lineno": 24,
      "outcome": "passed",
      "keywords": [
        "test_batch_load_raises_keyerror",
        "test_batch.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_batchstatistics.py::test_batchstats_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_batchstats_load",
        "test_batchstatistics.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_batchstatistics.py::test_batchstats_load_raises_keyerror",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_batchstats_load_raises_keyerror",
        "test_batchstatistics.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_count.py::test_count_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_count_params",
        "test_count.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_count.py::test_count_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_count_calls_requests",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2386 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_count.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 187,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/batch/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9E8BD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9E8C20>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2386 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231013840'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_count_calls_requests(mock, engine_url):\n        count_batches = pycamunda.batch.Count(url=engine_url)\n>       count_batches()\n\ntests\\batch\\test_count.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:187: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/batch/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9E8BD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9E8C20>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2386 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_count.py::test_count_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_count_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_count.py::test_count_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_count_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_count.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 187,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/batch/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9E9800>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9E9670>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212892320'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_count_raises_for_status(mock, engine_url):\n        count_batches = pycamunda.batch.Count(url=engine_url)\n>       count_batches()\n\ntests\\batch\\test_count.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:187: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/batch/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9E9800>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9E9670>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_count.py::test_count_returns_int",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_count_returns_int",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2419 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_count.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 187,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/batch/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9E9B70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9E9B20>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2419 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', count_response_mock)\n    def test_count_returns_int(engine_url):\n        count_batches = pycamunda.batch.Count(url=engine_url)\n>       result = count_batches()\n\ntests\\batch\\test_count.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:187: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/batch/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9E9B70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9E9B20>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2419 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_countstats.py::test_countstats_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_countstats_params",
        "test_countstats.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_countstats.py::test_countstats_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_countstats_calls_requests",
        "__wrapped__",
        "patchings",
        "test_countstats.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2553 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_countstats.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 371,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CountStats(url='http://localhost/engine-rest/batch/statistics/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9E9990>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9EB880>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2553 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231008224'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_countstats_calls_requests(mock, engine_url):\n        count_batch_stats = pycamunda.batch.CountStats(url=engine_url)\n>       count_batch_stats()\n\ntests\\batch\\test_countstats.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:371: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CountStats(url='http://localhost/engine-rest/batch/statistics/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9E9990>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9EB880>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2553 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_countstats.py::test_countstats_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_countstats_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_countstats.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_countstats.py::test_countstats_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_countstats_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_countstats.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2378 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_countstats.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 371,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CountStats(url='http://localhost/engine-rest/batch/statistics/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CA28AE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CA29D00>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2378 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231115520'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_countstats_raises_for_status(mock, engine_url):\n        count_batch_stats = pycamunda.batch.CountStats(url=engine_url)\n>       count_batch_stats()\n\ntests\\batch\\test_countstats.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:371: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CountStats(url='http://localhost/engine-rest/batch/statistics/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CA28AE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CA29D00>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2378 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_countstats.py::test_countstats_returns_int",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_countstats_returns_int",
        "__wrapped__",
        "patchings",
        "test_countstats.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_countstats.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 371,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CountStats(url='http://localhost/engine-rest/batch/statistics/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CA28F90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CA28F40>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', count_response_mock)\n    def test_countstats_returns_int(engine_url):\n        count_batch_stats = pycamunda.batch.CountStats(url=engine_url)\n>       result = count_batch_stats()\n\ntests\\batch\\test_countstats.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:371: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CountStats(url='http://localhost/engine-rest/batch/statistics/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CA28F90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CA28F40>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_delete.py::test_delete_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_delete_params",
        "test_delete.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_delete.py::test_delete_path",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_delete_path",
        "test_delete.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_delete.py::test_delete_calls_requests",
      "lineno": 24,
      "outcome": "failed",
      "keywords": [
        "test_delete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_delete.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 273,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/batch/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CA2A890>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CA2A750>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200212879696'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_delete_calls_requests(mock, engine_url):\n        delete_batch = pycamunda.batch.Delete(url=engine_url, id_='anId')\n>       delete_batch()\n\ntests\\batch\\test_delete.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:273: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/batch/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CA2A890>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CA2A750>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_delete.py::test_delete_raises_pycamunda_exception",
      "lineno": 33,
      "outcome": "passed",
      "keywords": [
        "test_delete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_delete.py::test_delete_raises_for_status",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_delete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2260 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_delete.py",
            "lineno": 45,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 273,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/batch/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CA2BD30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CA2ACA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2260 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231124640'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_delete_raises_for_status(mock, engine_url):\n        delete_batch = pycamunda.batch.Delete(url=engine_url, id_='anId')\n>       delete_batch()\n\ntests\\batch\\test_delete.py:45: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:273: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/batch/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CA2BD30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CA2ACA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2260 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_delete.py::test_delete_returns_none",
      "lineno": 49,
      "outcome": "failed",
      "keywords": [
        "test_delete_returns_none",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_delete.py",
            "lineno": 53,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 273,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/batch/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAA30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9AC0E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9AC130>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_delete_returns_none(engine_url):\n        delete_batch = pycamunda.batch.Delete(url=engine_url, id_='anId')\n>       result = delete_batch()\n\ntests\\batch\\test_delete.py:53: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:273: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/batch/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAA30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9AC0E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9AC130>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_get.py::test_get_path",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_get_path",
        "test_get.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_get.py::test_get_calls_requests",
      "lineno": 24,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2543 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_get.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 207,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/batch/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9ADF80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9ADDA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2543 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200230937840'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n        get_batch = pycamunda.batch.Get(url=engine_url, id_='anId')\n>       get_batch()\n\ntests\\batch\\test_get.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:207: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/batch/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9ADF80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9ADDA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2543 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 33,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_get.py::test_get_raises_for_status",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_get.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 207,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/batch/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9AE7A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9AE7F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231113504'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.batch.Batch', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_batch = pycamunda.batch.Get(url=engine_url, id_='anId')\n>       get_batch()\n\ntests\\batch\\test_get.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:207: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/batch/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9AE7A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9AE7F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_get.py::test_get_returns_batch",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_batch",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_get.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 207,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/batch/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9AF740>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9AF790>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_get_returns_batch(engine_url):\n        get_batch = pycamunda.batch.Get(url=engine_url, id_='anId')\n>       batch = get_batch()\n\ntests\\batch\\test_get.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:207: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/batch/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9AF740>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9AF790>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_getlist.py::test_getlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2220 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_getlist.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 147,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/batch')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD64950>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD649A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2220 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200230936208'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_batches = pycamunda.batch.GetList(url=engine_url)\n>       get_batches()\n\ntests\\batch\\test_getlist.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:147: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/batch')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD64950>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD649A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2220 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_getlist.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 147,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/batch')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD65BC0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD65DF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200234702560'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.batch.Batch', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_batches = pycamunda.batch.GetList(url=engine_url)\n>       get_batches()\n\ntests\\batch\\test_getlist.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:147: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/batch')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD65BC0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD65DF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_getlist.py::test_getlist_returns_batches",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_batches",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_getlist.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 147,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/batch')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD66750>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD66CF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getlist_returns_batches(engine_url):\n        get_batches = pycamunda.batch.GetList(url=engine_url)\n>       batches = get_batches()\n\ntests\\batch\\test_getlist.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:147: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/batch')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD66750>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD66CF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_getstats.py::test_getstats_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getstats_params",
        "test_getstats.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_getstats.py::test_getstats_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getstats_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getstats.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_getstats.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 331,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetStats(url='http://localhost/engine-rest/batch/statistics')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD67100>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD67BF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200200219088'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getstats_calls_requests(mock, engine_url):\n        get_batch_stats = pycamunda.batch.GetStats(url=engine_url)\n>       get_batch_stats()\n\ntests\\batch\\test_getstats.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:331: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetStats(url='http://localhost/engine-rest/batch/statistics')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD67100>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD67BF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_getstats.py::test_getstats_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_getstats_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getstats.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_getstats.py::test_getstats_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_getstats_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getstats.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2271 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_getstats.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 331,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetStats(url='http://localhost/engine-rest/batch/statistics')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDF49A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDF4AE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2271 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200234711776'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.batch.BatchStats', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getstats_raises_for_status(mock, engine_url):\n        get_batch_stats = pycamunda.batch.GetStats(url=engine_url)\n>       get_batch_stats()\n\ntests\\batch\\test_getstats.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:331: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetStats(url='http://localhost/engine-rest/batch/statistics')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDF49A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDF4AE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2271 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_getstats.py::test_getstats_returns_batchstats",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_getstats_returns_batchstats",
        "__wrapped__",
        "patchings",
        "test_getstats.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\batch\\test_getstats.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\batch.py",
            "lineno": 331,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetStats(url='http://localhost/engine-rest/batch/statistics')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDF4FE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDF4F90>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getstats_returns_batchstats(engine_url):\n        get_batch_stats = pycamunda.batch.GetStats(url=engine_url)\n>       batch_stats = get_batch_stats()\n\ntests\\batch\\test_getstats.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\batch.py:331: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetStats(url='http://localhost/engine-rest/batch/statistics')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDF4FE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDF4F90>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/batch/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "batch",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_casedefinition.py::test_case_definition_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_case_definition_load",
        "test_casedefinition.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_casedefinition.py::test_case_definition_load_raises_keyerror",
      "lineno": 21,
      "outcome": "passed",
      "keywords": [
        "test_case_definition_load_raises_keyerror",
        "test_casedefinition.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_count.py::test_count_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_count_params",
        "test_count.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_count.py::test_count_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_count_calls_requests",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_count.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 255,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/case-definition/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAA30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDF7330>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDF7380>\nquery_string = 'caseDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200234788176'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_count_calls_requests(mock, engine_url):\n        count_definitions = pycamunda.casedef.Count(url=engine_url, id_='anId')\n>       count_definitions()\n\ntests\\casedef\\test_count.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:255: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/case-definition/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAA30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDF7330>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDF7380>\nquery_string = 'caseDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_count.py::test_count_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_count_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_count.py::test_count_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_count_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_count.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 255,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/case-definition/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD93A60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD920C0>\nquery_string = 'caseDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200234710672'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_count_raises_for_status(mock, engine_url):\n        count_definitions = pycamunda.casedef.Count(url=engine_url, id_='anId')\n>       count_definitions()\n\ntests\\casedef\\test_count.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:255: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/case-definition/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD93A60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD920C0>\nquery_string = 'caseDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_count.py::test_count_returns_response_content",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_count_returns_response_content",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_count.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 255,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/case-definition/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD931F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD931A0>\nquery_string = 'caseDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', count_response_mock)\n    def test_count_returns_response_content(engine_url):\n        count_definitions = pycamunda.casedef.Count(url=engine_url, id_='anId')\n>       result = count_definitions()\n\ntests\\casedef\\test_count.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:255: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/case-definition/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD931F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD931A0>\nquery_string = 'caseDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_createinstance.py::test_createinstance_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_createinstance_params",
        "test_createinstance.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_createinstance.py::test_createinstance_path",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_createinstance_path",
        "test_createinstance.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_createinstance.py::test_createinstance_calls_requests",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_createinstance_calls_requests",
        "__wrapped__",
        "patchings",
        "test_createinstance.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2265 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_createinstance.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 429,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CreateInstance(url='http://localhost/engine-rest/case-definition/anId/create', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD98680>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD98720>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2265 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200234795424'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_createinstance_calls_requests(mock, engine_url):\n        create_instance = pycamunda.casedef.CreateInstance(url=engine_url, id_='anId')\n>       create_instance()\n\ntests\\casedef\\test_createinstance.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:429: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CreateInstance(url='http://localhost/engine-rest/case-definition/anId/create', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD98680>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD98720>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2265 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_createinstance.py::test_createinstance_raises_pycamunda_exception",
      "lineno": 53,
      "outcome": "passed",
      "keywords": [
        "test_createinstance_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_createinstance.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_createinstance.py::test_createinstance_raises_for_status",
      "lineno": 60,
      "outcome": "failed",
      "keywords": [
        "test_createinstance_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_createinstance.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2218 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_createinstance.py",
            "lineno": 66,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 429,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CreateInstance(url='http://localhost/engine-rest/case-definition/anId/create', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD99580>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD9B560>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2218 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200234361280'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.caseinst.CaseInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_createinstance_raises_for_status(mock, engine_url):\n        create_instance = pycamunda.casedef.CreateInstance(url=engine_url, id_='anId')\n>       create_instance()\n\ntests\\casedef\\test_createinstance.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:429: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CreateInstance(url='http://localhost/engine-rest/case-definition/anId/create', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD99580>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD9B560>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2218 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_createinstance.py::test_createinstance_returns_caseinstance",
      "lineno": 70,
      "outcome": "failed",
      "keywords": [
        "test_createinstance_returns_caseinstance",
        "__wrapped__",
        "patchings",
        "test_createinstance.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_createinstance.py",
            "lineno": 74,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 429,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CreateInstance(url='http://localhost/engine-rest/case-definition/anId/create', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B968220>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B968040>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_createinstance_returns_caseinstance(engine_url):\n        create_instance = pycamunda.casedef.CreateInstance(url=engine_url, id_='anId')\n>       instance = create_instance()\n\ntests\\casedef\\test_createinstance.py:74: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:429: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CreateInstance(url='http://localhost/engine-rest/case-definition/anId/create', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B968220>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B968040>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_get.py::test_get_path",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_get_path",
        "test_get.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_get.py::test_get_calls_requests",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2262 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_get.py",
            "lineno": 32,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 282,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/case-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B851120>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B8513F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2262 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200212950800'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n        get_definition = pycamunda.casedef.Get(url=engine_url, id_='anId')\n>       get_definition()\n\ntests\\casedef\\test_get.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:282: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/case-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B851120>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B8513F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2262 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 37,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_get.py::test_get_raises_for_status",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_get.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 282,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/case-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD9A840>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD9A250>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200211961712'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.casedef.CaseDefinition', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_definition = pycamunda.casedef.Get(url=engine_url, id_='anId')\n>       get_definition()\n\ntests\\casedef\\test_get.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:282: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/case-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD9A840>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD9A250>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_get.py::test_get_returns_casedefinition",
      "lineno": 54,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_casedefinition",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_get.py",
            "lineno": 58,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 282,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/case-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAA30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD9AED0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD9AD40>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_get_returns_casedefinition(engine_url):\n        get_definition = pycamunda.casedef.Get(url=engine_url, id_='anId')\n>       case_definition = get_definition()\n\ntests\\casedef\\test_get.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:282: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/case-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAA30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD9AED0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD9AD40>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getdiagram.py::test_getdiagram_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getdiagram_params",
        "test_getdiagram.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getdiagram.py::test_getdiagram_path",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_getdiagram_path",
        "test_getdiagram.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getdiagram.py::test_getdiagram_calls_requests",
      "lineno": 31,
      "outcome": "failed",
      "keywords": [
        "test_getdiagram_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getdiagram.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2281 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_getdiagram.py",
            "lineno": 35,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 339,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetDiagram(url='http://localhost/engine-rest/case-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B969080>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B968040>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2281 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200199771056'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getdiagram_calls_requests(mock, engine_url):\n        get_diagram = pycamunda.casedef.GetDiagram(url=engine_url, id_='anId')\n>       get_diagram()\n\ntests\\casedef\\test_getdiagram.py:35: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:339: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetDiagram(url='http://localhost/engine-rest/case-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91B969080>\nheaders_buffer = <_io.BytesIO object at 0x000002E91B968040>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2281 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getdiagram.py::test_getdiagram_raises_pycamunda_exception",
      "lineno": 40,
      "outcome": "passed",
      "keywords": [
        "test_getdiagram_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getdiagram.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getdiagram.py::test_getdiagram_raises_for_status",
      "lineno": 47,
      "outcome": "failed",
      "keywords": [
        "test_getdiagram_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getdiagram.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2262 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_getdiagram.py",
            "lineno": 52,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 339,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetDiagram(url='http://localhost/engine-rest/case-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDFCFE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDFEA70>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2262 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212952720'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getdiagram_raises_for_status(mock, engine_url):\n        get_diagram = pycamunda.casedef.GetDiagram(url=engine_url, id_='anId')\n>       get_diagram()\n\ntests\\casedef\\test_getdiagram.py:52: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:339: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetDiagram(url='http://localhost/engine-rest/case-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDFCFE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDFEA70>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2262 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getdiagram.py::test_getdiagram_returns_response_content",
      "lineno": 56,
      "outcome": "failed",
      "keywords": [
        "test_getdiagram_returns_response_content",
        "__wrapped__",
        "patchings",
        "test_getdiagram.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2226 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_getdiagram.py",
            "lineno": 60,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 339,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetDiagram(url='http://localhost/engine-rest/case-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDFC590>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDFD080>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2226 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', response_mock)\n    def test_getdiagram_returns_response_content(engine_url):\n        get_diagram = pycamunda.casedef.GetDiagram(url=engine_url, id_='anId')\n>       result = get_diagram()\n\ntests\\casedef\\test_getdiagram.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:339: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetDiagram(url='http://localhost/engine-rest/case-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDFC590>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDFD080>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2226 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getlist.py::test_getlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_getlist.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 167,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/case-definition', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDFE110>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDFF290>\nquery_string = 'caseDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200213196320'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_definitions = pycamunda.casedef.GetList(url=engine_url, id_='anId')\n>       get_definitions()\n\ntests\\casedef\\test_getlist.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:167: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/case-definition', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDFE110>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDFF290>\nquery_string = 'caseDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_getlist.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 167,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/case-definition', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDCDE90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDCC630>\nquery_string = 'caseDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212677168'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.casedef.CaseDefinition', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_definitions = pycamunda.casedef.GetList(url=engine_url, id_='anId')\n>       get_definitions()\n\ntests\\casedef\\test_getlist.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:167: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/case-definition', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDCDE90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDCC630>\nquery_string = 'caseDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getlist.py::test_getlist_returns_response_content",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_response_content",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_getlist.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 167,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/case-definition', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDCC130>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDCC1D0>\nquery_string = 'caseDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getlist_returns_response_content(engine_url):\n        get_definitions = pycamunda.casedef.GetList(url=engine_url, id_='anId')\n>       definitions = get_definitions()\n\ntests\\casedef\\test_getlist.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:167: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/case-definition', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDCC130>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDCC1D0>\nquery_string = 'caseDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getxml.py::test_getxml_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getxml_params",
        "test_getxml.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getxml.py::test_getxml_path",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_getxml_path",
        "test_getxml.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getxml.py::test_getxml_calls_requests",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_getxml_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getxml.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2438 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_getxml.py",
            "lineno": 32,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 314,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetXML(url='http://localhost/engine-rest/case-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDCE1B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDCE200>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2438 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200212797008'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getxml_calls_requests(mock, engine_url):\n        get_xml = pycamunda.casedef.GetXML(url=engine_url, id_='anId')\n>       get_xml()\n\ntests\\casedef\\test_getxml.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:314: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetXML(url='http://localhost/engine-rest/case-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDCE1B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDCE200>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2438 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getxml.py::test_getxml_raises_pycamunda_exception",
      "lineno": 37,
      "outcome": "passed",
      "keywords": [
        "test_getxml_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getxml.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getxml.py::test_getxml_raises_for_status",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_getxml_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getxml.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_getxml.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 314,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetXML(url='http://localhost/engine-rest/case-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDCE610>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDCF600>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212802624'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getxml_raises_for_status(mock, engine_url):\n        get_xml = pycamunda.casedef.GetXML(url=engine_url, id_='anId')\n>       get_xml()\n\ntests\\casedef\\test_getxml.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:314: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetXML(url='http://localhost/engine-rest/case-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDCE610>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDCF600>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_getxml.py::test_getxml_returns_str",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_getxml_returns_str",
        "__wrapped__",
        "patchings",
        "test_getxml.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_getxml.py",
            "lineno": 57,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 314,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetXML(url='http://localhost/engine-rest/case-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDCFD80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDCFBA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', response_mock)\n    def test_getxml_returns_str(engine_url):\n        get_xml = pycamunda.casedef.GetXML(url=engine_url, id_='anId')\n>       case_definition_xml = get_xml()\n\ntests\\casedef\\test_getxml.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:314: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetXML(url='http://localhost/engine-rest/case-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDCFD80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDCFBA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_updatehistorytimetolive_params",
        "test_updatehistorytimetolive.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_path",
      "lineno": 21,
      "outcome": "passed",
      "keywords": [
        "test_updatehistorytimetolive_path",
        "test_updatehistorytimetolive.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_calls_requests",
      "lineno": 39,
      "outcome": "failed",
      "keywords": [
        "test_updatehistorytimetolive_calls_requests",
        "__wrapped__",
        "patchings",
        "test_updatehistorytimetolive.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_updatehistorytimetolive.py",
            "lineno": 45,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 379,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UpdateHistoryTimeToLive(url='http://localhost/engine-rest/case-definition/anId/history-time-to-live', id_='anId', history_time_to_live=10)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE29080>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE29170>\nbody = '{\"historyTimeToLive\": 10}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200212803104'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_updatehistorytimetolive_calls_requests(mock, engine_url):\n        update_definition = pycamunda.casedef.UpdateHistoryTimeToLive(\n            url=engine_url, id_='anId', history_time_to_live=10\n        )\n>       update_definition()\n\ntests\\casedef\\test_updatehistorytimetolive.py:45: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:379: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UpdateHistoryTimeToLive(url='http://localhost/engine-rest/case-definition/anId/history-time-to-live', id_='anId', history_time_to_live=10)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE29080>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE29170>\nbody = '{\"historyTimeToLive\": 10}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_raises_pycamunda_exception",
      "lineno": 50,
      "outcome": "passed",
      "keywords": [
        "test_updatehistorytimetolive_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_updatehistorytimetolive.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_raises_for_status",
      "lineno": 59,
      "outcome": "failed",
      "keywords": [
        "test_updatehistorytimetolive_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_updatehistorytimetolive.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_updatehistorytimetolive.py",
            "lineno": 66,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 379,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UpdateHistoryTimeToLive(url='http://localhost/engine-rest/case-definition/anId/history-time-to-live', id_='anId', history_time_to_live=10)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE29B70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE2A660>\nbody = '{\"historyTimeToLive\": 10}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212665600'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_updatehistorytimetolive_raises_for_status(mock, engine_url):\n        update_definition = pycamunda.casedef.UpdateHistoryTimeToLive(\n            url=engine_url, id_='anId', history_time_to_live=10\n        )\n>       update_definition()\n\ntests\\casedef\\test_updatehistorytimetolive.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:379: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UpdateHistoryTimeToLive(url='http://localhost/engine-rest/case-definition/anId/history-time-to-live', id_='anId', history_time_to_live=10)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE29B70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE2A660>\nbody = '{\"historyTimeToLive\": 10}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/casedef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_returns_none",
      "lineno": 70,
      "outcome": "failed",
      "keywords": [
        "test_updatehistorytimetolive_returns_none",
        "__wrapped__",
        "patchings",
        "test_updatehistorytimetolive.py",
        "casedef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\casedef\\test_updatehistorytimetolive.py",
            "lineno": 76,
            "message": ""
          },
          {
            "path": "pycamunda\\casedef.py",
            "lineno": 379,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UpdateHistoryTimeToLive(url='http://localhost/engine-rest/case-definition/anId/history-time-to-live', id_='anId', history_time_to_live=10)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE2B740>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE2B1A0>\nbody = '{\"historyTimeToLive\": 10}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', response_mock)\n    def test_updatehistorytimetolive_returns_none(engine_url):\n        update_definition = pycamunda.casedef.UpdateHistoryTimeToLive(\n            url=engine_url, id_='anId', history_time_to_live=10\n        )\n>       result = update_definition()\n\ntests\\casedef\\test_updatehistorytimetolive.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\casedef.py:379: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UpdateHistoryTimeToLive(url='http://localhost/engine-rest/case-definition/anId/history-time-to-live', id_='anId', history_time_to_live=10)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE2B740>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE2B1A0>\nbody = '{\"historyTimeToLive\": 10}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_caseinstance.py::test_caseinstance_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_caseinstance_load",
        "test_caseinstance.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_caseinstance.py::test_caseinstance_load_raises_keyerror",
      "lineno": 17,
      "outcome": "passed",
      "keywords": [
        "test_caseinstance_load_raises_keyerror",
        "test_caseinstance.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_close.py::test_close_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_close_params",
        "test_close.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_close.py::test_close_calls_requests",
      "lineno": 26,
      "outcome": "failed",
      "keywords": [
        "test_close_calls_requests",
        "__wrapped__",
        "patchings",
        "test_close.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_close.py",
            "lineno": 30,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 399,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Close(url='http://localhost/engine-rest/case-instance/anId/close', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE3D030>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE3CFE0>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200234797104'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_close_calls_requests(mock, engine_url):\n        close_instance = pycamunda.caseinst.Close(url=engine_url, id_='anId')\n>       close_instance()\n\ntests\\caseinst\\test_close.py:30: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:399: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Close(url='http://localhost/engine-rest/case-instance/anId/close', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE3D030>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE3CFE0>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_close.py::test_close_raises_pycamunda_exception",
      "lineno": 35,
      "outcome": "passed",
      "keywords": [
        "test_close_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_close.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_close.py::test_close_raises_for_status",
      "lineno": 42,
      "outcome": "failed",
      "keywords": [
        "test_close_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_close.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2268 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_close.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 399,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Close(url='http://localhost/engine-rest/case-instance/anId/close', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE3E480>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE3F060>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2268 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212670160'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_close_raises_for_status(mock, engine_url):\n        close_instance = pycamunda.caseinst.Close(url=engine_url, id_='anId')\n>       close_instance()\n\ntests\\caseinst\\test_close.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:399: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Close(url='http://localhost/engine-rest/case-instance/anId/close', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE3E480>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE3F060>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2268 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_close.py::test_close_returns_none",
      "lineno": 51,
      "outcome": "failed",
      "keywords": [
        "test_close_returns_none",
        "__wrapped__",
        "patchings",
        "test_close.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_close.py",
            "lineno": 55,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 399,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Close(url='http://localhost/engine-rest/case-instance/anId/close', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE3F330>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE3F600>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_close_returns_none(engine_url):\n        close_instance = pycamunda.caseinst.Close(url=engine_url, id_='anId')\n>       result = close_instance()\n\ntests\\caseinst\\test_close.py:55: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:399: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Close(url='http://localhost/engine-rest/case-instance/anId/close', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE3F330>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE3F600>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_complete.py::test_complete_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_complete_params",
        "test_complete.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_complete.py::test_complete_calls_requests",
      "lineno": 26,
      "outcome": "failed",
      "keywords": [
        "test_complete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_complete.py",
            "lineno": 30,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 374,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Complete(url='http://localhost/engine-rest/case-instance/anId/complete', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD58450>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD59440>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231012544'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_complete_calls_requests(mock, engine_url):\n        complete_instance = pycamunda.caseinst.Complete(url=engine_url, id_='anId')\n>       complete_instance()\n\ntests\\caseinst\\test_complete.py:30: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:374: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Complete(url='http://localhost/engine-rest/case-instance/anId/complete', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD58450>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD59440>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_complete.py::test_complete_raises_pycamunda_exception",
      "lineno": 35,
      "outcome": "passed",
      "keywords": [
        "test_complete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_complete.py::test_complete_raises_for_status",
      "lineno": 42,
      "outcome": "failed",
      "keywords": [
        "test_complete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_complete.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 374,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Complete(url='http://localhost/engine-rest/case-instance/anId/complete', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD5AA20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD59B20>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231116768'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_complete_raises_for_status(mock, engine_url):\n        complete_instance = pycamunda.caseinst.Complete(url=engine_url, id_='anId')\n>       complete_instance()\n\ntests\\caseinst\\test_complete.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:374: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Complete(url='http://localhost/engine-rest/case-instance/anId/complete', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD5AA20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD59B20>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_complete.py::test_complete_returns_none",
      "lineno": 51,
      "outcome": "failed",
      "keywords": [
        "test_complete_returns_none",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_complete.py",
            "lineno": 55,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 374,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Complete(url='http://localhost/engine-rest/case-instance/anId/complete', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD5BA60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD5B510>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_complete_returns_none(engine_url):\n        complete_instance = pycamunda.caseinst.Complete(url=engine_url, id_='anId')\n>       result = complete_instance()\n\ntests\\caseinst\\test_complete.py:55: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:374: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Complete(url='http://localhost/engine-rest/case-instance/anId/complete', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD5BA60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD5B510>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_count.py::test_count_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_count_params",
        "test_count.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_count.py::test_count_variable_params",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_count_variable_params",
        "test_count.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_count.py::test_count_calls_requests",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_count_calls_requests",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2461 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_count.py",
            "lineno": 32,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 268,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/case-instance/count', variables={})\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCAC9F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCACA40>\nquery_string = 'variables={}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2461 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200212680480'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_count_calls_requests(mock, engine_url):\n        count_instances = pycamunda.caseinst.Count(url=engine_url)\n>       count_instances()\n\ntests\\caseinst\\test_count.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:268: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/case-instance/count', variables={})\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCAC9F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCACA40>\nquery_string = 'variables={}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2461 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_count.py::test_count_raises_pycamunda_exception",
      "lineno": 37,
      "outcome": "passed",
      "keywords": [
        "test_count_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_count.py::test_count_raises_for_status",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_count_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2270 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_count.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 268,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/case-instance/count', variables={})\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCACE50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCADCB0>\nquery_string = 'variables={}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2270 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200230943408'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.caseinst.CaseInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_count_raises_for_status(mock, engine_url):\n        count_instances = pycamunda.caseinst.Count(url=engine_url)\n>       count_instances()\n\ntests\\caseinst\\test_count.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:268: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/case-instance/count', variables={})\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCACE50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCADCB0>\nquery_string = 'variables={}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2270 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_count.py::test_count_returns_int",
      "lineno": 54,
      "outcome": "failed",
      "keywords": [
        "test_count_returns_int",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_count.py",
            "lineno": 58,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 268,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/case-instance/count', variables={})\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD2B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCAE200>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCAE110>\nquery_string = 'variables={}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', count_response_mock)\n    def test_count_returns_int(engine_url):\n        count_instances = pycamunda.caseinst.Count(url=engine_url)\n>       result = count_instances()\n\ntests\\caseinst\\test_count.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:268: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/case-instance/count', variables={})\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD2B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCAE200>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCAE110>\nquery_string = 'variables={}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_get.py::test_get_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2359 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_get.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 312,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/case-instance/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCAFD30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCAE160>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2359 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200212887712'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n        get_instance = pycamunda.caseinst.Get(url=engine_url, id_='anId')\n>       get_instance()\n\ntests\\caseinst\\test_get.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:312: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/case-instance/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCAFD30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCAE160>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2359 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_get.py::test_get_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_get.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 312,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/case-instance/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCA44A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCA4BD0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212801328'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.caseinst.CaseInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_instance = pycamunda.caseinst.Get(url=engine_url, id_='anId')\n>       get_instance()\n\ntests\\caseinst\\test_get.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:312: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/case-instance/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCA44A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCA4BD0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_get.py::test_get_returns_casedefinition",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_casedefinition",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_get.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 312,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/case-instance/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCA4E00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCA4D60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_get_returns_casedefinition(engine_url):\n        get_instance = pycamunda.caseinst.Get(url=engine_url, id_='anId')\n>       case_instance = get_instance()\n\ntests\\caseinst\\test_get.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:312: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/case-instance/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCA4E00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCA4D60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_getlist.py::test_getlist_variable_params",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_getlist_variable_params",
        "test_getlist.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_getlist.py::test_getlist_calls_requests",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_getlist.py",
            "lineno": 32,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 169,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/case-instance', variables={})\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCA6ED0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCA6F20>\nquery_string = 'variables={}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200234713840'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_instances = pycamunda.caseinst.GetList(url=engine_url)\n>       get_instances()\n\ntests\\caseinst\\test_getlist.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:169: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/case-instance', variables={})\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCA6ED0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCA6F20>\nquery_string = 'variables={}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 37,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2353 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_getlist.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 169,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/case-instance', variables={})\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD28180>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD28270>\nquery_string = 'variables={}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2353 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200234371456'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.caseinst.CaseInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_instances = pycamunda.caseinst.GetList(url=engine_url)\n>       get_instances()\n\ntests\\caseinst\\test_getlist.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:169: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/case-instance', variables={})\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD28180>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD28270>\nquery_string = 'variables={}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2353 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_getlist.py::test_getlist_returns_case_instances",
      "lineno": 54,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_case_instances",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2556 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_getlist.py",
            "lineno": 58,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 169,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/case-instance', variables={})\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD285E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD287C0>\nquery_string = 'variables={}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2556 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getlist_returns_case_instances(engine_url):\n        get_instances = pycamunda.caseinst.GetList(url=engine_url)\n>       instances = get_instances()\n\ntests\\caseinst\\test_getlist.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:169: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/case-instance', variables={})\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD285E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD287C0>\nquery_string = 'variables={}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2556 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_terminate.py::test_terminate_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_terminate_params",
        "test_terminate.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_terminate.py::test_terminate_calls_requests",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_terminate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_terminate.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_terminate.py",
            "lineno": 32,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 424,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Terminate(url='http://localhost/engine-rest/case-instance/anId/terminate', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD29C60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD29D00>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231115184'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_terminate_calls_requests(mock, engine_url):\n        terminate_instance = pycamunda.caseinst.Terminate(url=engine_url, id_='anId')\n>       terminate_instance()\n\ntests\\caseinst\\test_terminate.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:424: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Terminate(url='http://localhost/engine-rest/case-instance/anId/terminate', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD29C60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD29D00>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_terminate.py::test_terminate_raises_pycamunda_exception",
      "lineno": 37,
      "outcome": "passed",
      "keywords": [
        "test_terminate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_terminate.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_terminate.py::test_terminate_raises_for_status",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_terminate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_terminate.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2269 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_terminate.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 424,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Terminate(url='http://localhost/engine-rest/case-instance/anId/terminate', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD2B290>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD2A480>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2269 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212667184'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_terminate_raises_for_status(mock, engine_url):\n        terminate_instance = pycamunda.caseinst.Terminate(url=engine_url, id_='anId')\n>       terminate_instance()\n\ntests\\caseinst\\test_terminate.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:424: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Terminate(url='http://localhost/engine-rest/case-instance/anId/terminate', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD2B290>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD2A480>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2269 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/caseinst/test_terminate.py::test_terminate_returns_none",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_terminate_returns_none",
        "__wrapped__",
        "patchings",
        "test_terminate.py",
        "caseinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2494 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\caseinst\\test_terminate.py",
            "lineno": 57,
            "message": ""
          },
          {
            "path": "pycamunda\\caseinst.py",
            "lineno": 424,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Terminate(url='http://localhost/engine-rest/case-instance/anId/terminate', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD2B4C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD2B7E0>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2494 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_terminate_returns_none(engine_url):\n        terminate_instance = pycamunda.caseinst.Terminate(url=engine_url, id_='anId')\n>       result = terminate_instance()\n\ntests\\caseinst\\test_terminate.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\caseinst.py:424: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Terminate(url='http://localhost/engine-rest/case-instance/anId/terminate', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD2B4C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD2B7E0>\nbody = '{\"variables\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2494 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/condition/test_correlate.py::test_evaluate_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_evaluate_params",
        "test_correlate.py",
        "condition",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/condition/test_correlate.py::test_evaluate_method_params",
      "lineno": 19,
      "outcome": "passed",
      "keywords": [
        "test_evaluate_method_params",
        "test_correlate.py",
        "condition",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/condition/test_correlate.py::test_evaluate_calls_requests",
      "lineno": 27,
      "outcome": "failed",
      "keywords": [
        "test_evaluate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_correlate.py",
        "condition",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2438 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\condition\\test_correlate.py",
            "lineno": 32,
            "message": ""
          },
          {
            "path": "pycamunda\\condition.py",
            "lineno": 68,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Evaluate(url='http://localhost/engine-rest/condition', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCFD210>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCFD260>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2438 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200230939520'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.processinst.ProcessInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_evaluate_calls_requests(mock, engine_url):\n        evaluate = pycamunda.condition.Evaluate(url=engine_url)\n>       evaluate()\n\ntests\\condition\\test_correlate.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\condition.py:68: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Evaluate(url='http://localhost/engine-rest/condition', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCFD210>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCFD260>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2438 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/condition/test_correlate.py::test_evaluate_raises_pycamunda_exception",
      "lineno": 37,
      "outcome": "passed",
      "keywords": [
        "test_evaluate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_correlate.py",
        "condition",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/condition/test_correlate.py::test_correlatesingle_raises_for_status",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_correlatesingle_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_correlate.py",
        "condition",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2593 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\condition\\test_correlate.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\condition.py",
            "lineno": 68,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Evaluate(url='http://localhost/engine-rest/condition', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCFD7B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCFDCB0>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2593 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200234369536'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.processinst.ProcessInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_correlatesingle_raises_for_status(mock, engine_url):\n        evaluate = pycamunda.condition.Evaluate(url=engine_url)\n>       evaluate()\n\ntests\\condition\\test_correlate.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\condition.py:68: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Evaluate(url='http://localhost/engine-rest/condition', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCFD7B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCFDCB0>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2593 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/condition/test_correlate.py::test_evaluate_returns_processinstance",
      "lineno": 54,
      "outcome": "failed",
      "keywords": [
        "test_evaluate_returns_processinstance",
        "__wrapped__",
        "patchings",
        "test_correlate.py",
        "condition",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2647 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\condition\\test_correlate.py",
            "lineno": 58,
            "message": ""
          },
          {
            "path": "pycamunda\\condition.py",
            "lineno": 68,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Evaluate(url='http://localhost/engine-rest/condition', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCFEE30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCFFA60>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2647 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_evaluate_returns_processinstance(engine_url):\n        evaluate = pycamunda.condition.Evaluate(url=engine_url)\n>       results = evaluate()\n\ntests\\condition\\test_correlate.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\condition.py:68: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Evaluate(url='http://localhost/engine-rest/condition', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CCFEE30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CCFFA60>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2647 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/condition/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "condition",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_count.py::test_count_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_count_params",
        "test_count.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_count.py::test_count_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_count_calls_requests",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2515 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_count.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 264,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/decision-definition/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD3CE50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD3CEF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2515 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200233293248'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_count_calls_requests(mock, engine_url):\n        count_definitions = pycamunda.decisiondef.Count(url=engine_url)\n>       count_definitions()\n\ntests\\decisiondef\\test_count.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:264: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/decision-definition/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD3CE50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD3CEF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2515 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_count.py::test_count_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_count_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_count.py::test_count_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_count_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2273 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_count.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 264,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/decision-definition/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD1C090>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD1C180>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2273 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200233302272'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_count_raises_for_status(mock, engine_url):\n        count_definitions = pycamunda.decisiondef.Count(url=engine_url)\n>       count_definitions()\n\ntests\\decisiondef\\test_count.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:264: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/decision-definition/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD1C090>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD1C180>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2273 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_count.py::test_count_returns_response_content",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_count_returns_response_content",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2226 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_count.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 264,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/decision-definition/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD1C3B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD1C6D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2226 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', count_response_mock)\n    def test_count_returns_response_content(engine_url):\n        count_definitions = pycamunda.decisiondef.Count(url=engine_url)\n>       result = count_definitions()\n\ntests\\decisiondef\\test_count.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:264: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/decision-definition/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD1C3B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD1C6D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2226 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_decisiondefinition.py::test_decision_definition_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_decision_definition_load",
        "test_decisiondefinition.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_decisiondefinition.py::test_decision_definition_load_raises_keyerror",
      "lineno": 30,
      "outcome": "passed",
      "keywords": [
        "test_decision_definition_load_raises_keyerror",
        "test_decisiondefinition.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_evaluate.py::test_evaluate_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_evaluate_params",
        "test_evaluate.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_evaluate.py::test_evaluate_path",
      "lineno": 22,
      "outcome": "passed",
      "keywords": [
        "test_evaluate_path",
        "test_evaluate.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_evaluate.py::test_evaluate_calls_requests",
      "lineno": 39,
      "outcome": "failed",
      "keywords": [
        "test_evaluate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_evaluate.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2545 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_evaluate.py",
            "lineno": 43,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 390,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Evaluate(url='http://localhost/engine-rest/decision-definition/anId/evaluate', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD1E020>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD1E070>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2545 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200234370976'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_evaluate_calls_requests(mock, engine_url):\n        evaluate = pycamunda.decisiondef.Evaluate(url=engine_url, id_='anId')\n>       evaluate()\n\ntests\\decisiondef\\test_evaluate.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:390: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Evaluate(url='http://localhost/engine-rest/decision-definition/anId/evaluate', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD1E020>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD1E070>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2545 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_evaluate.py::test_evaluate_raises_pycamunda_exception",
      "lineno": 48,
      "outcome": "passed",
      "keywords": [
        "test_evaluate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_evaluate.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_evaluate.py::test_evaluate_raises_for_status",
      "lineno": 55,
      "outcome": "failed",
      "keywords": [
        "test_evaluate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_evaluate.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_evaluate.py",
            "lineno": 61,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 390,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Evaluate(url='http://localhost/engine-rest/decision-definition/anId/evaluate', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD1F7E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD1EAC0>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200212667040'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_evaluate_raises_for_status(mock, engine_url):\n        evaluate = pycamunda.decisiondef.Evaluate(url=engine_url, id_='anId')\n        try:\n>           evaluate()\n\ntests\\decisiondef\\test_evaluate.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:390: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Evaluate(url='http://localhost/engine-rest/decision-definition/anId/evaluate', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD1F7E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD1EAC0>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_evaluate.py::test_evaluate_returns_tuple",
      "lineno": 67,
      "outcome": "failed",
      "keywords": [
        "test_evaluate_returns_tuple",
        "__wrapped__",
        "patchings",
        "test_evaluate.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2424 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_evaluate.py",
            "lineno": 71,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 390,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Evaluate(url='http://localhost/engine-rest/decision-definition/anId/evaluate', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD1FEC0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD1FD80>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2424 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_evaluate_returns_tuple(engine_url):\n        evaluate = pycamunda.decisiondef.Evaluate(url=engine_url, id_='anId')\n>       result = evaluate()\n\ntests\\decisiondef\\test_evaluate.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:390: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Evaluate(url='http://localhost/engine-rest/decision-definition/anId/evaluate', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DAC70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CD1FEC0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CD1FD80>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2424 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_get.py::test_get_path",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_get_path",
        "test_get.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_get.py::test_get_calls_requests",
      "lineno": 32,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_get.py",
            "lineno": 36,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 291,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/decision-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CC652B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CC65170>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200212883968'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n        get_definition = pycamunda.decisiondef.Get(url=engine_url, id_='anId')\n>       get_definition()\n\ntests\\decisiondef\\test_get.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:291: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/decision-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CC652B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CC65170>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 41,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_get.py::test_get_raises_for_status",
      "lineno": 48,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_get.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 291,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/decision-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CC654E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CC659E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200233295072'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.decisiondef.DecisionDefinition', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_definition = pycamunda.decisiondef.Get(url=engine_url, id_='anId')\n>       get_definition()\n\ntests\\decisiondef\\test_get.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:291: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/decision-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DD730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CC654E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CC659E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_get.py::test_get_returns_decisiondefinition",
      "lineno": 58,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_decisiondefinition",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2212 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_get.py",
            "lineno": 62,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 291,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/decision-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CC66DE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CC66D40>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2212 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_get_returns_decisiondefinition(engine_url):\n        get_definition = pycamunda.decisiondef.Get(url=engine_url, id_='anId')\n>       decision_definition = get_definition()\n\ntests\\decisiondef\\test_get.py:62: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:291: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/decision-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA5B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CC66DE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CC66D40>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2212 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getdiagram.py::test_getdiagram_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getdiagram_params",
        "test_getdiagram.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getdiagram.py::test_getdiagram_path",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_getdiagram_path",
        "test_getdiagram.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getdiagram.py::test_getdiagram_calls_requests",
      "lineno": 32,
      "outcome": "failed",
      "keywords": [
        "test_getdiagram_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getdiagram.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2562 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_getdiagram.py",
            "lineno": 36,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 348,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetDiagram(url='http://localhost/engine-rest/decision-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E919069440>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CBB0A90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CBB0AE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2562 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200233766160'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getdiagram_calls_requests(mock, engine_url):\n        get_diagram = pycamunda.decisiondef.GetDiagram(url=engine_url, id_='anId')\n>       get_diagram()\n\ntests\\decisiondef\\test_getdiagram.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:348: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetDiagram(url='http://localhost/engine-rest/decision-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E919069440>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CBB0A90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CBB0AE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2562 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getdiagram.py::test_getdiagram_raises_pycamunda_exception",
      "lineno": 41,
      "outcome": "passed",
      "keywords": [
        "test_getdiagram_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getdiagram.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getdiagram.py::test_getdiagram_raises_for_status",
      "lineno": 48,
      "outcome": "failed",
      "keywords": [
        "test_getdiagram_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getdiagram.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_getdiagram.py",
            "lineno": 53,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 348,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetDiagram(url='http://localhost/engine-rest/decision-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CBB0FE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CBB12B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200233766640'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getdiagram_raises_for_status(mock, engine_url):\n        get_diagram = pycamunda.decisiondef.GetDiagram(url=engine_url, id_='anId')\n>       get_diagram()\n\ntests\\decisiondef\\test_getdiagram.py:53: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:348: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetDiagram(url='http://localhost/engine-rest/decision-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DCE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CBB0FE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CBB12B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getdiagram.py::test_getdiagram_returns_response_content",
      "lineno": 57,
      "outcome": "failed",
      "keywords": [
        "test_getdiagram_returns_response_content",
        "__wrapped__",
        "patchings",
        "test_getdiagram.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_getdiagram.py",
            "lineno": 61,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 348,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetDiagram(url='http://localhost/engine-rest/decision-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDCFC40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDCFD80>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', response_mock)\n    def test_getdiagram_returns_response_content(engine_url):\n        get_diagram = pycamunda.decisiondef.GetDiagram(url=engine_url, id_='anId')\n>       result = get_diagram()\n\ntests\\decisiondef\\test_getdiagram.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:348: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetDiagram(url='http://localhost/engine-rest/decision-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CDCFC40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CDCFD80>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getlist.py::test_getlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_getlist.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 172,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/decision-definition')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CBB1DF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CBB2070>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200233302848'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_definitions = pycamunda.decisiondef.GetList(url=engine_url)\n>       get_definitions()\n\ntests\\decisiondef\\test_getlist.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:172: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/decision-definition')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CBB1DF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CBB2070>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_getlist.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 172,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/decision-definition')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CBB2890>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CBB36F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231006496'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.decisiondef.DecisionDefinition', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_definitions = pycamunda.decisiondef.GetList(url=engine_url)\n>       get_definitions()\n\ntests\\decisiondef\\test_getlist.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:172: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/decision-definition')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CBB2890>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CBB36F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getlist.py::test_getlist_returns_response_content",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_response_content",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_getlist.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 172,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/decision-definition')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CBB39C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CBB3CE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getlist_returns_response_content(engine_url):\n        get_definitions = pycamunda.decisiondef.GetList(url=engine_url)\n>       definitions = get_definitions()\n\ntests\\decisiondef\\test_getlist.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:172: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/decision-definition')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CBB39C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CBB3CE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getxml.py::test_getxml_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getxml_params",
        "test_getxml.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getxml.py::test_getxml_path",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_getxml_path",
        "test_getxml.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getxml.py::test_getxml_calls_requests",
      "lineno": 30,
      "outcome": "failed",
      "keywords": [
        "test_getxml_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getxml.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_getxml.py",
            "lineno": 34,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 323,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetXML(url='http://localhost/engine-rest/decision-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9CD3A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9CD440>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200212805168'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getxml_calls_requests(mock, engine_url):\n        get_xml = pycamunda.decisiondef.GetXML(url=engine_url, id_='anId')\n>       get_xml()\n\ntests\\decisiondef\\test_getxml.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:323: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetXML(url='http://localhost/engine-rest/decision-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DC9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9CD3A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9CD440>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getxml.py::test_getxml_raises_pycamunda_exception",
      "lineno": 39,
      "outcome": "passed",
      "keywords": [
        "test_getxml_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getxml.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getxml.py::test_getxml_raises_for_status",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_getxml_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getxml.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2567 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_getxml.py",
            "lineno": 51,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 323,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetXML(url='http://localhost/engine-rest/decision-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9CD760>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9CE1B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2567 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200233306208'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getxml_raises_for_status(mock, engine_url):\n        get_xml = pycamunda.decisiondef.GetXML(url=engine_url, id_='anId')\n>       get_xml()\n\ntests\\decisiondef\\test_getxml.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:323: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetXML(url='http://localhost/engine-rest/decision-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9CD760>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9CE1B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2567 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_getxml.py::test_getxml_returns_str",
      "lineno": 55,
      "outcome": "failed",
      "keywords": [
        "test_getxml_returns_str",
        "__wrapped__",
        "patchings",
        "test_getxml.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\decisiondef\\test_getxml.py",
            "lineno": 59,
            "message": ""
          },
          {
            "path": "pycamunda\\decisiondef.py",
            "lineno": 323,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetXML(url='http://localhost/engine-rest/decision-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9CEDE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9CECF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', response_mock)\n    def test_getxml_returns_str(engine_url):\n        get_xml = pycamunda.decisiondef.GetXML(url=engine_url, id_='anId')\n>       decision_definition_xml = get_xml()\n\ntests\\decisiondef\\test_getxml.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\decisiondef.py:323: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetXML(url='http://localhost/engine-rest/decision-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DB9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91C9CEDE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91C9CECF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisiondef/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "decisiondef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisionreqdef/test_decisionrequirementsdefinition.py::test_decision_requirements_definition_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_decision_requirements_definition_load",
        "test_decisionrequirementsdefinition.py",
        "decisionreqdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisionreqdef/test_decisionrequirementsdefinition.py::test_decision_requirements_definition_load_raises_keyerror",
      "lineno": 22,
      "outcome": "passed",
      "keywords": [
        "test_decision_requirements_definition_load_raises_keyerror",
        "test_decisionrequirementsdefinition.py",
        "decisionreqdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/decisionreqdef/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "decisionreqdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_create.py::test_create_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_create_params",
        "test_create.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_create.py::test_create_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_create_calls_requests",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\deployment.py",
          "lineno": 157,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2415 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_create.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\deployment.py",
            "lineno": 223,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\deployment.py",
            "lineno": 215,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\deployment.py",
            "lineno": 157,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "url = 'http://localhost/engine-rest/deployment/create', method = 'POST'\nheaders = None, params = {}\ndata = {'deploy-changed-only': False, 'deployment-name': 'aName', 'deployment-source': 'aSource', 'enable-duplicate-filtering': False}\nfiles = [('resource-0', (10, 'NotARealFile'))]\n\n    @staticmethod\n    def send_request(url, method, headers=None, params=None, data=None, files=None):\n        buffer = io.BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(curl.URL, url)\n        curl.setopt(curl.WRITEDATA, buffer)\n    \n        if headers:\n            curl.setopt(curl.HTTPHEADER, [f\"{key}: {value}\" for key, value in headers.items()])\n    \n        if method == 'POST':\n            curl.setopt(curl.POST, 1)\n            if data:\n                curl.setopt(curl.POSTFIELDS, json.dumps(data))\n            if files:\n                curl.setopt(curl.HTTPPOST, files)\n    \n        elif method == 'DELETE':\n            curl.setopt(curl.CUSTOMREQUEST, 'DELETE')\n    \n        elif method == 'GET':\n            curl.setopt(curl.HTTPGET, 1)\n    \n        try:\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2415 ms: Could not connect to server')\n\npycamunda\\deployment.py:154: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200234784528'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    def test_create_calls_requests(mock, engine_url):\n        create_deployment = pycamunda.deployment.Create(url=engine_url, name='aName', source='aSource')\n        create_deployment.add_resource(file='NotARealFile')\n>       create_deployment()\n\ntests\\deployment\\test_create.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\deployment.py:223: in __call__\n    raise exc\npycamunda\\deployment.py:215: in __call__\n    response = PyCurlRequest.send_request(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nurl = 'http://localhost/engine-rest/deployment/create', method = 'POST'\nheaders = None, params = {}\ndata = {'deploy-changed-only': False, 'deployment-name': 'aName', 'deployment-source': 'aSource', 'enable-duplicate-filtering': False}\nfiles = [('resource-0', (10, 'NotARealFile'))]\n\n    @staticmethod\n    def send_request(url, method, headers=None, params=None, data=None, files=None):\n        buffer = io.BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(curl.URL, url)\n        curl.setopt(curl.WRITEDATA, buffer)\n    \n        if headers:\n            curl.setopt(curl.HTTPHEADER, [f\"{key}: {value}\" for key, value in headers.items()])\n    \n        if method == 'POST':\n            curl.setopt(curl.POST, 1)\n            if data:\n                curl.setopt(curl.POSTFIELDS, json.dumps(data))\n            if files:\n                curl.setopt(curl.HTTPPOST, files)\n    \n        elif method == 'DELETE':\n            curl.setopt(curl.CUSTOMREQUEST, 'DELETE')\n    \n        elif method == 'GET':\n            curl.setopt(curl.HTTPGET, 1)\n    \n        try:\n            curl.perform()\n            curl.close()\n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2415 ms: Could not connect to server')\n\npycamunda\\deployment.py:157: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_create.py::test_create_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_create_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_create.py::test_create_raises_for_status",
      "lineno": 37,
      "outcome": "failed",
      "keywords": [
        "test_create_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\deployment.py",
          "lineno": 157,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2435 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_create.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "pycamunda\\deployment.py",
            "lineno": 223,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\deployment.py",
            "lineno": 215,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\deployment.py",
            "lineno": 157,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "url = 'http://localhost/engine-rest/deployment/create', method = 'POST'\nheaders = None, params = {}\ndata = {'deploy-changed-only': False, 'deployment-name': 'aName', 'deployment-source': 'aSource', 'enable-duplicate-filtering': False}\nfiles = [('resource-0', (10, 'NotARealFile'))]\n\n    @staticmethod\n    def send_request(url, method, headers=None, params=None, data=None, files=None):\n        buffer = io.BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(curl.URL, url)\n        curl.setopt(curl.WRITEDATA, buffer)\n    \n        if headers:\n            curl.setopt(curl.HTTPHEADER, [f\"{key}: {value}\" for key, value in headers.items()])\n    \n        if method == 'POST':\n            curl.setopt(curl.POST, 1)\n            if data:\n                curl.setopt(curl.POSTFIELDS, json.dumps(data))\n            if files:\n                curl.setopt(curl.HTTPPOST, files)\n    \n        elif method == 'DELETE':\n            curl.setopt(curl.CUSTOMREQUEST, 'DELETE')\n    \n        elif method == 'GET':\n            curl.setopt(curl.HTTPGET, 1)\n    \n        try:\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2435 ms: Could not connect to server')\n\npycamunda\\deployment.py:154: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200234362048'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch(\n        'pycamunda.deployment.DeploymentWithDefinitions.load', unittest.mock.MagicMock()\n    )\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_create_raises_for_status(mock, engine_url):\n        create_deployment = pycamunda.deployment.Create(url=engine_url, name='aName', source='aSource')\n        create_deployment.add_resource(file='NotARealFile')\n>       create_deployment()\n\ntests\\deployment\\test_create.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\deployment.py:223: in __call__\n    raise exc\npycamunda\\deployment.py:215: in __call__\n    response = PyCurlRequest.send_request(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nurl = 'http://localhost/engine-rest/deployment/create', method = 'POST'\nheaders = None, params = {}\ndata = {'deploy-changed-only': False, 'deployment-name': 'aName', 'deployment-source': 'aSource', 'enable-duplicate-filtering': False}\nfiles = [('resource-0', (10, 'NotARealFile'))]\n\n    @staticmethod\n    def send_request(url, method, headers=None, params=None, data=None, files=None):\n        buffer = io.BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(curl.URL, url)\n        curl.setopt(curl.WRITEDATA, buffer)\n    \n        if headers:\n            curl.setopt(curl.HTTPHEADER, [f\"{key}: {value}\" for key, value in headers.items()])\n    \n        if method == 'POST':\n            curl.setopt(curl.POST, 1)\n            if data:\n                curl.setopt(curl.POSTFIELDS, json.dumps(data))\n            if files:\n                curl.setopt(curl.HTTPPOST, files)\n    \n        elif method == 'DELETE':\n            curl.setopt(curl.CUSTOMREQUEST, 'DELETE')\n    \n        elif method == 'GET':\n            curl.setopt(curl.HTTPGET, 1)\n    \n        try:\n            curl.perform()\n            curl.close()\n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2435 ms: Could not connect to server')\n\npycamunda\\deployment.py:157: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_create.py::test_create_returns_deployment_with_definitions",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_create_returns_deployment_with_definitions",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\deployment.py",
          "lineno": 157,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2259 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_create.py",
            "lineno": 56,
            "message": ""
          },
          {
            "path": "pycamunda\\deployment.py",
            "lineno": 223,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\deployment.py",
            "lineno": 215,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\deployment.py",
            "lineno": 157,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "url = 'http://localhost/engine-rest/deployment/create', method = 'POST'\nheaders = None, params = {}\ndata = {'deploy-changed-only': False, 'deployment-name': 'aName', 'deployment-source': 'aSource', 'enable-duplicate-filtering': False}\nfiles = [('resource-0', (10, 'NotARealFile'))]\n\n    @staticmethod\n    def send_request(url, method, headers=None, params=None, data=None, files=None):\n        buffer = io.BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(curl.URL, url)\n        curl.setopt(curl.WRITEDATA, buffer)\n    \n        if headers:\n            curl.setopt(curl.HTTPHEADER, [f\"{key}: {value}\" for key, value in headers.items()])\n    \n        if method == 'POST':\n            curl.setopt(curl.POST, 1)\n            if data:\n                curl.setopt(curl.POSTFIELDS, json.dumps(data))\n            if files:\n                curl.setopt(curl.HTTPPOST, files)\n    \n        elif method == 'DELETE':\n            curl.setopt(curl.CUSTOMREQUEST, 'DELETE')\n    \n        elif method == 'GET':\n            curl.setopt(curl.HTTPGET, 1)\n    \n        try:\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2259 ms: Could not connect to server')\n\npycamunda\\deployment.py:154: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    def test_create_returns_deployment_with_definitions(engine_url):\n        create_deployment = pycamunda.deployment.Create(url=engine_url, name='aName', source='aSource')\n        create_deployment.add_resource(file='NotARealFile')\n>       result = create_deployment()\n\ntests\\deployment\\test_create.py:56: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\deployment.py:223: in __call__\n    raise exc\npycamunda\\deployment.py:215: in __call__\n    response = PyCurlRequest.send_request(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nurl = 'http://localhost/engine-rest/deployment/create', method = 'POST'\nheaders = None, params = {}\ndata = {'deploy-changed-only': False, 'deployment-name': 'aName', 'deployment-source': 'aSource', 'enable-duplicate-filtering': False}\nfiles = [('resource-0', (10, 'NotARealFile'))]\n\n    @staticmethod\n    def send_request(url, method, headers=None, params=None, data=None, files=None):\n        buffer = io.BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(curl.URL, url)\n        curl.setopt(curl.WRITEDATA, buffer)\n    \n        if headers:\n            curl.setopt(curl.HTTPHEADER, [f\"{key}: {value}\" for key, value in headers.items()])\n    \n        if method == 'POST':\n            curl.setopt(curl.POST, 1)\n            if data:\n                curl.setopt(curl.POSTFIELDS, json.dumps(data))\n            if files:\n                curl.setopt(curl.HTTPPOST, files)\n    \n        elif method == 'DELETE':\n            curl.setopt(curl.CUSTOMREQUEST, 'DELETE')\n    \n        elif method == 'GET':\n            curl.setopt(curl.HTTPGET, 1)\n    \n        try:\n            curl.perform()\n            curl.close()\n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2259 ms: Could not connect to server')\n\npycamunda\\deployment.py:157: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_delete.py::test_delete_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_delete_params",
        "test_delete.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_delete.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'Delete'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_delete.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_delete_params(engine_url):\n>       delete_deployment = pycamunda.deployment.Delete(\n            url=engine_url, id_='anId', cascade=True, skip_custom_listeners=True, skip_io_mappings=True\n        )\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'Delete'\n\ntests\\deployment\\test_delete.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_delete.py::test_get_calls_requests",
      "lineno": 22,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_delete.py",
          "lineno": 25,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'Delete'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_delete.py",
            "lineno": 25,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200233932176'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n>       delete_deployment = pycamunda.deployment.Delete(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'Delete'\n\ntests\\deployment\\test_delete.py:25: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_delete.py::test_get_raises_pycamunda_exception",
      "lineno": 31,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_delete.py",
          "lineno": 34,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'Delete'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_delete.py",
            "lineno": 34,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_get_raises_pycamunda_exception(engine_url):\n>       delete_deployment = pycamunda.deployment.Delete(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'Delete'\n\ntests\\deployment\\test_delete.py:34: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_delete.py::test_get_raises_for_status",
      "lineno": 38,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_delete.py",
          "lineno": 42,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'Delete'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_delete.py",
            "lineno": 42,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200230944080'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n>       delete_deployment = pycamunda.deployment.Delete(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'Delete'\n\ntests\\deployment\\test_delete.py:42: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_delete.py::test_get_returns_none",
      "lineno": 47,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_none",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_delete.py",
          "lineno": 50,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'Delete'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_delete.py",
            "lineno": 50,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_get_returns_none(engine_url):\n>       delete_deployment = pycamunda.deployment.Delete(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'Delete'\n\ntests\\deployment\\test_delete.py:50: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_deployment.py::test_deployment_load",
      "lineno": 9,
      "outcome": "passed",
      "keywords": [
        "test_deployment_load",
        "test_deployment.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_deployment.py::test_deployment_load_raises_keyerror",
      "lineno": 21,
      "outcome": "passed",
      "keywords": [
        "test_deployment_load_raises_keyerror",
        "test_deployment.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_deploymentwithdefinitions.py::test_deployment_with_definitions_load",
      "lineno": 8,
      "outcome": "passed",
      "keywords": [
        "test_deployment_with_definitions_load",
        "test_deploymentwithdefinitions.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_deploymentwithdefinitions.py::test_deployment_with_definitions_load_raises_keyerror",
      "lineno": 35,
      "outcome": "passed",
      "keywords": [
        "test_deployment_with_definitions_load_raises_keyerror",
        "test_deploymentwithdefinitions.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_get.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'Get'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_get.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_get_params(engine_url):\n>       get_deployment = pycamunda.deployment.Get(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'Get'\n\ntests\\deployment\\test_get.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_get.py::test_get_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_get.py",
          "lineno": 22,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'Get'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_get.py",
            "lineno": 22,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200233450256'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n>       get_deployment = pycamunda.deployment.Get(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'Get'\n\ntests\\deployment\\test_get.py:22: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_get.py",
          "lineno": 31,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'Get'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_get.py",
            "lineno": 31,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_get_raises_pycamunda_exception(engine_url):\n>       get_deployment = pycamunda.deployment.Get(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'Get'\n\ntests\\deployment\\test_get.py:31: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_get.py::test_get_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_get.py",
          "lineno": 40,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'Get'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_get.py",
            "lineno": 40,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200233228144'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.deployment.Deployment', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n>       get_deployment = pycamunda.deployment.Get(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'Get'\n\ntests\\deployment\\test_get.py:40: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_get.py::test_get_returns_response_content",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_response_content",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_get.py",
          "lineno": 49,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'Get'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_get.py",
            "lineno": 49,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = <MagicMock name='from_isoformat' id='3200233227424'>\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat')\n    def test_get_returns_response_content(engine_url):\n>       get_deployment = pycamunda.deployment.Get(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'Get'\n\ntests\\deployment\\test_get.py:49: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getlist.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetList'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getlist.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\ngetlist_input = {'after': datetime.datetime(2000, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'ascending': True, 'before': datetime.datetime(2000, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), 'first_result': 1, ...}\ngetlist_output = {'after': '2000-01-01T00:00:00.000+0000', 'before': '2000-01-01T00:00:00.000+0000', 'firstResult': 1, 'id': 'anId', ...}\n\n    def test_getlist_params(engine_url, getlist_input, getlist_output):\n>       get_deployments = pycamunda.deployment.GetList(url=engine_url, **getlist_input)\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetList'\n\ntests\\deployment\\test_getlist.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getlist.py::test_getlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getlist.py",
          "lineno": 21,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetList'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getlist.py",
            "lineno": 21,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200232899600'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n>       get_deployments = pycamunda.deployment.GetList(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetList'\n\ntests\\deployment\\test_getlist.py:21: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getlist.py",
          "lineno": 30,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetList'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getlist.py",
            "lineno": 30,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_getlist_raises_pycamunda_exception(engine_url):\n>       get_deployments = pycamunda.deployment.GetList(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetList'\n\ntests\\deployment\\test_getlist.py:30: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getlist.py",
          "lineno": 39,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetList'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getlist.py",
            "lineno": 39,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200232906656'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.deployment.Deployment', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n>       get_deployments = pycamunda.deployment.GetList(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetList'\n\ntests\\deployment\\test_getlist.py:39: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getlist.py::test_getlist_returns_response_content",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_response_content",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getlist.py",
          "lineno": 47,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetList'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getlist.py",
            "lineno": 47,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getlist_returns_response_content(engine_url):\n>       get_deployments = pycamunda.deployment.GetList(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetList'\n\ntests\\deployment\\test_getlist.py:47: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getresource.py::test_getresource_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_getresource_params",
        "test_getresource.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getresource.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getresource.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_getresource_params(engine_url):\n>       get_resource = pycamunda.deployment.GetResource(\n            url=engine_url, id_='anId', resource_id='aResourceId', binary=False\n        )\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?\n\ntests\\deployment\\test_getresource.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getresource.py::test_getresource_binary_params",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_getresource_binary_params",
        "test_getresource.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getresource.py",
          "lineno": 22,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getresource.py",
            "lineno": 22,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_getresource_binary_params(engine_url):\n>       get_resource = pycamunda.deployment.GetResource(\n            url=engine_url, id_='anId', resource_id='aResourceId', binary=True\n        )\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?\n\ntests\\deployment\\test_getresource.py:22: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getresource.py::test_getresource_calls_requests",
      "lineno": 30,
      "outcome": "failed",
      "keywords": [
        "test_getresource_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getresource.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getresource.py",
          "lineno": 33,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getresource.py",
            "lineno": 33,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200233228384'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getresource_calls_requests(mock, engine_url):\n>       get_resource = pycamunda.deployment.GetResource(\n            url=engine_url, id_='anId', resource_id='aResourceId'\n        )\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?\n\ntests\\deployment\\test_getresource.py:33: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getresource.py::test_getresource_raises_pycamunda_exception",
      "lineno": 41,
      "outcome": "failed",
      "keywords": [
        "test_getresource_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getresource.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getresource.py",
          "lineno": 44,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getresource.py",
            "lineno": 44,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_getresource_raises_pycamunda_exception(engine_url):\n>       get_resource = pycamunda.deployment.GetResource(\n            url=engine_url, id_='anId', resource_id='aResourceId'\n        )\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?\n\ntests\\deployment\\test_getresource.py:44: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getresource.py::test_getresource_raises_for_status",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_getresource_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getresource.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getresource.py",
          "lineno": 55,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getresource.py",
            "lineno": 55,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200233449680'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    @unittest.mock.patch('pycamunda.deployment.Resource', unittest.mock.MagicMock())\n    def test_getresource_raises_for_status(mock, engine_url):\n>       get_resource = pycamunda.deployment.GetResource(\n            url=engine_url, id_='anId', resource_id='aResourceId'\n        )\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?\n\ntests\\deployment\\test_getresource.py:55: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getresource.py::test_getresources_returns_resource",
      "lineno": 62,
      "outcome": "failed",
      "keywords": [
        "test_getresources_returns_resource",
        "__wrapped__",
        "patchings",
        "test_getresource.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getresource.py",
          "lineno": 65,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getresource.py",
            "lineno": 65,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getresources_returns_resource(engine_url):\n>       get_resource = pycamunda.deployment.GetResource(\n            url=engine_url, id_='anId', resource_id='aResourceId'\n        )\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?\n\ntests\\deployment\\test_getresource.py:65: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getresource.py::test_getresources_binary_returns_content",
      "lineno": 72,
      "outcome": "failed",
      "keywords": [
        "test_getresources_binary_returns_content",
        "__wrapped__",
        "patchings",
        "test_getresource.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getresource.py",
          "lineno": 75,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getresource.py",
            "lineno": 75,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', response_mock)\n    def test_getresources_binary_returns_content(engine_url):\n>       get_resource = pycamunda.deployment.GetResource(\n            url=engine_url, id_='anId', resource_id='aResourceId', binary=True\n        )\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetResource'. Did you mean: 'Resource'?\n\ntests\\deployment\\test_getresource.py:75: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getresources.py::test_getresources_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_getresources_params",
        "test_getresources.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getresources.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetResources'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getresources.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_getresources_params(engine_url):\n>       get_resources = pycamunda.deployment.GetResources(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetResources'\n\ntests\\deployment\\test_getresources.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getresources.py::test_getresources_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getresources_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getresources.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getresources.py",
          "lineno": 21,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetResources'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getresources.py",
            "lineno": 21,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200234361136'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getresources_calls_requests(mock, engine_url):\n>       get_resources = pycamunda.deployment.GetResources(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetResources'\n\ntests\\deployment\\test_getresources.py:21: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getresources.py::test_getresources_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "failed",
      "keywords": [
        "test_getresources_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getresources.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getresources.py",
          "lineno": 30,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetResources'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getresources.py",
            "lineno": 30,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_getresources_raises_pycamunda_exception(engine_url):\n>       get_resources = pycamunda.deployment.GetResources(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetResources'\n\ntests\\deployment\\test_getresources.py:30: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getresources.py::test_getresources_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_getresources_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getresources.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getresources.py",
          "lineno": 39,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetResources'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getresources.py",
            "lineno": 39,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200232904784'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    @unittest.mock.patch('pycamunda.deployment.Resource', unittest.mock.MagicMock())\n    def test_getresources_raises_for_status(mock, engine_url):\n>       get_resources = pycamunda.deployment.GetResources(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetResources'\n\ntests\\deployment\\test_getresources.py:39: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_getresources.py::test_getresources_returns_resources",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_getresources_returns_resources",
        "__wrapped__",
        "patchings",
        "test_getresources.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_getresources.py",
          "lineno": 48,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetResources'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_getresources.py",
            "lineno": 48,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.deployment.Resource', unittest.mock.MagicMock())\n    def test_getresources_returns_resources(engine_url):\n>       get_resources = pycamunda.deployment.GetResources(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.deployment' has no attribute 'GetResources'\n\ntests\\deployment\\test_getresources.py:48: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "failed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\deployment\\test_module.py",
          "lineno": 8,
          "message": "AttributeError: module 'pycamunda.deployment' has no attribute 'GetList'"
        },
        "traceback": [
          {
            "path": "tests\\deployment\\test_module.py",
            "lineno": 8,
            "message": "AttributeError"
          }
        ],
        "longrepr": "def test_all_contains_only_valid_names():\n        import pycamunda.deployment\n    \n        for name in pycamunda.deployment.__all__:\n>           getattr(pycamunda.deployment, name)\nE           AttributeError: module 'pycamunda.deployment' has no attribute 'GetList'\n\ntests\\deployment\\test_module.py:8: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_resource.py::test_resource_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_resource_load",
        "test_resource.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/deployment/test_resource.py::test_resource_load_raises_keyerror",
      "lineno": 17,
      "outcome": "passed",
      "keywords": [
        "test_resource_load_raises_keyerror",
        "test_resource.py",
        "deployment",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/execution/test_execution.py::test_execution_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_execution_load",
        "test_execution.py",
        "execution",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/execution/test_execution.py::test_execution_load_raises_keyerror",
      "lineno": 16,
      "outcome": "passed",
      "keywords": [
        "test_execution_load_raises_keyerror",
        "test_execution.py",
        "execution",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/execution/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "execution",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_complete.py::test_complete_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_complete_params",
        "test_complete.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_complete.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Complete'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_complete.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_complete_params(engine_url):\n>       complete_task = pycamunda.externaltask.Complete(url=engine_url, worker_id='1', id_='anId')\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Complete'\n\ntests\\externaltask\\test_complete.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_complete.py::test_complete_calls_requests",
      "lineno": 26,
      "outcome": "failed",
      "keywords": [
        "test_complete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_complete.py",
          "lineno": 29,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Complete'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_complete.py",
            "lineno": 29,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200232578448'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_complete_calls_requests(mock, engine_url):\n>       complete_task = pycamunda.externaltask.Complete(url=engine_url, worker_id='1', id_='anId')\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Complete'\n\ntests\\externaltask\\test_complete.py:29: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_complete.py::test_complete_raises_pycamunda_exception",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_complete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_complete.py",
          "lineno": 38,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Complete'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_complete.py",
            "lineno": 38,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_complete_raises_pycamunda_exception(engine_url):\n>       complete_task = pycamunda.externaltask.Complete(url=engine_url, worker_id='1', id_='anId')\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Complete'\n\ntests\\externaltask\\test_complete.py:38: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_complete.py::test_complete_raises_for_status",
      "lineno": 42,
      "outcome": "failed",
      "keywords": [
        "test_complete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_complete.py",
          "lineno": 46,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Complete'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_complete.py",
            "lineno": 46,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200232901520'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_complete_raises_for_status(mock, engine_url):\n>       complete_task = pycamunda.externaltask.Complete(url=engine_url, worker_id='1', id_='anId')\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Complete'\n\ntests\\externaltask\\test_complete.py:46: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_complete.py::test_complete_returns_none",
      "lineno": 51,
      "outcome": "failed",
      "keywords": [
        "test_complete_returns_none",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_complete.py",
          "lineno": 54,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Complete'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_complete.py",
            "lineno": 54,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_complete_returns_none(engine_url):\n>       complete_task = pycamunda.externaltask.Complete(url=engine_url, worker_id='1', id_='anId')\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Complete'\n\ntests\\externaltask\\test_complete.py:54: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_count.py::test_count_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_count_params",
        "test_count.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_count.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Count'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_count.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\ngetlist_input = {'active': True, 'activity_id': 'anActivityId', 'activity_id_in': [], 'ascending': True, ...}\ngetlist_output = {'active': 'true', 'activityId': 'anActivityId', 'activityIdIn': [], 'executionId': 'anExecutionId', ...}\n\n    def test_count_params(engine_url, getlist_input, getlist_output):\n>       count_tasks = pycamunda.externaltask.Count(url=engine_url, **getlist_input)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Count'\n\ntests\\externaltask\\test_count.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_count.py::test_count_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_count_calls_requests",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_count.py",
          "lineno": 21,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Count'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_count.py",
            "lineno": 21,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200230939616'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_count_calls_requests(mock, engine_url):\n>       count_tasks = pycamunda.externaltask.Count(url=engine_url)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Count'\n\ntests\\externaltask\\test_count.py:21: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_count.py::test_count_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_count_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_count.py",
          "lineno": 31,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Count'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_count.py",
            "lineno": 31,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_count_raises_pycamunda_exception(engine_url):\n>       count_tasks = pycamunda.externaltask.Count(url=engine_url)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Count'\n\ntests\\externaltask\\test_count.py:31: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_count.py::test_count_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_count_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_count.py",
          "lineno": 39,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Count'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_count.py",
            "lineno": 39,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200233440848'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_count_raises_for_status(mock, engine_url):\n>       count_tasks = pycamunda.externaltask.Count(url=engine_url)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Count'\n\ntests\\externaltask\\test_count.py:39: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_count.py::test_count_returns_int",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_count_returns_int",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_count.py",
          "lineno": 47,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Count'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_count.py",
            "lineno": 47,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_count_returns_int(engine_url):\n>       count_tasks = pycamunda.externaltask.Count(url=engine_url)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Count'\n\ntests\\externaltask\\test_count.py:47: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_extendlock.py::test_extendlock_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_extendlock_params",
        "test_extendlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_extendlock.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'ExtendLock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_extendlock.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_extendlock_params(engine_url):\n>       extend_task_lock = pycamunda.externaltask.ExtendLock(\n            url=engine_url, id_='anId', new_duration=10000, worker_id='1'\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'ExtendLock'\n\ntests\\externaltask\\test_extendlock.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_extendlock.py::test_extendlock_calls_requests",
      "lineno": 23,
      "outcome": "failed",
      "keywords": [
        "test_extendlock_calls_requests",
        "__wrapped__",
        "patchings",
        "test_extendlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_extendlock.py",
          "lineno": 26,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'ExtendLock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_extendlock.py",
            "lineno": 26,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200233232368'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_extendlock_calls_requests(mock, engine_url):\n>       extend_task_lock = pycamunda.externaltask.ExtendLock(\n            url=engine_url, id_='anId', new_duration=10000, worker_id='1'\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'ExtendLock'\n\ntests\\externaltask\\test_extendlock.py:26: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_extendlock.py::test_extendlock_raises_pycamunda_exception",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_extendlock_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_extendlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_extendlock.py",
          "lineno": 37,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'ExtendLock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_extendlock.py",
            "lineno": 37,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_extendlock_raises_pycamunda_exception(engine_url):\n>       extend_task_lock = pycamunda.externaltask.ExtendLock(\n            url=engine_url, id_='anId', new_duration=10000, worker_id='1'\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'ExtendLock'\n\ntests\\externaltask\\test_extendlock.py:37: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_extendlock.py::test_extendlock_raises_for_status",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_extendlock_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_extendlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_extendlock.py",
          "lineno": 47,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'ExtendLock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_extendlock.py",
            "lineno": 47,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200233113312'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_extendlock_raises_for_status(mock, engine_url):\n>       extend_task_lock = pycamunda.externaltask.ExtendLock(\n            url=engine_url, id_='anId', new_duration=10000, worker_id='1'\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'ExtendLock'\n\ntests\\externaltask\\test_extendlock.py:47: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_extendlock.py::test_extendlock_returns_none",
      "lineno": 54,
      "outcome": "failed",
      "keywords": [
        "test_extendlock_returns_none",
        "__wrapped__",
        "patchings",
        "test_extendlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_extendlock.py",
          "lineno": 57,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'ExtendLock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_extendlock.py",
            "lineno": 57,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_extendlock_returns_none(engine_url):\n>       extend_task_lock = pycamunda.externaltask.ExtendLock(\n            url=engine_url, id_='anId', new_duration=10000, worker_id='1'\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'ExtendLock'\n\ntests\\externaltask\\test_extendlock.py:57: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_externaltask.py::test_externaltask_load_definition",
      "lineno": 9,
      "outcome": "passed",
      "keywords": [
        "test_externaltask_load_definition",
        "test_externaltask.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_externaltask.py::test_externaltask_load_definition_without_error_details",
      "lineno": 38,
      "outcome": "passed",
      "keywords": [
        "test_externaltask_load_definition_without_error_details",
        "test_externaltask.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_externaltask.py::test_externaltask_load_raises_keyerror",
      "lineno": 46,
      "outcome": "passed",
      "keywords": [
        "test_externaltask_load_raises_keyerror",
        "test_externaltask.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_fetchandlock.py::test_fetchandlock_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_fetchandlock_params",
        "test_fetchandlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_fetchandlock.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'FetchAndLock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_fetchandlock.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_fetchandlock_params(engine_url):\n>       fetch_and_lock = pycamunda.externaltask.FetchAndLock(\n            url=engine_url, worker_id='1', max_tasks=10, use_priority=True\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'FetchAndLock'\n\ntests\\externaltask\\test_fetchandlock.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_fetchandlock.py::test_fetchandlock_calls_requests",
      "lineno": 33,
      "outcome": "failed",
      "keywords": [
        "test_fetchandlock_calls_requests",
        "__wrapped__",
        "patchings",
        "test_fetchandlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_fetchandlock.py",
          "lineno": 36,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'FetchAndLock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_fetchandlock.py",
            "lineno": 36,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200233119120'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_fetchandlock_calls_requests(mock, engine_url):\n>       fetch_and_lock = pycamunda.externaltask.FetchAndLock(\n            url=engine_url, worker_id='1', max_tasks=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'FetchAndLock'\n\ntests\\externaltask\\test_fetchandlock.py:36: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_fetchandlock.py::test_fetchandlock_raises_pycamunda_exception",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_fetchandlock_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_fetchandlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_fetchandlock.py",
          "lineno": 47,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'FetchAndLock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_fetchandlock.py",
            "lineno": 47,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_fetchandlock_raises_pycamunda_exception(engine_url):\n>       fetch_and_lock = pycamunda.externaltask.FetchAndLock(\n            url=engine_url, worker_id='1', max_tasks=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'FetchAndLock'\n\ntests\\externaltask\\test_fetchandlock.py:47: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_fetchandlock.py::test_fetchandlock_raises_for_status",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_fetchandlock_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_fetchandlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_fetchandlock.py",
          "lineno": 58,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'FetchAndLock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_fetchandlock.py",
            "lineno": 58,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200231200992'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.externaltask.ExternalTask', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_fetchandlock_raises_for_status(mock, engine_url):\n>       fetch_and_lock = pycamunda.externaltask.FetchAndLock(\n            url=engine_url, worker_id='1', max_tasks=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'FetchAndLock'\n\ntests\\externaltask\\test_fetchandlock.py:58: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_fetchandlock.py::test_fetchandlock_returns_tuple",
      "lineno": 65,
      "outcome": "failed",
      "keywords": [
        "test_fetchandlock_returns_tuple",
        "__wrapped__",
        "patchings",
        "test_fetchandlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_fetchandlock.py",
          "lineno": 68,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'FetchAndLock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_fetchandlock.py",
            "lineno": 68,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_fetchandlock_returns_tuple(engine_url):\n>       fetch_and_lock = pycamunda.externaltask.FetchAndLock(\n            url=engine_url, worker_id='1', max_tasks=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'FetchAndLock'\n\ntests\\externaltask\\test_fetchandlock.py:68: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_get.py::test_get_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\externaltask.py",
          "lineno": 112,
          "message": "pycamunda.PyCamundaException: Request failed: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_get.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\externaltask.py",
            "lineno": 137,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\externaltask.py",
            "lineno": 112,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "url = 'http://localhost/engine-rest/external-task/aTaskId', method = 'GET'\ndata = None\n\n    def _perform_request(url: str, method: str = 'GET', data: typing.Optional[dict] = None) -> str:\n        \"\"\"Helper function to perform HTTP requests using pycurl.\"\"\"\n        buffer = BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.URL, url)\n        curl.setopt(pycurl.WRITEDATA, buffer)\n        curl.setopt(pycurl.CUSTOMREQUEST, method)\n    \n        if method == 'POST' and data is not None:\n            curl.setopt(pycurl.POSTFIELDS, json.dumps(data))\n            curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n        try:\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\externaltask.py:110: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200233113312'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    @unittest.mock.patch('pycamunda.externaltask.ExternalTask', unittest.mock.MagicMock())\n    def test_get_calls_requests(mock, engine_url):\n        get_task = pycamunda.externaltask.Get(url=engine_url, id_='aTaskId')\n>       get_task()\n\ntests\\externaltask\\test_get.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\externaltask.py:137: in __call__\n    response = _perform_request(self.url, method='GET')\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nurl = 'http://localhost/engine-rest/external-task/aTaskId', method = 'GET'\ndata = None\n\n    def _perform_request(url: str, method: str = 'GET', data: typing.Optional[dict] = None) -> str:\n        \"\"\"Helper function to perform HTTP requests using pycurl.\"\"\"\n        buffer = BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.URL, url)\n        curl.setopt(pycurl.WRITEDATA, buffer)\n        curl.setopt(pycurl.CUSTOMREQUEST, method)\n    \n        if method == 'POST' and data is not None:\n            curl.setopt(pycurl.POSTFIELDS, json.dumps(data))\n            curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n        try:\n            curl.perform()\n        except pycurl.error as e:\n>           raise pycamunda.PyCamundaException(f\"Request failed: {e}\")\nE           pycamunda.PyCamundaException: Request failed: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\externaltask.py:112: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_get.py::test_get_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\externaltask.py",
          "lineno": 112,
          "message": "pycamunda.PyCamundaException: Request failed: (7, 'Failed to connect to localhost port 80 after 2273 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_get.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\externaltask.py",
            "lineno": 137,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\externaltask.py",
            "lineno": 112,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "url = 'http://localhost/engine-rest/external-task/aTaskId', method = 'GET'\ndata = None\n\n    def _perform_request(url: str, method: str = 'GET', data: typing.Optional[dict] = None) -> str:\n        \"\"\"Helper function to perform HTTP requests using pycurl.\"\"\"\n        buffer = BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.URL, url)\n        curl.setopt(pycurl.WRITEDATA, buffer)\n        curl.setopt(pycurl.CUSTOMREQUEST, method)\n    \n        if method == 'POST' and data is not None:\n            curl.setopt(pycurl.POSTFIELDS, json.dumps(data))\n            curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n        try:\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2273 ms: Could not connect to server')\n\npycamunda\\externaltask.py:110: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200232577200'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.externaltask.ExternalTask', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_task = pycamunda.externaltask.Get(url=engine_url, id_='aTaskId')\n>       get_task()\n\ntests\\externaltask\\test_get.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\externaltask.py:137: in __call__\n    response = _perform_request(self.url, method='GET')\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nurl = 'http://localhost/engine-rest/external-task/aTaskId', method = 'GET'\ndata = None\n\n    def _perform_request(url: str, method: str = 'GET', data: typing.Optional[dict] = None) -> str:\n        \"\"\"Helper function to perform HTTP requests using pycurl.\"\"\"\n        buffer = BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.URL, url)\n        curl.setopt(pycurl.WRITEDATA, buffer)\n        curl.setopt(pycurl.CUSTOMREQUEST, method)\n    \n        if method == 'POST' and data is not None:\n            curl.setopt(pycurl.POSTFIELDS, json.dumps(data))\n            curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n        try:\n            curl.perform()\n        except pycurl.error as e:\n>           raise pycamunda.PyCamundaException(f\"Request failed: {e}\")\nE           pycamunda.PyCamundaException: Request failed: (7, 'Failed to connect to localhost port 80 after 2273 ms: Could not connect to server')\n\npycamunda\\externaltask.py:112: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_get.py::test_get_returns_none",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_none",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\externaltask.py",
          "lineno": 112,
          "message": "pycamunda.PyCamundaException: Request failed: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_get.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\externaltask.py",
            "lineno": 137,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\externaltask.py",
            "lineno": 112,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "url = 'http://localhost/engine-rest/external-task/aTaskId', method = 'GET'\ndata = None\n\n    def _perform_request(url: str, method: str = 'GET', data: typing.Optional[dict] = None) -> str:\n        \"\"\"Helper function to perform HTTP requests using pycurl.\"\"\"\n        buffer = BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.URL, url)\n        curl.setopt(pycurl.WRITEDATA, buffer)\n        curl.setopt(pycurl.CUSTOMREQUEST, method)\n    \n        if method == 'POST' and data is not None:\n            curl.setopt(pycurl.POSTFIELDS, json.dumps(data))\n            curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n        try:\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\externaltask.py:110: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    def test_get_returns_none(engine_url):\n        get_task = pycamunda.externaltask.Get(url=engine_url, id_='aTaskId')\n>       task = get_task()\n\ntests\\externaltask\\test_get.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\externaltask.py:137: in __call__\n    response = _perform_request(self.url, method='GET')\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nurl = 'http://localhost/engine-rest/external-task/aTaskId', method = 'GET'\ndata = None\n\n    def _perform_request(url: str, method: str = 'GET', data: typing.Optional[dict] = None) -> str:\n        \"\"\"Helper function to perform HTTP requests using pycurl.\"\"\"\n        buffer = BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.URL, url)\n        curl.setopt(pycurl.WRITEDATA, buffer)\n        curl.setopt(pycurl.CUSTOMREQUEST, method)\n    \n        if method == 'POST' and data is not None:\n            curl.setopt(pycurl.POSTFIELDS, json.dumps(data))\n            curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n        try:\n            curl.perform()\n        except pycurl.error as e:\n>           raise pycamunda.PyCamundaException(f\"Request failed: {e}\")\nE           pycamunda.PyCamundaException: Request failed: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\externaltask.py:112: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_getlist.py::test_getlist_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\externaltask.py",
          "lineno": 112,
          "message": "pycamunda.PyCamundaException: Request failed: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_getlist.py",
            "lineno": 25,
            "message": ""
          },
          {
            "path": "pycamunda\\externaltask.py",
            "lineno": 283,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\externaltask.py",
            "lineno": 112,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "url = 'http://localhost/engine-rest/external-task', method = 'GET', data = None\n\n    def _perform_request(url: str, method: str = 'GET', data: typing.Optional[dict] = None) -> str:\n        \"\"\"Helper function to perform HTTP requests using pycurl.\"\"\"\n        buffer = BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.URL, url)\n        curl.setopt(pycurl.WRITEDATA, buffer)\n        curl.setopt(pycurl.CUSTOMREQUEST, method)\n    \n        if method == 'POST' and data is not None:\n            curl.setopt(pycurl.POSTFIELDS, json.dumps(data))\n            curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n        try:\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')\n\npycamunda\\externaltask.py:110: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200230939712'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    @unittest.mock.patch('pycamunda.externaltask.ExternalTask', unittest.mock.MagicMock())\n    def test_getlist_calls_requests(mock, engine_url):\n        get_tasks = pycamunda.externaltask.GetList(url=engine_url)\n>       get_tasks()\n\ntests\\externaltask\\test_getlist.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\externaltask.py:283: in __call__\n    response = _perform_request(self.url, method='GET')\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nurl = 'http://localhost/engine-rest/external-task', method = 'GET', data = None\n\n    def _perform_request(url: str, method: str = 'GET', data: typing.Optional[dict] = None) -> str:\n        \"\"\"Helper function to perform HTTP requests using pycurl.\"\"\"\n        buffer = BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.URL, url)\n        curl.setopt(pycurl.WRITEDATA, buffer)\n        curl.setopt(pycurl.CUSTOMREQUEST, method)\n    \n        if method == 'POST' and data is not None:\n            curl.setopt(pycurl.POSTFIELDS, json.dumps(data))\n            curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n        try:\n            curl.perform()\n        except pycurl.error as e:\n>           raise pycamunda.PyCamundaException(f\"Request failed: {e}\")\nE           pycamunda.PyCamundaException: Request failed: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')\n\npycamunda\\externaltask.py:112: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 30,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 37,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\externaltask.py",
          "lineno": 112,
          "message": "pycamunda.PyCamundaException: Request failed: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_getlist.py",
            "lineno": 43,
            "message": ""
          },
          {
            "path": "pycamunda\\externaltask.py",
            "lineno": 283,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\externaltask.py",
            "lineno": 112,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "url = 'http://localhost/engine-rest/external-task', method = 'GET', data = None\n\n    def _perform_request(url: str, method: str = 'GET', data: typing.Optional[dict] = None) -> str:\n        \"\"\"Helper function to perform HTTP requests using pycurl.\"\"\"\n        buffer = BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.URL, url)\n        curl.setopt(pycurl.WRITEDATA, buffer)\n        curl.setopt(pycurl.CUSTOMREQUEST, method)\n    \n        if method == 'POST' and data is not None:\n            curl.setopt(pycurl.POSTFIELDS, json.dumps(data))\n            curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n        try:\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\externaltask.py:110: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200234371504'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.externaltask.ExternalTask', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_tasks = pycamunda.externaltask.GetList(url=engine_url)\n>       get_tasks()\n\ntests\\externaltask\\test_getlist.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\externaltask.py:283: in __call__\n    response = _perform_request(self.url, method='GET')\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nurl = 'http://localhost/engine-rest/external-task', method = 'GET', data = None\n\n    def _perform_request(url: str, method: str = 'GET', data: typing.Optional[dict] = None) -> str:\n        \"\"\"Helper function to perform HTTP requests using pycurl.\"\"\"\n        buffer = BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.URL, url)\n        curl.setopt(pycurl.WRITEDATA, buffer)\n        curl.setopt(pycurl.CUSTOMREQUEST, method)\n    \n        if method == 'POST' and data is not None:\n            curl.setopt(pycurl.POSTFIELDS, json.dumps(data))\n            curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n        try:\n            curl.perform()\n        except pycurl.error as e:\n>           raise pycamunda.PyCamundaException(f\"Request failed: {e}\")\nE           pycamunda.PyCamundaException: Request failed: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\externaltask.py:112: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_getlist.py::test_getlist_returns_tuple",
      "lineno": 47,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_tuple",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\externaltask.py",
          "lineno": 112,
          "message": "pycamunda.PyCamundaException: Request failed: (7, 'Failed to connect to localhost port 80 after 2360 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_getlist.py",
            "lineno": 52,
            "message": ""
          },
          {
            "path": "pycamunda\\externaltask.py",
            "lineno": 283,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\externaltask.py",
            "lineno": 112,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "url = 'http://localhost/engine-rest/external-task', method = 'GET', data = None\n\n    def _perform_request(url: str, method: str = 'GET', data: typing.Optional[dict] = None) -> str:\n        \"\"\"Helper function to perform HTTP requests using pycurl.\"\"\"\n        buffer = BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.URL, url)\n        curl.setopt(pycurl.WRITEDATA, buffer)\n        curl.setopt(pycurl.CUSTOMREQUEST, method)\n    \n        if method == 'POST' and data is not None:\n            curl.setopt(pycurl.POSTFIELDS, json.dumps(data))\n            curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n        try:\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2360 ms: Could not connect to server')\n\npycamunda\\externaltask.py:110: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.externaltask.ExternalTask', unittest.mock.MagicMock())\n    def test_getlist_returns_tuple(engine_url):\n        get_tasks = pycamunda.externaltask.GetList(url=engine_url)\n>       tasks = get_tasks()\n\ntests\\externaltask\\test_getlist.py:52: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\externaltask.py:283: in __call__\n    response = _perform_request(self.url, method='GET')\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nurl = 'http://localhost/engine-rest/external-task', method = 'GET', data = None\n\n    def _perform_request(url: str, method: str = 'GET', data: typing.Optional[dict] = None) -> str:\n        \"\"\"Helper function to perform HTTP requests using pycurl.\"\"\"\n        buffer = BytesIO()\n        curl = pycurl.Curl()\n        curl.setopt(pycurl.URL, url)\n        curl.setopt(pycurl.WRITEDATA, buffer)\n        curl.setopt(pycurl.CUSTOMREQUEST, method)\n    \n        if method == 'POST' and data is not None:\n            curl.setopt(pycurl.POSTFIELDS, json.dumps(data))\n            curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n        try:\n            curl.perform()\n        except pycurl.error as e:\n>           raise pycamunda.PyCamundaException(f\"Request failed: {e}\")\nE           pycamunda.PyCamundaException: Request failed: (7, 'Failed to connect to localhost port 80 after 2360 ms: Could not connect to server')\n\npycamunda\\externaltask.py:112: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_handlebpmnerror.py::test_handlebpmnerror_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_handlebpmnerror_params",
        "test_handlebpmnerror.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_handlebpmnerror.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleBPMNError'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_handlebpmnerror.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_handlebpmnerror_params(engine_url):\n>       handle_error = pycamunda.externaltask.HandleBPMNError(\n            url=engine_url,\n            worker_id='1',\n            id_='anId',\n            error_code='anErrorCode',\n            error_message='anErrorMessage'\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleBPMNError'\n\ntests\\externaltask\\test_handlebpmnerror.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_handlebpmnerror.py::test_handlebpmnerror_calls_requests",
      "lineno": 30,
      "outcome": "failed",
      "keywords": [
        "test_handlebpmnerror_calls_requests",
        "__wrapped__",
        "patchings",
        "test_handlebpmnerror.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_handlebpmnerror.py",
          "lineno": 33,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleBPMNError'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_handlebpmnerror.py",
            "lineno": 33,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200232904496'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_handlebpmnerror_calls_requests(mock, engine_url):\n>       handle_error = pycamunda.externaltask.HandleBPMNError(\n            url=engine_url, worker_id='1', id_='anId', error_code='anErrorCode'\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleBPMNError'\n\ntests\\externaltask\\test_handlebpmnerror.py:33: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_handlebpmnerror.py::test_handlebpmnerror_raises_pycamunda_exception",
      "lineno": 41,
      "outcome": "failed",
      "keywords": [
        "test_handlebpmnerror_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_handlebpmnerror.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_handlebpmnerror.py",
          "lineno": 44,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleBPMNError'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_handlebpmnerror.py",
            "lineno": 44,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_handlebpmnerror_raises_pycamunda_exception(engine_url):\n>       handle_error = pycamunda.externaltask.HandleBPMNError(\n            url=engine_url, worker_id='1', id_='anId', error_code='anErrorCode'\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleBPMNError'\n\ntests\\externaltask\\test_handlebpmnerror.py:44: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_handlebpmnerror.py::test_handlebpmnerror_raises_for_status",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_handlebpmnerror_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_handlebpmnerror.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_handlebpmnerror.py",
          "lineno": 54,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleBPMNError'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_handlebpmnerror.py",
            "lineno": 54,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200233936688'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_handlebpmnerror_raises_for_status(mock, engine_url):\n>       handle_error = pycamunda.externaltask.HandleBPMNError(\n            url=engine_url, worker_id='1', id_='anId', error_code='anErrorCode'\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleBPMNError'\n\ntests\\externaltask\\test_handlebpmnerror.py:54: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_handlebpmnerror.py::test_handlebpmnerror_returns_none",
      "lineno": 61,
      "outcome": "failed",
      "keywords": [
        "test_handlebpmnerror_returns_none",
        "__wrapped__",
        "patchings",
        "test_handlebpmnerror.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_handlebpmnerror.py",
          "lineno": 64,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleBPMNError'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_handlebpmnerror.py",
            "lineno": 64,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_handlebpmnerror_returns_none(engine_url):\n>       handle_error = pycamunda.externaltask.HandleBPMNError(\n            url=engine_url, worker_id='1', id_='anId', error_code='anErrorCode'\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleBPMNError'\n\ntests\\externaltask\\test_handlebpmnerror.py:64: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_handlefailure.py::test_handlefailure_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_handlefailure_params",
        "test_handlefailure.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_handlefailure.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleFailure'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_handlefailure.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_handlefailure_params(engine_url):\n>       handle_failure = pycamunda.externaltask.HandleFailure(\n            url=engine_url,\n            worker_id='1',\n            id_='anId',\n            error_message='anErrorMessage',\n            error_details='anErrorDetail',\n            retries=1,\n            retry_timeout=10000\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleFailure'\n\ntests\\externaltask\\test_handlefailure.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_handlefailure.py::test_handlefailure_calls_requests",
      "lineno": 32,
      "outcome": "failed",
      "keywords": [
        "test_handlefailure_calls_requests",
        "__wrapped__",
        "patchings",
        "test_handlefailure.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_handlefailure.py",
          "lineno": 35,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleFailure'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_handlefailure.py",
            "lineno": 35,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200233124352'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_handlefailure_calls_requests(mock, engine_url):\n>       handle_failure = pycamunda.externaltask.HandleFailure(\n            url=engine_url,\n            worker_id='1',\n            id_='anId',\n            error_message='anErrorMessage',\n            error_details='anErrorDetail',\n            retries=1,\n            retry_timeout=10000\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleFailure'\n\ntests\\externaltask\\test_handlefailure.py:35: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_handlefailure.py::test_handlefailure_raises_pycamunda_exception",
      "lineno": 49,
      "outcome": "failed",
      "keywords": [
        "test_handlefailure_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_handlefailure.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_handlefailure.py",
          "lineno": 52,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleFailure'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_handlefailure.py",
            "lineno": 52,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_handlefailure_raises_pycamunda_exception(engine_url):\n>       handle_failure = pycamunda.externaltask.HandleFailure(\n            url=engine_url,\n            worker_id='1',\n            id_='anId',\n            error_message='anErrorMessage',\n            error_details='anErrorDetail',\n            retries=1,\n            retry_timeout=10000\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleFailure'\n\ntests\\externaltask\\test_handlefailure.py:52: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_handlefailure.py::test_handlefailure_raises_for_status",
      "lineno": 64,
      "outcome": "failed",
      "keywords": [
        "test_handlefailure_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_handlefailure.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_handlefailure.py",
          "lineno": 68,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleFailure'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_handlefailure.py",
            "lineno": 68,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200231327504'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_handlefailure_raises_for_status(mock, engine_url):\n>       handle_failure = pycamunda.externaltask.HandleFailure(\n            url=engine_url,\n            worker_id='1',\n            id_='anId',\n            error_message='anErrorMessage',\n            error_details='anErrorDetail',\n            retries=1,\n            retry_timeout=10000\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleFailure'\n\ntests\\externaltask\\test_handlefailure.py:68: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_handlefailure.py::test_handlefailure_returns_none",
      "lineno": 81,
      "outcome": "failed",
      "keywords": [
        "test_handlefailure_returns_none",
        "__wrapped__",
        "patchings",
        "test_handlefailure.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_handlefailure.py",
          "lineno": 84,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleFailure'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_handlefailure.py",
            "lineno": 84,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_handlefailure_returns_none(engine_url):\n>       handle_failure = pycamunda.externaltask.HandleFailure(\n            url=engine_url,\n            worker_id='1',\n            id_='anId',\n            error_message='anErrorMessage',\n            error_details='anErrorDetail',\n            retries=1,\n            retry_timeout=10000\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'HandleFailure'\n\ntests\\externaltask\\test_handlefailure.py:84: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "failed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_module.py",
          "lineno": 8,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Count'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_module.py",
            "lineno": 8,
            "message": "AttributeError"
          }
        ],
        "longrepr": "def test_all_contains_only_valid_names():\n        import pycamunda.externaltask\n    \n        for name in pycamunda.externaltask.__all__:\n>           getattr(pycamunda.externaltask, name)\nE           AttributeError: module 'pycamunda.externaltask' has no attribute 'Count'\n\ntests\\externaltask\\test_module.py:8: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setpriority.py::test_setpriority_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_setpriority_params",
        "test_setpriority.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setpriority.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetPriority'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setpriority.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_setpriority_params(engine_url):\n>       set_priority = pycamunda.externaltask.SetPriority(url=engine_url, id_='anId', priority=10)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetPriority'\n\ntests\\externaltask\\test_setpriority.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setpriority.py::test_setpriority_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_setpriority_calls_requests",
        "__wrapped__",
        "patchings",
        "test_setpriority.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setpriority.py",
          "lineno": 21,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetPriority'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setpriority.py",
            "lineno": 21,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200202978368'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_setpriority_calls_requests(mock, engine_url):\n>       set_priority = pycamunda.externaltask.SetPriority(url=engine_url, id_='anId', priority=10)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetPriority'\n\ntests\\externaltask\\test_setpriority.py:21: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setpriority.py::test_setpriority_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "failed",
      "keywords": [
        "test_setpriority_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_setpriority.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setpriority.py",
          "lineno": 30,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetPriority'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setpriority.py",
            "lineno": 30,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_setpriority_raises_pycamunda_exception(engine_url):\n>       set_priority = pycamunda.externaltask.SetPriority(url=engine_url, id_='anId', priority=10)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetPriority'\n\ntests\\externaltask\\test_setpriority.py:30: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setpriority.py::test_setpriority_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_setpriority_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_setpriority.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setpriority.py",
          "lineno": 38,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetPriority'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setpriority.py",
            "lineno": 38,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200231597376'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_setpriority_raises_for_status(mock, engine_url):\n>       set_priority = pycamunda.externaltask.SetPriority(url=engine_url, id_='anId', priority=10)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetPriority'\n\ntests\\externaltask\\test_setpriority.py:38: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setpriority.py::test_setpriority_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_setpriority_returns_none",
        "__wrapped__",
        "patchings",
        "test_setpriority.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setpriority.py",
          "lineno": 46,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetPriority'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setpriority.py",
            "lineno": 46,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_setpriority_returns_none(engine_url):\n>       set_priority = pycamunda.externaltask.SetPriority(url=engine_url, id_='anId', priority=10)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetPriority'\n\ntests\\externaltask\\test_setpriority.py:46: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretries.py::test_setretries_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_setretries_params",
        "test_setretries.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretries.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetries'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretries.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_setretries_params(engine_url):\n>       set_retries = pycamunda.externaltask.SetRetries(url=engine_url, id_='anId', retries=10)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetries'\n\ntests\\externaltask\\test_setretries.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretries.py::test_setretries_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_setretries_calls_requests",
        "__wrapped__",
        "patchings",
        "test_setretries.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretries.py",
          "lineno": 21,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetries'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretries.py",
            "lineno": 21,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200231333936'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_setretries_calls_requests(mock, engine_url):\n>       set_retries = pycamunda.externaltask.SetRetries(url=engine_url, id_='anId', retries=10)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetries'\n\ntests\\externaltask\\test_setretries.py:21: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretries.py::test_setretries_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "failed",
      "keywords": [
        "test_setretries_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_setretries.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretries.py",
          "lineno": 30,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetries'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretries.py",
            "lineno": 30,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_setretries_raises_pycamunda_exception(engine_url):\n>       set_retries = pycamunda.externaltask.SetRetries(url=engine_url, id_='anId', retries=10)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetries'\n\ntests\\externaltask\\test_setretries.py:30: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretries.py::test_setretries_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_setretries_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_setretries.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretries.py",
          "lineno": 38,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetries'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretries.py",
            "lineno": 38,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200233126272'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_setretries_raises_for_status(mock, engine_url):\n>       set_retries = pycamunda.externaltask.SetRetries(url=engine_url, id_='anId', retries=10)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetries'\n\ntests\\externaltask\\test_setretries.py:38: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretries.py::test_setretries_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_setretries_returns_none",
        "__wrapped__",
        "patchings",
        "test_setretries.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretries.py",
          "lineno": 46,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetries'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretries.py",
            "lineno": 46,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_setretries_returns_none(engine_url):\n>       set_retries = pycamunda.externaltask.SetRetries(url=engine_url, id_='anId', retries=10)\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetries'\n\ntests\\externaltask\\test_setretries.py:46: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretriesasync.py::test_setretriesasync_params",
      "lineno": 11,
      "outcome": "failed",
      "keywords": [
        "test_setretriesasync_params",
        "test_setretriesasync.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretriesasync.py",
          "lineno": 13,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesAsync'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretriesasync.py",
            "lineno": 13,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_setretriesasync_params(engine_url):\n>       set_retries = pycamunda.externaltask.SetRetriesAsync(\n            url=engine_url, external_task_ids=['anId'], retries=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesAsync'\n\ntests\\externaltask\\test_setretriesasync.py:13: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretriesasync.py::test_setretriesasync_calls_requests",
      "lineno": 32,
      "outcome": "failed",
      "keywords": [
        "test_setretriesasync_calls_requests",
        "__wrapped__",
        "patchings",
        "test_setretriesasync.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretriesasync.py",
          "lineno": 35,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesAsync'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretriesasync.py",
            "lineno": 35,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200231208576'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_setretriesasync_calls_requests(mock, engine_url):\n>       set_retries = pycamunda.externaltask.SetRetriesAsync(\n            url=engine_url, external_task_ids=['anId'], retries=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesAsync'\n\ntests\\externaltask\\test_setretriesasync.py:35: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretriesasync.py::test_setretriesasync_raises_pycamunda_exception",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_setretriesasync_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_setretriesasync.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretriesasync.py",
          "lineno": 46,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesAsync'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretriesasync.py",
            "lineno": 46,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_setretriesasync_raises_pycamunda_exception(engine_url):\n>       set_retries = pycamunda.externaltask.SetRetriesAsync(\n            url=engine_url, external_task_ids=['anId'], retries=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesAsync'\n\ntests\\externaltask\\test_setretriesasync.py:46: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretriesasync.py::test_setretriesasync_raises_for_status",
      "lineno": 52,
      "outcome": "failed",
      "keywords": [
        "test_setretriesasync_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_setretriesasync.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretriesasync.py",
          "lineno": 57,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesAsync'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretriesasync.py",
            "lineno": 57,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200233454048'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.batch.Batch', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_setretriesasync_raises_for_status(mock, engine_url):\n>       set_retries = pycamunda.externaltask.SetRetriesAsync(\n            url=engine_url, external_task_ids=['anId'], retries=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesAsync'\n\ntests\\externaltask\\test_setretriesasync.py:57: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretriesasync.py::test_setretriesasync_returns_batch",
      "lineno": 64,
      "outcome": "failed",
      "keywords": [
        "test_setretriesasync_returns_batch",
        "__wrapped__",
        "patchings",
        "test_setretriesasync.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretriesasync.py",
          "lineno": 67,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesAsync'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretriesasync.py",
            "lineno": 67,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_setretriesasync_returns_batch(engine_url):\n>       set_retries = pycamunda.externaltask.SetRetriesAsync(\n            url=engine_url, external_task_ids=['anId'], retries=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesAsync'\n\ntests\\externaltask\\test_setretriesasync.py:67: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretriessync.py::test_setretriessync_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_setretriessync_params",
        "test_setretriessync.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretriessync.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesSync'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretriessync.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_setretriessync_params(engine_url):\n>       set_retries = pycamunda.externaltask.SetRetriesSync(\n            url=engine_url, external_task_ids=['anId'], retries=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesSync'\n\ntests\\externaltask\\test_setretriessync.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretriessync.py::test_setretriessync_calls_requests",
      "lineno": 31,
      "outcome": "failed",
      "keywords": [
        "test_setretriessync_calls_requests",
        "__wrapped__",
        "patchings",
        "test_setretriessync.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretriessync.py",
          "lineno": 34,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesSync'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretriessync.py",
            "lineno": 34,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200231687712'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_setretriessync_calls_requests(mock, engine_url):\n>       set_retries = pycamunda.externaltask.SetRetriesSync(\n            url=engine_url, external_task_ids=['anId'], retries=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesSync'\n\ntests\\externaltask\\test_setretriessync.py:34: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretriessync.py::test_setretriessync_raises_pycamunda_exception",
      "lineno": 42,
      "outcome": "failed",
      "keywords": [
        "test_setretriessync_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_setretriessync.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretriessync.py",
          "lineno": 45,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesSync'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretriessync.py",
            "lineno": 45,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_setretriessync_raises_pycamunda_exception(engine_url):\n>       set_retries = pycamunda.externaltask.SetRetriesSync(\n            url=engine_url, external_task_ids=['anId'], retries=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesSync'\n\ntests\\externaltask\\test_setretriessync.py:45: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretriessync.py::test_setretriessync_raises_for_status",
      "lineno": 51,
      "outcome": "failed",
      "keywords": [
        "test_setretriessync_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_setretriessync.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretriessync.py",
          "lineno": 55,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesSync'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretriessync.py",
            "lineno": 55,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200231697408'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_setretriessync_raises_for_status(mock, engine_url):\n>       set_retries = pycamunda.externaltask.SetRetriesSync(\n            url=engine_url, external_task_ids=['anId'], retries=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesSync'\n\ntests\\externaltask\\test_setretriessync.py:55: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_setretriessync.py::test_setretriessync_returns_none",
      "lineno": 62,
      "outcome": "failed",
      "keywords": [
        "test_setretriessync_returns_none",
        "__wrapped__",
        "patchings",
        "test_setretriessync.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_setretriessync.py",
          "lineno": 65,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesSync'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_setretriessync.py",
            "lineno": 65,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_setretriessync_returns_none(engine_url):\n>       set_retries = pycamunda.externaltask.SetRetriesSync(\n            url=engine_url, external_task_ids=['anId'], retries=10\n        )\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'SetRetriesSync'\n\ntests\\externaltask\\test_setretriessync.py:65: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_unlock.py::test_unlock_params",
      "lineno": 10,
      "outcome": "failed",
      "keywords": [
        "test_unlock_params",
        "test_unlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_unlock.py",
          "lineno": 12,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Unlock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_unlock.py",
            "lineno": 12,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    def test_unlock_params(engine_url):\n>       unlock_task = pycamunda.externaltask.Unlock(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Unlock'\n\ntests\\externaltask\\test_unlock.py:12: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_unlock.py::test_unlock_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_unlock_calls_requests",
        "__wrapped__",
        "patchings",
        "test_unlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_unlock.py",
          "lineno": 21,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Unlock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_unlock.py",
            "lineno": 21,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='request' id='3200203118192'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_unlock_calls_requests(mock, engine_url):\n>       unlock_task = pycamunda.externaltask.Unlock(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Unlock'\n\ntests\\externaltask\\test_unlock.py:21: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_unlock.py::test_unlock_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "failed",
      "keywords": [
        "test_unlock_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_unlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_unlock.py",
          "lineno": 30,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Unlock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_unlock.py",
            "lineno": 30,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', raise_requests_exception_mock)\n    def test_unlock_raises_pycamunda_exception(engine_url):\n>       unlock_task = pycamunda.externaltask.Unlock(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Unlock'\n\ntests\\externaltask\\test_unlock.py:30: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_unlock.py::test_unlock_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_unlock_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_unlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_unlock.py",
          "lineno": 38,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Unlock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_unlock.py",
            "lineno": 38,
            "message": "AttributeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200231594832'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_unlock_raises_for_status(mock, engine_url):\n>       unlock_task = pycamunda.externaltask.Unlock(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Unlock'\n\ntests\\externaltask\\test_unlock.py:38: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/externaltask/test_unlock.py::test_unlock_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_unlock_returns_none",
        "__wrapped__",
        "patchings",
        "test_unlock.py",
        "externaltask",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\tests\\externaltask\\test_unlock.py",
          "lineno": 46,
          "message": "AttributeError: module 'pycamunda.externaltask' has no attribute 'Unlock'"
        },
        "traceback": [
          {
            "path": "tests\\externaltask\\test_unlock.py",
            "lineno": 46,
            "message": "AttributeError"
          }
        ],
        "longrepr": "engine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_unlock_returns_none(engine_url):\n>       unlock_task = pycamunda.externaltask.Unlock(url=engine_url, id_='anId')\nE       AttributeError: module 'pycamunda.externaltask' has no attribute 'Unlock'\n\ntests\\externaltask\\test_unlock.py:46: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_count.py::test_count_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_count_params",
        "test_count.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_count.py::test_count_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_count_calls_requests",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_count.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 175,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/filter/count', resource_type='Task')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CA9E660>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CA9E6B0>\nquery_string = 'resourceType=Task'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200233236928'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_count_calls_requests(mock, engine_url):\n        count_filters = pycamunda.filter.Count(url=engine_url)\n>       count_filters()\n\ntests\\filter\\test_count.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:175: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/filter/count', resource_type='Task')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91A4DA7F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CA9E660>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CA9E6B0>\nquery_string = 'resourceType=Task'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_count.py::test_count_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_count_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_count.py::test_count_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_count_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_count.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 175,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/filter/count', resource_type='Task')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E919069440>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CAFB6F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CAFB4C0>\nquery_string = 'resourceType=Task'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200233127088'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_count_raises_for_status(mock, engine_url):\n        count_filters = pycamunda.filter.Count(url=engine_url)\n>       count_filters()\n\ntests\\filter\\test_count.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:175: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/filter/count', resource_type='Task')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E919069440>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CAFB6F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CAFB4C0>\nquery_string = 'resourceType=Task'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_count.py::test_count_returns_int",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_count_returns_int",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2431 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_count.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 175,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/filter/count', resource_type='Task')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E917518000>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CAFBAB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CAFB970>\nquery_string = 'resourceType=Task'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2431 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', count_response_mock)\n    def test_count_returns_int(engine_url):\n        count_filters = pycamunda.filter.Count(url=engine_url)\n>       result = count_filters()\n\ntests\\filter\\test_count.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:175: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/filter/count', resource_type='Task')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E917518000>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CAFBAB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CAFB970>\nquery_string = 'resourceType=Task'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2431 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_create.py::test_create_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_create_params",
        "test_create.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_create.py::test_create_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_create_calls_requests",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2220 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_create.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 585,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 562,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/filter/create', resource_type='Task', name='aName', owner='anOwner')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB2C6D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB2D6C0>\nbody = '{\"query\": {}, \"resourceType\": \"Task\", \"name\": \"aName\", \"owner\": \"anOwner\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2220 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231330576'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_create_calls_requests(mock, engine_url):\n        create_filter = pycamunda.filter.Create(url=engine_url, name='aName', owner='anOwner')\n>       create_filter()\n\ntests\\filter\\test_create.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:585: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\npycamunda\\filter.py:562: in __call__\n    return super().__call__(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/filter/create', resource_type='Task', name='aName', owner='anOwner')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB2C6D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB2D6C0>\nbody = '{\"query\": {}, \"resourceType\": \"Task\", \"name\": \"aName\", \"owner\": \"anOwner\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2220 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_create.py::test_create_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_create_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_create.py::test_create_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_create_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 50,
          "message": "TypeError: functions are not supported for this option"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_create.py",
            "lineno": 42,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 585,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 562,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 50,
            "message": "TypeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200231327600'>\nengine_url = <MagicMock name='Filter' id='3200233228768'>\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.filter.Filter')\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_create_raises_for_status(mock, engine_url):\n        create_filter = pycamunda.filter.Create(url=engine_url, name='aName', owner='anOwner')\n>       create_filter()\n\ntests\\filter\\test_create.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:585: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\npycamunda\\filter.py:562: in __call__\n    return super().__call__(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url=<MagicMock name='Filter.__add__().__add__().format().rstrip()' id='3200231815264'>, resource_type='Task', name='aName', owner='anOwner')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB2E2A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB2E430>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n>           curl.setopt(pycurl.URL, self.url)\nE           TypeError: functions are not supported for this option\n\npycamunda\\base.py:50: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_create.py::test_create_returns_filter",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_create_returns_filter",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2477 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_create.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 585,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 562,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/filter/create', resource_type='Task', name='aName', owner='anOwner')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB2EC00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB2ED40>\nbody = '{\"query\": {}, \"resourceType\": \"Task\", \"name\": \"aName\", \"owner\": \"anOwner\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2477 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_create_returns_filter(engine_url):\n        create_filter = pycamunda.filter.Create(url=engine_url, name='aName', owner='anOwner')\n>       filter_ = create_filter()\n\ntests\\filter\\test_create.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:585: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\npycamunda\\filter.py:562: in __call__\n    return super().__call__(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/filter/create', resource_type='Task', name='aName', owner='anOwner')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB2EC00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB2ED40>\nbody = '{\"query\": {}, \"resourceType\": \"Task\", \"name\": \"aName\", \"owner\": \"anOwner\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2477 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_criteria.py::test_criteria_params_process_instance_criteria",
      "lineno": 8,
      "outcome": "passed",
      "keywords": [
        "test_criteria_params_process_instance_criteria",
        "test_criteria.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_criteria.py::test_criteria_params_process_definition_criteria",
      "lineno": 19,
      "outcome": "passed",
      "keywords": [
        "test_criteria_params_process_definition_criteria",
        "test_criteria.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_criteria.py::test_criteria_params_case_instance_criteria",
      "lineno": 32,
      "outcome": "passed",
      "keywords": [
        "test_criteria_params_case_instance_criteria",
        "test_criteria.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_criteria.py::test_criteria_params_case_definition_criteria",
      "lineno": 43,
      "outcome": "passed",
      "keywords": [
        "test_criteria_params_case_definition_criteria",
        "test_criteria.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_criteria.py::test_criteria_params_other_criteria",
      "lineno": 55,
      "outcome": "passed",
      "keywords": [
        "test_criteria_params_other_criteria",
        "test_criteria.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_criteria.py::test_criteria_params_user_criteria",
      "lineno": 66,
      "outcome": "passed",
      "keywords": [
        "test_criteria_params_user_criteria",
        "test_criteria.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_criteria.py::test_criteria_params_task_criteria",
      "lineno": 89,
      "outcome": "passed",
      "keywords": [
        "test_criteria_params_task_criteria",
        "test_criteria.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_criteria.py::test_criteria_params_datetime_criteria",
      "lineno": 120,
      "outcome": "passed",
      "keywords": [
        "test_criteria_params_datetime_criteria",
        "test_criteria.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_delete.py::test_delete_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_delete_params",
        "test_delete.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_delete.py::test_delete_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_delete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_delete.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 631,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/filter/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB05530>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB05580>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200232174800'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_delete_calls_requests(mock, engine_url):\n        delete_filter = pycamunda.filter.Delete(url=engine_url, id_='anId')\n>       delete_filter()\n\ntests\\filter\\test_delete.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:631: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/filter/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB05530>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB05580>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_delete.py::test_delete_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_delete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_delete.py::test_delete_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_delete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_delete.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 631,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/filter/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB05C10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB06980>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200232132528'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_delete_raises_for_status(mock, engine_url):\n        delete_filter = pycamunda.filter.Delete(url=engine_url, id_='anId')\n>       delete_filter()\n\ntests\\filter\\test_delete.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:631: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/filter/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB05C10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB06980>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_delete.py::test_delete_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_delete_returns_none",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_delete.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 631,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/filter/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CDF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB2DFD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB2DEE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_delete_returns_none(engine_url):\n        delete_filter = pycamunda.filter.Delete(url=engine_url, id_='anId')\n>       result = delete_filter()\n\ntests\\filter\\test_delete.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:631: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/filter/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CDF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB2DFD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB2DEE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_execute.py::test_execute_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_execute_params",
        "test_execute.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_execute.py::test_execute_params_single_reuslt",
      "lineno": 19,
      "outcome": "passed",
      "keywords": [
        "test_execute_params_single_reuslt",
        "test_execute.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_execute.py::test_execute_calls_requests",
      "lineno": 27,
      "outcome": "failed",
      "keywords": [
        "test_execute_calls_requests",
        "__wrapped__",
        "patchings",
        "test_execute.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2260 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_execute.py",
            "lineno": 31,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 662,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 562,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Execute(url='http://localhost/engine-rest/filter/anId/list', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB07D80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB07DD0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2260 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200232169760'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_execute_calls_requests(mock, engine_url):\n        execute_filter = pycamunda.filter.Execute(url=engine_url, id_='anId')\n>       execute_filter()\n\ntests\\filter\\test_execute.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:662: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\npycamunda\\filter.py:562: in __call__\n    return super().__call__(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Execute(url='http://localhost/engine-rest/filter/anId/list', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB07D80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB07DD0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2260 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_execute.py::test_execute_calls_requests_post",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_execute_calls_requests_post",
        "__wrapped__",
        "patchings",
        "test_execute.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2450 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_execute.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 660,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 562,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Execute(url='http://localhost/engine-rest/filter/anId/list', priority=1, id_='anId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB18360>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB19030>\nbody = '{\"priority\": 1}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2450 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200233114512'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_execute_calls_requests_post(mock, engine_url):\n        execute_filter = pycamunda.filter.Execute(url=engine_url, id_='anId')\n        execute_filter.priority = 1\n>       execute_filter()\n\ntests\\filter\\test_execute.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:660: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\npycamunda\\filter.py:562: in __call__\n    return super().__call__(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Execute(url='http://localhost/engine-rest/filter/anId/list', priority=1, id_='anId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB18360>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB19030>\nbody = '{\"priority\": 1}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2450 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_execute.py::test_execute_raises_pycamunda_exception",
      "lineno": 45,
      "outcome": "passed",
      "keywords": [
        "test_execute_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_execute.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_execute.py::test_execute_raises_for_status",
      "lineno": 52,
      "outcome": "failed",
      "keywords": [
        "test_execute_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_execute.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 50,
          "message": "TypeError: functions are not supported for this option"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_execute.py",
            "lineno": 58,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 662,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 562,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 50,
            "message": "TypeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200231816896'>\nengine_url = <MagicMock name='Task' id='3200231815312'>\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.task.Task')\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_execute_raises_for_status(mock, engine_url):\n        execute_filter = pycamunda.filter.Execute(url=engine_url, id_='anId')\n>       execute_filter()\n\ntests\\filter\\test_execute.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:662: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\npycamunda\\filter.py:562: in __call__\n    return super().__call__(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Execute(url=<MagicMock name='Task.__add__().__add__().format().rstrip().__add__()' id='3200231828912'>, id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB1A7A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB1A8E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n>           curl.setopt(pycurl.URL, self.url)\nE           TypeError: functions are not supported for this option\n\npycamunda\\base.py:50: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_execute.py::test_execute_returns_tasks",
      "lineno": 62,
      "outcome": "failed",
      "keywords": [
        "test_execute_returns_tasks",
        "__wrapped__",
        "patchings",
        "test_execute.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2371 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_execute.py",
            "lineno": 66,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 662,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 562,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Execute(url='http://localhost/engine-rest/filter/anId/list', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB1BA10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB1A930>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2371 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_execute_returns_tasks(engine_url):\n        execute_filter = pycamunda.filter.Execute(url=engine_url, id_='anId')\n>       tasks = execute_filter()\n\ntests\\filter\\test_execute.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:662: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\npycamunda\\filter.py:562: in __call__\n    return super().__call__(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Execute(url='http://localhost/engine-rest/filter/anId/list', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB1BA10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB1A930>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2371 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_execute.py::test_execute_returns_task",
      "lineno": 71,
      "outcome": "failed",
      "keywords": [
        "test_execute_returns_task",
        "__wrapped__",
        "patchings",
        "test_execute.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2438 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_execute.py",
            "lineno": 76,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 662,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 562,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Execute(url='http://localhost/engine-rest/filter/anId/singleResult', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB1BF10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB1BB50>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2438 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    def test_execute_returns_task(engine_url):\n        execute_filter = pycamunda.filter.Execute(url=engine_url, id_='anId', single_result=True)\n>       task = execute_filter()\n\ntests\\filter\\test_execute.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:662: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\npycamunda\\filter.py:562: in __call__\n    return super().__call__(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Execute(url='http://localhost/engine-rest/filter/anId/singleResult', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB1BF10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB1BB50>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2438 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_executecount.py::test_executecount_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_executecount_params",
        "test_executecount.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_executecount.py::test_executecount_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_executecount_calls_requests",
        "__wrapped__",
        "patchings",
        "test_executecount.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2220 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_executecount.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 684,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = ExecuteCount(url='http://localhost/engine-rest/filter/anId/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D270>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEC8950>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CECBEC0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2220 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200232173360'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_executecount_calls_requests(mock, engine_url):\n        get_filter_count = pycamunda.filter.ExecuteCount(url=engine_url, id_='anId')\n>       get_filter_count()\n\ntests\\filter\\test_executecount.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:684: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ExecuteCount(url='http://localhost/engine-rest/filter/anId/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D270>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEC8950>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CECBEC0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2220 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_executecount.py::test_executecount_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_executecount_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_executecount.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_executecount.py::test_executecount_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_executecount_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_executecount.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_executecount.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 684,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = ExecuteCount(url='http://localhost/engine-rest/filter/anId/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CECAB10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEC9BC0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200232179040'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_executecount_raises_for_status(mock, engine_url):\n        get_filter_count = pycamunda.filter.ExecuteCount(url=engine_url, id_='anId')\n>       get_filter_count()\n\ntests\\filter\\test_executecount.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:684: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ExecuteCount(url='http://localhost/engine-rest/filter/anId/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CECAB10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEC9BC0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_executecount.py::test_executecount_returns_int",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_executecount_returns_int",
        "__wrapped__",
        "patchings",
        "test_executecount.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2366 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_executecount.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 684,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = ExecuteCount(url='http://localhost/engine-rest/filter/anId/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEC9D50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CECAE30>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2366 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', count_response_mock)\n    def test_executecount_returns_int(engine_url):\n        get_filter_count = pycamunda.filter.ExecuteCount(url=engine_url, id_='anId')\n>       filter_ = get_filter_count()\n\ntests\\filter\\test_executecount.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:684: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ExecuteCount(url='http://localhost/engine-rest/filter/anId/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEC9D50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CECAE30>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2366 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_filter.py::test_filter_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_filter_load",
        "test_filter.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_filter.py::test_incident_load_raises_keyerror",
      "lineno": 19,
      "outcome": "passed",
      "keywords": [
        "test_incident_load_raises_keyerror",
        "test_filter.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_get.py::test_get_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2249 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_get.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 198,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/filter/anId', id_='anId', item_count=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE90DB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE90E00>\nquery_string = 'itemCount=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2249 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200233229344'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n        get_filter = pycamunda.filter.Get(url=engine_url, id_='anId', item_count=True)\n>       get_filter()\n\ntests\\filter\\test_get.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:198: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/filter/anId', id_='anId', item_count=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE90DB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE90E00>\nquery_string = 'itemCount=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2249 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_get.py::test_get_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2273 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_get.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 198,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/filter/anId', id_='anId', item_count=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE920C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE910D0>\nquery_string = 'itemCount=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2273 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200232193392'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.filter.Filter', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_filter = pycamunda.filter.Get(url=engine_url, id_='anId', item_count=True)\n>       get_filter()\n\ntests\\filter\\test_get.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:198: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/filter/anId', id_='anId', item_count=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE920C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE910D0>\nquery_string = 'itemCount=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2273 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_get.py::test_get_returns_filter",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_filter",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_get.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 198,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/filter/anId', id_='anId', item_count=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE92F20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE92A20>\nquery_string = 'itemCount=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_get_returns_filter(engine_url):\n        get_filter = pycamunda.filter.Get(url=engine_url, id_='anId', item_count=True)\n>       filter_ = get_filter()\n\ntests\\filter\\test_get.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:198: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/filter/anId', id_='anId', item_count=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE92F20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE92A20>\nquery_string = 'itemCount=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_getlist.py::test_getlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_getlist.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 137,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/filter', resource_type='Task', item_count=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AE70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB1B7E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB1BC90>\nquery_string = 'resourceType=Task&itemCount=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200232193536'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_filters = pycamunda.filter.GetList(url=engine_url)\n>       get_filters()\n\ntests\\filter\\test_getlist.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:137: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/filter', resource_type='Task', item_count=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AE70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB1B7E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB1BC90>\nquery_string = 'resourceType=Task&itemCount=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2272 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_getlist.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 137,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/filter', resource_type='Task', item_count=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C070>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB1A7F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB1A700>\nquery_string = 'resourceType=Task&itemCount=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2272 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231831024'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.filter.Filter', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_filters = pycamunda.filter.GetList(url=engine_url)\n>       get_filters()\n\ntests\\filter\\test_getlist.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:137: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/filter', resource_type='Task', item_count=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C070>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB1A7F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB1A700>\nquery_string = 'resourceType=Task&itemCount=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2272 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_getlist.py::test_getlist_returns_filter_tuple",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_filter_tuple",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2369 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_getlist.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 137,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/filter', resource_type='Task', item_count=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CDF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB184F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB1A110>\nquery_string = 'resourceType=Task&itemCount=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2369 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.filter.Filter', unittest.mock.MagicMock())\n    def test_getlist_returns_filter_tuple(engine_url):\n        get_filters = pycamunda.filter.GetList(url=engine_url)\n>       filters = get_filters()\n\ntests\\filter\\test_getlist.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:137: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/filter', resource_type='Task', item_count=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CDF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CB184F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CB1A110>\nquery_string = 'resourceType=Task&itemCount=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2369 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_options.py::test_options_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_options_params",
        "test_options.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_options.py::test_options_calls_requests",
      "lineno": 24,
      "outcome": "failed",
      "keywords": [
        "test_options_calls_requests",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_options.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 709,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/filter/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DB70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEFCEF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEFD030>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231818064'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_options_calls_requests(mock, engine_url):\n        get_options = pycamunda.filter.Options(url=engine_url, id_='anId')\n>       get_options()\n\ntests\\filter\\test_options.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:709: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/filter/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DB70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEFCEF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEFD030>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_options.py::test_options_raises_pycamunda_exception",
      "lineno": 33,
      "outcome": "passed",
      "keywords": [
        "test_options_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_options.py::test_options_raises_for_status",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_options_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_options.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 709,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/filter/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C2B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEFD620>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEFD8F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200232142656'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.resource.ResourceOptions', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_options_raises_for_status(mock, engine_url):\n        get_options = pycamunda.filter.Options(url=engine_url, id_='anId')\n>       get_options()\n\ntests\\filter\\test_options.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:709: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/filter/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C2B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEFD620>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEFD8F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_options.py::test_options_returns_resource_options",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_options_returns_resource_options",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_options.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 709,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/filter/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17F30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEFEA70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEFD8A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_options_returns_resource_options(engine_url):\n        get_options = pycamunda.filter.Options(url=engine_url, id_='anId')\n>       resource_options = get_options()\n\ntests\\filter\\test_options.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:709: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/filter/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17F30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEFEA70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEFD8A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_update.py::test_update_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_update_params",
        "test_update.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_update.py::test_update_calls_requests",
      "lineno": 22,
      "outcome": "failed",
      "keywords": [
        "test_update_calls_requests",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_update.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 613,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 562,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/filter/anId', id_='anId', resource_type='Task', name='aName', owner='anOwner')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18170>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEFE070>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEFFF10>\nbody = '{\"query\": {}, \"resourceType\": \"Task\", \"name\": \"aName\", \"owner\": \"anOwner\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231821616'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_update_calls_requests(mock, engine_url):\n        update_filter = pycamunda.filter.Update(\n            url=engine_url, id_='anId', name='aName', owner='anOwner'\n        )\n>       update_filter()\n\ntests\\filter\\test_update.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:613: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\npycamunda\\filter.py:562: in __call__\n    return super().__call__(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/filter/anId', id_='anId', resource_type='Task', name='aName', owner='anOwner')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18170>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEFE070>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEFFF10>\nbody = '{\"query\": {}, \"resourceType\": \"Task\", \"name\": \"aName\", \"owner\": \"anOwner\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_update.py::test_update_raises_pycamunda_exception",
      "lineno": 33,
      "outcome": "passed",
      "keywords": [
        "test_update_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_update.py::test_update_raises_for_status",
      "lineno": 42,
      "outcome": "failed",
      "keywords": [
        "test_update_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 50,
          "message": "TypeError: functions are not supported for this option"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_update.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 613,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 562,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 50,
            "message": "TypeError"
          }
        ],
        "longrepr": "mock = <MagicMock name='_raise_for_status' id='3200232136608'>\nengine_url = <MagicMock name='Filter' id='3200232136656'>\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.filter.Filter')\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_update_raises_for_status(mock, engine_url):\n        update_filter = pycamunda.filter.Update(\n            url=engine_url, id_='anId', name='aName', owner='anOwner'\n        )\n>       update_filter()\n\ntests\\filter\\test_update.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:613: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\npycamunda\\filter.py:562: in __call__\n    return super().__call__(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url=<MagicMock name='Filter.__add__().__add__().format().rstrip()' id='3200231603664'>, id_='anId', resource_type='Task', name='aName', owner='anOwner')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CDF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE4CC20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE4CD60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n>           curl.setopt(pycurl.URL, self.url)\nE           TypeError: functions are not supported for this option\n\npycamunda\\base.py:50: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/filter/test_update.py::test_update_returns_none",
      "lineno": 54,
      "outcome": "failed",
      "keywords": [
        "test_update_returns_none",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "filter",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\filter\\test_update.py",
            "lineno": 60,
            "message": ""
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 613,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\filter.py",
            "lineno": 562,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/filter/anId', id_='anId', resource_type='Task', name='aName', owner='anOwner')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE4D530>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE4D5D0>\nbody = '{\"query\": {}, \"resourceType\": \"Task\", \"name\": \"aName\", \"owner\": \"anOwner\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_update_returns_none(engine_url):\n        update_filter = pycamunda.filter.Update(\n            url=engine_url, id_='anId', name='aName', owner='anOwner'\n        )\n>       result = update_filter()\n\ntests\\filter\\test_update.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\filter.py:613: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\npycamunda\\filter.py:562: in __call__\n    return super().__call__(*args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/filter/anId', id_='anId', resource_type='Task', name='aName', owner='anOwner')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE4D530>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE4D5D0>\nbody = '{\"query\": {}, \"resourceType\": \"Task\", \"name\": \"aName\", \"owner\": \"anOwner\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_create.py::test_create_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_create_params",
        "test_create.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_create.py::test_create_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_create_calls_requests",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_create.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 155,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/group/create', id_='anId', name='aName', type_='aType')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18170>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE4E930>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE4ED90>\nbody = '{\"id\": \"anId\", \"name\": \"aName\", \"type\": \"aType\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231595504'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_create_calls_requests(mock, engine_url):\n        create_group = pycamunda.group.Create(url=engine_url, id_='anId', name='aName', type_='aType')\n>       create_group()\n\ntests\\group\\test_create.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:155: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/group/create', id_='anId', name='aName', type_='aType')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18170>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE4E930>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE4ED90>\nbody = '{\"id\": \"anId\", \"name\": \"aName\", \"type\": \"aType\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_create.py::test_create_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_create_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_create.py::test_create_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_create_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_create.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 155,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/group/create', id_='anId', name='aName', type_='aType')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE5C590>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE5C5E0>\nbody = '{\"id\": \"anId\", \"name\": \"aName\", \"type\": \"aType\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231701584'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_create_raises_for_status(mock, engine_url):\n        create_group = pycamunda.group.Create(url=engine_url, id_='anId', name='aName', type_='aType')\n>       create_group()\n\ntests\\group\\test_create.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:155: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/group/create', id_='anId', name='aName', type_='aType')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE5C590>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE5C5E0>\nbody = '{\"id\": \"anId\", \"name\": \"aName\", \"type\": \"aType\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_create.py::test_create_returns_none",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_create_returns_none",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_create.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 155,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/group/create', id_='anId', name='aName', type_='aType')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE5D0D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE5CB80>\nbody = '{\"id\": \"anId\", \"name\": \"aName\", \"type\": \"aType\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_create_returns_none(engine_url):\n        create_group = pycamunda.group.Create(url=engine_url, id_='anId', name='aName', type_='aType')\n>       result = create_group()\n\ntests\\group\\test_create.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:155: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/group/create', id_='anId', name='aName', type_='aType')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE5D0D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE5CB80>\nbody = '{\"id\": \"anId\", \"name\": \"aName\", \"type\": \"aType\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_delete.py::test_delete_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_delete_params",
        "test_delete.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_delete.py::test_delete_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_delete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2266 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_delete.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 226,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE5E750>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE5D8A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2266 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231816368'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_delete_calls_requests(mock, engine_url):\n        delete_group = pycamunda.group.Delete(url=engine_url, id_='anId')\n>       delete_group()\n\ntests\\group\\test_delete.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:226: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE5E750>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE5D8A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2266 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_delete.py::test_delete_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_delete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_delete.py::test_delete_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_delete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_delete.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 226,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE5FB50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE5ED40>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231807008'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_delete_raises_for_status(mock, engine_url):\n        delete_group = pycamunda.group.Delete(url=engine_url, id_='anId')\n>       delete_group()\n\ntests\\group\\test_delete.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:226: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE5FB50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE5ED40>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_delete.py::test_delete_returns_group",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_delete_returns_group",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_delete.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 226,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE5FE70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE5FEC0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_delete_returns_group(engine_url):\n        delete_group = pycamunda.group.Delete(url=engine_url, id_='anId')\n>       result = delete_group()\n\ntests\\group\\test_delete.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:226: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE5FE70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE5FEC0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_get.py::test_get_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2263 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_get.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 61,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF01260>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF01210>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2263 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231813920'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.group.Group.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n        get_group = pycamunda.group.Get(url=engine_url, id_='anId')\n>       get_group()\n\ntests\\group\\test_get.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:61: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF01260>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF01210>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2263 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_get.py::test_get_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_get.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 61,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF02430>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF012B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231600064'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.group.Group', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_group = pycamunda.group.Get(url=engine_url, id_='anId')\n>       get_group()\n\ntests\\group\\test_get.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:61: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF02430>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF012B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_get.py::test_get_returns_group",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_group",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_get.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 61,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17870>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF02E80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF033D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_get_returns_group(engine_url):\n        get_group = pycamunda.group.Get(url=engine_url, id_='anId')\n>       group = get_group()\n\ntests\\group\\test_get.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:61: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17870>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF02E80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF033D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_getlist.py::test_getlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_getlist.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 129,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/group')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE5F330>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE5F290>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231593296'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.group.Group.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_groups = pycamunda.group.GetList(url=engine_url)\n>       get_groups()\n\ntests\\group\\test_getlist.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:129: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/group')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE5F330>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE5F290>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_getlist.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 129,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/group')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEF1030>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEF1260>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231813872'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.group.Group', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_groups = pycamunda.group.GetList(url=engine_url)\n>       get_groups()\n\ntests\\group\\test_getlist.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:129: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/group')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEF1030>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEF1260>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_getlist.py::test_getlist_returns_incident",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_incident",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2269 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_getlist.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 129,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/group')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEF16C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEF2160>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2269 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getlist_returns_incident(engine_url):\n        get_groups = pycamunda.group.GetList(url=engine_url)\n>       groups = get_groups()\n\ntests\\group\\test_getlist.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:129: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/group')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEF16C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEF2160>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2269 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_group.py::test_group_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_group_load",
        "test_group.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_group.py::test_group_load_raises_keyerror",
      "lineno": 15,
      "outcome": "passed",
      "keywords": [
        "test_group_load_raises_keyerror",
        "test_group.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_membercreate.py::test_membercreate_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_membercreate_params",
        "test_membercreate.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_membercreate.py::test_membercreate_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_membercreate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_membercreate.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_membercreate.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 247,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = MemberCreate(url='http://localhost/engine-rest/group/anId/members/anUserId', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C070>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEF3740>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEF37E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200232580368'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_membercreate_calls_requests(mock, engine_url):\n        create_member = pycamunda.group.MemberCreate(url=engine_url, id_='anId', user_id='anUserId')\n>       create_member()\n\ntests\\group\\test_membercreate.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:247: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = MemberCreate(url='http://localhost/engine-rest/group/anId/members/anUserId', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C070>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CEF3740>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CEF37E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_membercreate.py::test_membercreate_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_membercreate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_membercreate.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_membercreate.py::test_membercreate_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_membercreate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_membercreate.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2263 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_membercreate.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 247,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = MemberCreate(url='http://localhost/engine-rest/group/anId/members/anUserId', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A0F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE88A90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE889A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2263 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200232908288'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_membercreate_raises_for_status(mock, engine_url):\n        create_member = pycamunda.group.MemberCreate(url=engine_url, id_='anId', user_id='anUserId')\n>       create_member()\n\ntests\\group\\test_membercreate.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:247: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = MemberCreate(url='http://localhost/engine-rest/group/anId/members/anUserId', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A0F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE88A90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE889A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2263 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_membercreate.py::test_membercreate_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_membercreate_returns_none",
        "__wrapped__",
        "patchings",
        "test_membercreate.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_membercreate.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 247,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = MemberCreate(url='http://localhost/engine-rest/group/anId/members/anUserId', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19EB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE88E00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE88D60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_membercreate_returns_none(engine_url):\n        create_member = pycamunda.group.MemberCreate(url=engine_url, id_='anId', user_id='anUserId')\n>       result = create_member()\n\ntests\\group\\test_membercreate.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:247: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = MemberCreate(url='http://localhost/engine-rest/group/anId/members/anUserId', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19EB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE88E00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE88D60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_memberdelete.py::test_memberdelete_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_memberdelete_params",
        "test_memberdelete.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_memberdelete.py::test_memberdelete_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_memberdelete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_memberdelete.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2246 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_memberdelete.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 268,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = MemberDelete(url='http://localhost/engine-rest/group/anId/members/anUserId', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CDF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE89170>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE89EE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2246 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231202576'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_memberdelete_calls_requests(mock, engine_url):\n        delete_member = pycamunda.group.MemberDelete(url=engine_url, id_='anId', user_id='anUserId')\n>       delete_member()\n\ntests\\group\\test_memberdelete.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:268: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = MemberDelete(url='http://localhost/engine-rest/group/anId/members/anUserId', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CDF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE89170>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE89EE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2246 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_memberdelete.py::test_memberdelete_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_memberdelete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_memberdelete.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_memberdelete.py::test_memberdelete_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_memberdelete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_memberdelete.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_memberdelete.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 268,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = MemberDelete(url='http://localhost/engine-rest/group/anId/members/anUserId', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DFF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE8A6B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE8B650>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231592048'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_memberdelete_raises_for_status(mock, engine_url):\n        delete_member = pycamunda.group.MemberDelete(url=engine_url, id_='anId', user_id='anUserId')\n>       delete_member()\n\ntests\\group\\test_memberdelete.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:268: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = MemberDelete(url='http://localhost/engine-rest/group/anId/members/anUserId', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DFF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE8A6B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE8B650>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_memberdelete.py::test_memberdelete_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_memberdelete_returns_none",
        "__wrapped__",
        "patchings",
        "test_memberdelete.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2273 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_memberdelete.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 268,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = MemberDelete(url='http://localhost/engine-rest/group/anId/members/anUserId', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE8A750>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE8BA60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2273 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_memberdelete_returns_none(engine_url):\n        delete_member = pycamunda.group.MemberDelete(url=engine_url, id_='anId', user_id='anUserId')\n>       result = delete_member()\n\ntests\\group\\test_memberdelete.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:268: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = MemberDelete(url='http://localhost/engine-rest/group/anId/members/anUserId', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE8A750>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE8BA60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2273 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_memberoptions.py::test_memberoptions_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_memberoptions_params",
        "test_memberoptions.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_memberoptions.py::test_memberoptions_calls_requests",
      "lineno": 19,
      "outcome": "failed",
      "keywords": [
        "test_memberoptions_calls_requests",
        "__wrapped__",
        "patchings",
        "test_memberoptions.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2215 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_memberoptions.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 287,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = MemberOptions(url='http://localhost/engine-rest/group/anId/members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E470>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE815D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE82200>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2215 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231594640'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_memberoptions_calls_requests(mock, engine_url):\n        member_options = pycamunda.group.MemberOptions(url=engine_url, id_='anId')\n>       member_options()\n\ntests\\group\\test_memberoptions.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:287: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = MemberOptions(url='http://localhost/engine-rest/group/anId/members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E470>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE815D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE82200>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2215 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_memberoptions.py::test_memberoptions_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_memberoptions_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_memberoptions.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_memberoptions.py::test_memberoptions_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_memberoptions_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_memberoptions.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2218 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_memberoptions.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 287,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = MemberOptions(url='http://localhost/engine-rest/group/anId/members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DFF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE813F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE82480>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2218 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231208048'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.resource.ResourceOptions', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_memberoptions_raises_for_status(mock, engine_url):\n        member_options = pycamunda.group.MemberOptions(url=engine_url, id_='anId')\n>       member_options()\n\ntests\\group\\test_memberoptions.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:287: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = MemberOptions(url='http://localhost/engine-rest/group/anId/members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DFF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE813F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE82480>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2218 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_memberoptions.py::test_memberoptions_returns_none",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_memberoptions_returns_none",
        "__wrapped__",
        "patchings",
        "test_memberoptions.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_memberoptions.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 287,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = MemberOptions(url='http://localhost/engine-rest/group/anId/members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17AB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE82E80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE83420>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_memberoptions_returns_none(engine_url):\n        member_options = pycamunda.group.MemberOptions(url=engine_url, id_='anId')\n>       options = member_options()\n\ntests\\group\\test_memberoptions.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:287: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = MemberOptions(url='http://localhost/engine-rest/group/anId/members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17AB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CE82E80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CE83420>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_options.py::test_options_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_options_params",
        "test_options.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_options.py::test_options_calls_requests",
      "lineno": 23,
      "outcome": "failed",
      "keywords": [
        "test_options_calls_requests",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2307 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_options.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 206,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF98810>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF98860>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2307 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200232166256'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.resource.ResourceOptions.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_options_calls_requests(mock, engine_url):\n        group_options = pycamunda.group.Options(url=engine_url, id_='anId')\n>       group_options()\n\ntests\\group\\test_options.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:206: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF98810>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF98860>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2307 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_options.py::test_options_raises_pycamunda_exception",
      "lineno": 33,
      "outcome": "passed",
      "keywords": [
        "test_options_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_options.py::test_options_raises_for_status",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_options_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2272 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_options.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 206,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF99A30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF99C60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2272 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200235417824'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.resource.ResourceOptions', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_options_raises_for_status(mock, engine_url):\n        group_options = pycamunda.group.Options(url=engine_url, id_='anId')\n>       group_options()\n\ntests\\group\\test_options.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:206: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF99A30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF99C60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2272 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_options.py::test_options_returns_group",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_options_returns_group",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_options.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 206,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D4B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF99E90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF9A110>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_options_returns_group(engine_url):\n        group_options = pycamunda.group.Options(url=engine_url, id_='anId')\n>       options = group_options()\n\ntests\\group\\test_options.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:206: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/group/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D4B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF99E90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF9A110>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_update.py::test_update_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_update_params",
        "test_update.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_update.py::test_update_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_update_calls_requests",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_update.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 184,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/group/anId', id_='anId', name='aName', type_='aType')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C070>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF9B8D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF9A1B0>\nbody = '{\"name\": \"aName\", \"type\": \"aType\", \"id\": \"anId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200230939328'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_update_calls_requests(mock, engine_url):\n        update_group = pycamunda.group.Update(url=engine_url, id_='anId', name='aName', type_='aType')\n>       update_group()\n\ntests\\group\\test_update.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:184: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/group/anId', id_='anId', name='aName', type_='aType')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C070>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF9B8D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF9A1B0>\nbody = '{\"name\": \"aName\", \"type\": \"aType\", \"id\": \"anId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_update.py::test_update_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_update_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_update.py::test_update_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_update_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2274 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_update.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 184,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/group/anId', id_='anId', name='aName', type_='aType')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D020680>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D020720>\nbody = '{\"name\": \"aName\", \"type\": \"aType\", \"id\": \"anId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2274 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231599920'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_update_raises_for_status(mock, engine_url):\n        update_group = pycamunda.group.Update(url=engine_url, id_='anId', name='aName', type_='aType')\n>       update_group()\n\ntests\\group\\test_update.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:184: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/group/anId', id_='anId', name='aName', type_='aType')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D020680>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D020720>\nbody = '{\"name\": \"aName\", \"type\": \"aType\", \"id\": \"anId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2274 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/group/test_update.py::test_update_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_update_returns_none",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "group",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\group\\test_update.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\group.py",
            "lineno": 184,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/group/anId', id_='anId', name='aName', type_='aType')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18830>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D021210>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D021760>\nbody = '{\"name\": \"aName\", \"type\": \"aType\", \"id\": \"anId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_update_returns_none(engine_url):\n        update_group = pycamunda.group.Update(url=engine_url, id_='anId', name='aName', type_='aType')\n>       result = update_group()\n\ntests\\group\\test_update.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\group.py:184: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/group/anId', id_='anId', name='aName', type_='aType')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18830>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D021210>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D021760>\nbody = '{\"name\": \"aName\", \"type\": \"aType\", \"id\": \"anId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_authstatus.py::test_authstatus_load",
      "lineno": 9,
      "outcome": "passed",
      "keywords": [
        "test_authstatus_load",
        "test_authstatus.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_authstatus.py::test_authstatus_load_raises_keyerror",
      "lineno": 16,
      "outcome": "passed",
      "keywords": [
        "test_authstatus_load_raises_keyerror",
        "test_authstatus.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_getgroups.py::test_getgroups_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getgroups_params",
        "test_getgroups.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_getgroups.py::test_getgroups_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getgroups_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getgroups.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\identity\\test_getgroups.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\identity.py",
            "lineno": 93,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetGroups(url='http://localhost/engine-rest/identity/groups', user_id='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DDB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D020090>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D020720>\nquery_string = 'userId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231594640'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.identity.UsersGroups.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_getgroups_calls_requests(mock, engine_url):\n        get_users_groups = pycamunda.identity.GetGroups(url=engine_url, user_id='anId')\n>       get_users_groups()\n\ntests\\identity\\test_getgroups.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\identity.py:93: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetGroups(url='http://localhost/engine-rest/identity/groups', user_id='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DDB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D020090>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D020720>\nquery_string = 'userId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_getgroups.py::test_getgroups_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_getgroups_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getgroups.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_getgroups.py::test_getgroups_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_getgroups_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getgroups.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2456 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\identity\\test_getgroups.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\identity.py",
            "lineno": 93,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetGroups(url='http://localhost/engine-rest/identity/groups', user_id='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D010130>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D010040>\nquery_string = 'userId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2456 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200213196320'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.identity.UsersGroups', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getgroups_raises_for_status(mock, engine_url):\n        get_users_groups = pycamunda.identity.GetGroups(url=engine_url, user_id='anId')\n>       get_users_groups()\n\ntests\\identity\\test_getgroups.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\identity.py:93: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetGroups(url='http://localhost/engine-rest/identity/groups', user_id='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D010130>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D010040>\nquery_string = 'userId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2456 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_getgroups.py::test_getgroups_returns_usersgroups",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_getgroups_returns_usersgroups",
        "__wrapped__",
        "patchings",
        "test_getgroups.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\identity\\test_getgroups.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\identity.py",
            "lineno": 93,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetGroups(url='http://localhost/engine-rest/identity/groups', user_id='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E8F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D010C70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D010590>\nquery_string = 'userId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getgroups_returns_usersgroups(engine_url):\n        get_users_groups = pycamunda.identity.GetGroups(url=engine_url, user_id='anId')\n>       users_groups = get_users_groups()\n\ntests\\identity\\test_getgroups.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\identity.py:93: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetGroups(url='http://localhost/engine-rest/identity/groups', user_id='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E8F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D010C70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D010590>\nquery_string = 'userId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_getpasswordpolicy.py::test_getpasswordpolicy_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getpasswordpolicy_params",
        "test_getpasswordpolicy.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_getpasswordpolicy.py::test_getpasswordpolicy_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getpasswordpolicy_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getpasswordpolicy.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2268 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\identity\\test_getpasswordpolicy.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\identity.py",
            "lineno": 132,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetPasswordPolicy(url='http://localhost/engine-rest/identity/password-policy')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D012250>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0122A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2268 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200237388576'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.identity.PasswordPolicy.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_getpasswordpolicy_calls_requests(mock, engine_url):\n        get_policy = pycamunda.identity.GetPasswordPolicy(url=engine_url)\n>       get_policy()\n\ntests\\identity\\test_getpasswordpolicy.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\identity.py:132: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetPasswordPolicy(url='http://localhost/engine-rest/identity/password-policy')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D012250>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0122A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2268 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_getpasswordpolicy.py::test_getpasswordpolicy_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_getpasswordpolicy_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getpasswordpolicy.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_getpasswordpolicy.py::test_getpasswordpolicy_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_getpasswordpolicy_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getpasswordpolicy.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\identity\\test_getpasswordpolicy.py",
            "lineno": 42,
            "message": ""
          },
          {
            "path": "pycamunda\\identity.py",
            "lineno": 132,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetPasswordPolicy(url='http://localhost/engine-rest/identity/password-policy')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0126B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0123E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200237403840'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.identity.PasswordPolicy', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getpasswordpolicy_raises_for_status(mock, engine_url):\n        get_policy = pycamunda.identity.GetPasswordPolicy(url=engine_url)\n        with pytest.raises(KeyError):\n>           get_policy()\n\ntests\\identity\\test_getpasswordpolicy.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\identity.py:132: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetPasswordPolicy(url='http://localhost/engine-rest/identity/password-policy')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0126B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0123E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_getpasswordpolicy.py::test_getpasswordpolicy_returns_tuple",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_getpasswordpolicy_returns_tuple",
        "__wrapped__",
        "patchings",
        "test_getpasswordpolicy.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2262 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\identity\\test_getpasswordpolicy.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\identity.py",
            "lineno": 132,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetPasswordPolicy(url='http://localhost/engine-rest/identity/password-policy')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D013880>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0136F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2262 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getpasswordpolicy_returns_tuple(engine_url):\n        get_policy = pycamunda.identity.GetPasswordPolicy(url=engine_url)\n>       password_policy = get_policy()\n\ntests\\identity\\test_getpasswordpolicy.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\identity.py:132: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetPasswordPolicy(url='http://localhost/engine-rest/identity/password-policy')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D013880>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0136F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2262 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_passwordpolicy.py::test_passwordpolicy_load",
      "lineno": 9,
      "outcome": "passed",
      "keywords": [
        "test_passwordpolicy_load",
        "test_passwordpolicy.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_passwordpolicy.py::test_passwordpolicy_load_raises_keyerror",
      "lineno": 16,
      "outcome": "passed",
      "keywords": [
        "test_passwordpolicy_load_raises_keyerror",
        "test_passwordpolicy.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_passwordpolicycompliance.py::test_passwordpolicycompliance_load",
      "lineno": 9,
      "outcome": "passed",
      "keywords": [
        "test_passwordpolicycompliance_load",
        "test_passwordpolicycompliance.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_passwordpolicycompliance.py::test_passwordpolicycompliance_load_raises_keyerror",
      "lineno": 17,
      "outcome": "passed",
      "keywords": [
        "test_passwordpolicycompliance_load_raises_keyerror",
        "test_passwordpolicycompliance.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_usersgroups.py::test_group_load",
      "lineno": 9,
      "outcome": "passed",
      "keywords": [
        "test_group_load",
        "test_usersgroups.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_usersgroups.py::test_group_load_raises_keyerror",
      "lineno": 16,
      "outcome": "passed",
      "keywords": [
        "test_group_load_raises_keyerror",
        "test_usersgroups.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_validatepassword.py::test_validatepassword_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_validatepassword_params",
        "test_validatepassword.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_validatepassword.py::test_validatepassword_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_validatepassword_calls_requests",
        "__wrapped__",
        "patchings",
        "test_validatepassword.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\identity\\test_validatepassword.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\identity.py",
            "lineno": 152,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = ValidatePassword(url='http://localhost/engine-rest/identity/password-policy', password='aPass')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D030>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D02A2A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D02A1B0>\nbody = '{\"password\": \"aPass\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200235412736'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.identity.PasswordPolicyCompliance.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_validatepassword_calls_requests(mock, engine_url):\n        validate_password = pycamunda.identity.ValidatePassword(url=engine_url, password='aPass')\n>       validate_password()\n\ntests\\identity\\test_validatepassword.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\identity.py:152: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ValidatePassword(url='http://localhost/engine-rest/identity/password-policy', password='aPass')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D030>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D02A2A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D02A1B0>\nbody = '{\"password\": \"aPass\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_validatepassword.py::test_validatepassword_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_validatepassword_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_validatepassword.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_validatepassword.py::test_validatepassword_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_validatepassword_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_validatepassword.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\identity\\test_validatepassword.py",
            "lineno": 42,
            "message": ""
          },
          {
            "path": "pycamunda\\identity.py",
            "lineno": 152,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = ValidatePassword(url='http://localhost/engine-rest/identity/password-policy', password='aPass')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C070>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D02A7A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D02A660>\nbody = '{\"password\": \"aPass\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200237391888'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.identity.PasswordPolicy', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_validatepassword_raises_for_status(mock, engine_url):\n        validate_password = pycamunda.identity.ValidatePassword(url=engine_url, password='aPass')\n        with pytest.raises(KeyError):\n>           validate_password()\n\ntests\\identity\\test_validatepassword.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\identity.py:152: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ValidatePassword(url='http://localhost/engine-rest/identity/password-policy', password='aPass')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C070>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D02A7A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D02A660>\nbody = '{\"password\": \"aPass\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_validatepassword.py::test_validatepassword_returns_tuple",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_validatepassword_returns_tuple",
        "__wrapped__",
        "patchings",
        "test_validatepassword.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2268 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\identity\\test_validatepassword.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\identity.py",
            "lineno": 152,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = ValidatePassword(url='http://localhost/engine-rest/identity/password-policy', password='aPass')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E230>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D02BBF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D02A2F0>\nbody = '{\"password\": \"aPass\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2268 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_validatepassword_returns_tuple(engine_url):\n        validate_password = pycamunda.identity.ValidatePassword(url=engine_url, password='aPass')\n>       password_compliance = validate_password()\n\ntests\\identity\\test_validatepassword.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\identity.py:152: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ValidatePassword(url='http://localhost/engine-rest/identity/password-policy', password='aPass')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E230>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D02BBF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D02A2F0>\nbody = '{\"password\": \"aPass\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2268 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_verifyuser.py::test_verifyuser_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_verifyuser_params",
        "test_verifyuser.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_verifyuser.py::test_verifyuser_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_verifyuser_calls_requests",
        "__wrapped__",
        "patchings",
        "test_verifyuser.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\identity\\test_verifyuser.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\identity.py",
            "lineno": 116,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VerifyUser(url='http://localhost/engine-rest/identity/verify', username='anUser', password='aPass')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CFDD0D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CFDC770>\nbody = '{\"username\": \"anUser\", \"password\": \"aPass\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200205074176'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.identity.AuthStatus.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_verifyuser_calls_requests(mock, engine_url):\n        verify_user = pycamunda.identity.VerifyUser(url=engine_url, username='anUser', password='aPass')\n>       verify_user()\n\ntests\\identity\\test_verifyuser.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\identity.py:116: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VerifyUser(url='http://localhost/engine-rest/identity/verify', username='anUser', password='aPass')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CFDD0D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CFDC770>\nbody = '{\"username\": \"anUser\", \"password\": \"aPass\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_verifyuser.py::test_verifyuser_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_verifyuser_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_verifyuser.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_verifyuser.py::test_verifyuser_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_verifyuser_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_verifyuser.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\identity\\test_verifyuser.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\identity.py",
            "lineno": 116,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VerifyUser(url='http://localhost/engine-rest/identity/verify', username='anUser', password='aPass')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CFDE520>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CFDD530>\nbody = '{\"username\": \"anUser\", \"password\": \"aPass\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200204353088'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.identity.AuthStatus', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_verifyuser_raises_for_status(mock, engine_url):\n        verify_user = pycamunda.identity.VerifyUser(url=engine_url, username='anUser', password='aPass')\n>       verify_user()\n\ntests\\identity\\test_verifyuser.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\identity.py:116: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VerifyUser(url='http://localhost/engine-rest/identity/verify', username='anUser', password='aPass')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CFDE520>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CFDD530>\nbody = '{\"username\": \"anUser\", \"password\": \"aPass\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/identity/test_verifyuser.py::test_verifyuser_returns_authstatus",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_verifyuser_returns_authstatus",
        "__wrapped__",
        "patchings",
        "test_verifyuser.py",
        "identity",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\identity\\test_verifyuser.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\identity.py",
            "lineno": 116,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VerifyUser(url='http://localhost/engine-rest/identity/verify', username='anUser', password='aPass')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18170>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CFDEF20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CFDE890>\nbody = '{\"username\": \"anUser\", \"password\": \"aPass\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_verifyuser_returns_authstatus(engine_url):\n        verify_user = pycamunda.identity.VerifyUser(url=engine_url, username='anUser', password='aPass')\n>       auth_status = verify_user()\n\ntests\\identity\\test_verifyuser.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\identity.py:116: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VerifyUser(url='http://localhost/engine-rest/identity/verify', username='anUser', password='aPass')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18170>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CFDEF20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CFDE890>\nbody = '{\"username\": \"anUser\", \"password\": \"aPass\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_get.py::test_get_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2265 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\incident\\test_get.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\incident.py",
            "lineno": 96,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/incident/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D060400>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D060590>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2265 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200236927936'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.incident.Incident.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n        get_incident = pycamunda.incident.Get(url=engine_url, id_='anId')\n>       get_incident()\n\ntests\\incident\\test_get.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\incident.py:96: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/incident/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D060400>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D060590>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2265 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_get.py::test_get_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\incident\\test_get.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\incident.py",
            "lineno": 96,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/incident/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0625C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D060950>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200236853664'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.incident.Incident', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_incident = pycamunda.incident.Get(url=engine_url, id_='anId')\n>       get_incident()\n\ntests\\incident\\test_get.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\incident.py:96: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/incident/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0625C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D060950>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_get.py::test_get_returns_incident",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_incident",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2226 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\incident\\test_get.py",
            "lineno": 51,
            "message": ""
          },
          {
            "path": "pycamunda\\incident.py",
            "lineno": 96,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/incident/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19EB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF99A80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF9A070>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2226 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.incident.IncidentType', unittest.mock.MagicMock())\n    def test_get_returns_incident(engine_url):\n        get_incident = pycamunda.incident.Get(url=engine_url, id_='anId')\n>       incident = get_incident()\n\ntests\\incident\\test_get.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\incident.py:96: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/incident/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19EB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF99A80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF9A070>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2226 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_getlist.py::test_getlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2262 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\incident\\test_getlist.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\incident.py",
            "lineno": 201,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/incident')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D030>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D060900>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D060360>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2262 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231328656'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.incident.Incident.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_incidents = pycamunda.incident.GetList(url=engine_url)\n>       get_incidents()\n\ntests\\incident\\test_getlist.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\incident.py:201: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/incident')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D030>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D060900>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D060360>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2262 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\incident\\test_getlist.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\incident.py",
            "lineno": 201,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/incident')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D063970>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D063BA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200232182112'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.incident.Incident', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_incidents = pycamunda.incident.GetList(url=engine_url)\n>       get_incidents()\n\ntests\\incident\\test_getlist.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\incident.py:201: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/incident')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B0B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D063970>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D063BA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_getlist.py::test_getlist_returns_incidents_tuple",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_incidents_tuple",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2240 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\incident\\test_getlist.py",
            "lineno": 51,
            "message": ""
          },
          {
            "path": "pycamunda\\incident.py",
            "lineno": 201,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/incident')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AE70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D063C40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF34DB0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2240 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.incident.IncidentType', unittest.mock.MagicMock())\n    def test_getlist_returns_incidents_tuple(engine_url):\n        get_incidents = pycamunda.incident.GetList(url=engine_url)\n>       incidents = get_incidents()\n\ntests\\incident\\test_getlist.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\incident.py:201: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/incident')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AE70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D063C40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF34DB0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2240 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_incident.py::test_incident_load",
      "lineno": 9,
      "outcome": "passed",
      "keywords": [
        "test_incident_load",
        "test_incident.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_incident.py::test_incident_load_raises_keyerror",
      "lineno": 31,
      "outcome": "passed",
      "keywords": [
        "test_incident_load_raises_keyerror",
        "test_incident.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_incidenttypecount.py::test_incident_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_incident_load",
        "test_incidenttypecount.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_incidenttypecount.py::test_incident_load_raises_keyerror",
      "lineno": 16,
      "outcome": "passed",
      "keywords": [
        "test_incident_load_raises_keyerror",
        "test_incidenttypecount.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_resolve.py::test_resolve_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_resolve_params",
        "test_resolve.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_resolve.py::test_resolve_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_resolve_calls_requests",
        "__wrapped__",
        "patchings",
        "test_resolve.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\incident\\test_resolve.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\incident.py",
            "lineno": 221,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Resolve(url='http://localhost/engine-rest/incident/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF36250>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF362A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200202978080'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_resolve_calls_requests(mock, engine_url):\n        resolve_incident = pycamunda.incident.Resolve(url=engine_url, id_='anId')\n>       resolve_incident()\n\ntests\\incident\\test_resolve.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\incident.py:221: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Resolve(url='http://localhost/engine-rest/incident/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF36250>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF362A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_resolve.py::test_resolve_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_resolve_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_resolve.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_resolve.py::test_resolve_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_resolve_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_resolve.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2212 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\incident\\test_resolve.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\incident.py",
            "lineno": 221,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Resolve(url='http://localhost/engine-rest/incident/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF36840>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF37650>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2212 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231700144'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_resolve_raises_for_status(mock, engine_url):\n        resolve_incident = pycamunda.incident.Resolve(url=engine_url, id_='anId')\n>       resolve_incident()\n\ntests\\incident\\test_resolve.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\incident.py:221: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Resolve(url='http://localhost/engine-rest/incident/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF36840>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF37650>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2212 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/incident/test_resolve.py::test_resolve_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_resolve_returns_none",
        "__wrapped__",
        "patchings",
        "test_resolve.py",
        "incident",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\incident\\test_resolve.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\incident.py",
            "lineno": 221,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Resolve(url='http://localhost/engine-rest/incident/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BBF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF37880>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF37BA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_resolve_returns_none(engine_url):\n        resolve_incident = pycamunda.incident.Resolve(url=engine_url, id_='anId')\n>       result = resolve_incident()\n\ntests\\incident\\test_resolve.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\incident.py:221: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Resolve(url='http://localhost/engine-rest/incident/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BBF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91CF37880>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF37BA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/instruction/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "instruction",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_correlate.py::test_correlatesingle_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_correlatesingle_params",
        "test_correlate.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_correlate.py::test_correlatesingle_method_params",
      "lineno": 24,
      "outcome": "passed",
      "keywords": [
        "test_correlatesingle_method_params",
        "test_correlate.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_correlate.py::test_correlatesingle_calls_requests",
      "lineno": 48,
      "outcome": "failed",
      "keywords": [
        "test_correlatesingle_calls_requests",
        "__wrapped__",
        "patchings",
        "test_correlate.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2255 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\message\\test_correlate.py",
            "lineno": 53,
            "message": ""
          },
          {
            "path": "pycamunda\\message.py",
            "lineno": 172,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CorrelateSingle(url='http://localhost/engine-rest/message', message_name='aMessageName', correlation_keys={}, local_co... process_variables={}, process_variables_local={}, all_=False, result_enabled=False, variables_in_result_enabled=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0CE070>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0CE0C0>\nbody = '{\"messageName\": \"aMessageName\", \"correlationKeys\": {}, \"localCorrelationKeys\": {}, \"processVariables\": {}, \"processVariablesLocal\": {}, \"all\": false, \"resultEnabled\": false, \"variablesInResultEnabled\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2255 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200235410384'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.message.MessageCorrelationResult', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_correlatesingle_calls_requests(mock, engine_url):\n        correlate = pycamunda.message.CorrelateSingle(url=engine_url, message_name='aMessageName')\n>       correlate()\n\ntests\\message\\test_correlate.py:53: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\message.py:172: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CorrelateSingle(url='http://localhost/engine-rest/message', message_name='aMessageName', correlation_keys={}, local_co... process_variables={}, process_variables_local={}, all_=False, result_enabled=False, variables_in_result_enabled=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0CE070>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0CE0C0>\nbody = '{\"messageName\": \"aMessageName\", \"correlationKeys\": {}, \"localCorrelationKeys\": {}, \"processVariables\": {}, \"processVariablesLocal\": {}, \"all\": false, \"resultEnabled\": false, \"variablesInResultEnabled\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2255 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_correlate.py::test_correlatesingle_raises_pycamunda_exception",
      "lineno": 58,
      "outcome": "passed",
      "keywords": [
        "test_correlatesingle_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_correlate.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_correlate.py::test_correlatesingle_raises_for_status",
      "lineno": 65,
      "outcome": "failed",
      "keywords": [
        "test_correlatesingle_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_correlate.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2213 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\message\\test_correlate.py",
            "lineno": 71,
            "message": ""
          },
          {
            "path": "pycamunda\\message.py",
            "lineno": 172,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CorrelateSingle(url='http://localhost/engine-rest/message', message_name='aMessageName', correlation_keys={}, local_co... process_variables={}, process_variables_local={}, all_=False, result_enabled=False, variables_in_result_enabled=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0CEFC0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF36160>\nbody = '{\"messageName\": \"aMessageName\", \"correlationKeys\": {}, \"localCorrelationKeys\": {}, \"processVariables\": {}, \"processVariablesLocal\": {}, \"all\": false, \"resultEnabled\": false, \"variablesInResultEnabled\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2213 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200236921840'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.message.MessageCorrelationResult', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_correlatesingle_raises_for_status(mock, engine_url):\n        correlate = pycamunda.message.CorrelateSingle(url=engine_url, message_name='aMessageName')\n>       correlate()\n\ntests\\message\\test_correlate.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\message.py:172: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CorrelateSingle(url='http://localhost/engine-rest/message', message_name='aMessageName', correlation_keys={}, local_co... process_variables={}, process_variables_local={}, all_=False, result_enabled=False, variables_in_result_enabled=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0CEFC0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91CF36160>\nbody = '{\"messageName\": \"aMessageName\", \"correlationKeys\": {}, \"localCorrelationKeys\": {}, \"processVariables\": {}, \"processVariablesLocal\": {}, \"all\": false, \"resultEnabled\": false, \"variablesInResultEnabled\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2213 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_correlate.py::test_correlatesingle_returns_messagecorrelationresult",
      "lineno": 75,
      "outcome": "failed",
      "keywords": [
        "test_correlatesingle_returns_messagecorrelationresult",
        "__wrapped__",
        "patchings",
        "test_correlate.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\message\\test_correlate.py",
            "lineno": 80,
            "message": ""
          },
          {
            "path": "pycamunda\\message.py",
            "lineno": 172,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CorrelateSingle(url='http://localhost/engine-rest/message', message_name='aMessageName', correlation_keys={}, local_co... process_variables={}, process_variables_local={}, all_=False, result_enabled=False, variables_in_result_enabled=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E8F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0683B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D068450>\nbody = '{\"messageName\": \"aMessageName\", \"correlationKeys\": {}, \"localCorrelationKeys\": {}, \"processVariables\": {}, \"processVariablesLocal\": {}, \"all\": false, \"resultEnabled\": false, \"variablesInResultEnabled\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.message.ResultType', unittest.mock.MagicMock())\n    def test_correlatesingle_returns_messagecorrelationresult(engine_url):\n        correlate = pycamunda.message.CorrelateSingle(url=engine_url, message_name='aMessageName')\n>       results = correlate()\n\ntests\\message\\test_correlate.py:80: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\message.py:172: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CorrelateSingle(url='http://localhost/engine-rest/message', message_name='aMessageName', correlation_keys={}, local_co... process_variables={}, process_variables_local={}, all_=False, result_enabled=False, variables_in_result_enabled=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E8F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0683B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D068450>\nbody = '{\"messageName\": \"aMessageName\", \"correlationKeys\": {}, \"localCorrelationKeys\": {}, \"processVariables\": {}, \"processVariablesLocal\": {}, \"all\": false, \"resultEnabled\": false, \"variablesInResultEnabled\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_correlate.py::test_correlateall_params",
      "lineno": 85,
      "outcome": "passed",
      "keywords": [
        "test_correlateall_params",
        "test_correlate.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_correlate.py::test_correlateall_method_params",
      "lineno": 99,
      "outcome": "passed",
      "keywords": [
        "test_correlateall_method_params",
        "test_correlate.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_correlate.py::test_correlateall_calls_requests",
      "lineno": 123,
      "outcome": "failed",
      "keywords": [
        "test_correlateall_calls_requests",
        "__wrapped__",
        "patchings",
        "test_correlate.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\message\\test_correlate.py",
            "lineno": 128,
            "message": ""
          },
          {
            "path": "pycamunda\\message.py",
            "lineno": 172,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CorrelateAll(url='http://localhost/engine-rest/message', message_name='aMessageName', correlation_keys={}, local_corre..., process_variables={}, process_variables_local={}, all_=True, result_enabled=False, variables_in_result_enabled=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D068090>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D068A40>\nbody = '{\"messageName\": \"aMessageName\", \"correlationKeys\": {}, \"localCorrelationKeys\": {}, \"processVariables\": {}, \"processVariablesLocal\": {}, \"all\": true, \"resultEnabled\": false, \"variablesInResultEnabled\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200235413408'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.message.MessageCorrelationResult', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_correlateall_calls_requests(mock, engine_url):\n        correlate = pycamunda.message.CorrelateAll(url=engine_url, message_name='aMessageName')\n>       correlate()\n\ntests\\message\\test_correlate.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\message.py:172: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CorrelateAll(url='http://localhost/engine-rest/message', message_name='aMessageName', correlation_keys={}, local_corre..., process_variables={}, process_variables_local={}, all_=True, result_enabled=False, variables_in_result_enabled=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D068090>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D068A40>\nbody = '{\"messageName\": \"aMessageName\", \"correlationKeys\": {}, \"localCorrelationKeys\": {}, \"processVariables\": {}, \"processVariablesLocal\": {}, \"all\": true, \"resultEnabled\": false, \"variablesInResultEnabled\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_correlate.py::test_correlateall_raises_pycamunda_exception",
      "lineno": 132,
      "outcome": "passed",
      "keywords": [
        "test_correlateall_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_correlate.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_correlate.py::test_correlateall_raises_for_status",
      "lineno": 139,
      "outcome": "failed",
      "keywords": [
        "test_correlateall_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_correlate.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\message\\test_correlate.py",
            "lineno": 145,
            "message": ""
          },
          {
            "path": "pycamunda\\message.py",
            "lineno": 172,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CorrelateAll(url='http://localhost/engine-rest/message', message_name='aMessageName', correlation_keys={}, local_corre..., process_variables={}, process_variables_local={}, all_=True, result_enabled=False, variables_in_result_enabled=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CBB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D06B790>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D06A930>\nbody = '{\"messageName\": \"aMessageName\", \"correlationKeys\": {}, \"localCorrelationKeys\": {}, \"processVariables\": {}, \"processVariablesLocal\": {}, \"all\": true, \"resultEnabled\": false, \"variablesInResultEnabled\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231802880'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.message.MessageCorrelationResult', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_correlateall_raises_for_status(mock, engine_url):\n        correlate = pycamunda.message.CorrelateAll(url=engine_url, message_name='aMessageName')\n>       correlate()\n\ntests\\message\\test_correlate.py:145: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\message.py:172: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CorrelateAll(url='http://localhost/engine-rest/message', message_name='aMessageName', correlation_keys={}, local_corre..., process_variables={}, process_variables_local={}, all_=True, result_enabled=False, variables_in_result_enabled=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CBB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D06B790>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D06A930>\nbody = '{\"messageName\": \"aMessageName\", \"correlationKeys\": {}, \"localCorrelationKeys\": {}, \"processVariables\": {}, \"processVariablesLocal\": {}, \"all\": true, \"resultEnabled\": false, \"variablesInResultEnabled\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_correlate.py::test_correlateall_returns_messagecorrelationresult",
      "lineno": 149,
      "outcome": "failed",
      "keywords": [
        "test_correlateall_returns_messagecorrelationresult",
        "__wrapped__",
        "patchings",
        "test_correlate.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2438 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\message\\test_correlate.py",
            "lineno": 154,
            "message": ""
          },
          {
            "path": "pycamunda\\message.py",
            "lineno": 172,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CorrelateAll(url='http://localhost/engine-rest/message', message_name='aMessageName', correlation_keys={}, local_corre..., process_variables={}, process_variables_local={}, all_=True, result_enabled=False, variables_in_result_enabled=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D06A110>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D06A430>\nbody = '{\"messageName\": \"aMessageName\", \"correlationKeys\": {}, \"localCorrelationKeys\": {}, \"processVariables\": {}, \"processVariablesLocal\": {}, \"all\": true, \"resultEnabled\": false, \"variablesInResultEnabled\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2438 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.message.ResultType', unittest.mock.MagicMock())\n    def test_correlateall_returns_messagecorrelationresult(engine_url):\n        correlate = pycamunda.message.CorrelateAll(url=engine_url, message_name='aMessageName')\n>       results = correlate()\n\ntests\\message\\test_correlate.py:154: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\message.py:172: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CorrelateAll(url='http://localhost/engine-rest/message', message_name='aMessageName', correlation_keys={}, local_corre..., process_variables={}, process_variables_local={}, all_=True, result_enabled=False, variables_in_result_enabled=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D06A110>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D06A430>\nbody = '{\"messageName\": \"aMessageName\", \"correlationKeys\": {}, \"localCorrelationKeys\": {}, \"processVariables\": {}, \"processVariablesLocal\": {}, \"all\": true, \"resultEnabled\": false, \"variablesInResultEnabled\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2438 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_messagecorrelationresult.py::test_messagecorrelationresult_load_definition",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_messagecorrelationresult_load_definition",
        "test_messagecorrelationresult.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_messagecorrelationresult.py::test_messagecorrelationresult_load_execution",
      "lineno": 25,
      "outcome": "passed",
      "keywords": [
        "test_messagecorrelationresult_load_execution",
        "test_messagecorrelationresult.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_messagecorrelationresult.py::test_messagecorrelationresult_load_raises_keyerror",
      "lineno": 40,
      "outcome": "passed",
      "keywords": [
        "test_messagecorrelationresult_load_raises_keyerror",
        "test_messagecorrelationresult.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/message/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "message",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_execute.py::test_execute_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_execute_params",
        "test_execute.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_execute.py::test_execute_from_migration_plan_params",
      "lineno": 44,
      "outcome": "passed",
      "keywords": [
        "test_execute_from_migration_plan_params",
        "test_execute.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_execute.py::test_execute_async_params",
      "lineno": 77,
      "outcome": "passed",
      "keywords": [
        "test_execute_async_params",
        "test_execute.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_execute.py::test_execute_calls_requests",
      "lineno": 91,
      "outcome": "failed",
      "keywords": [
        "test_execute_calls_requests",
        "__wrapped__",
        "patchings",
        "test_execute.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2240 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\migration\\test_execute.py",
            "lineno": 103,
            "message": ""
          },
          {
            "path": "pycamunda\\migration.py",
            "lineno": 304,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Execute(url='http://localhost/engine-rest/migration/execute', migration_plan=MigrationPlan(source_process_definition_i...rId'], update_event_trigger=False))), process_instance_ids=['anId'], skip_custom_listeners=True, skip_io_mappings=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0D6340>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0D6390>\nbody = '{\"migrationPlan\": {\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"..., \"updateEventTrigger\": false}]}, \"processInstanceIds\": [\"anId\"], \"skipCustomListeners\": true, \"skipIoMappings\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2240 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200236924624'>\nengine_url = 'http://localhost/engine-rest'\nmy_plan_json = {'instructions': [{'sourceActivityIds': ['anId'], 'targetActivityIds': ['anotherId'], 'updateEventTrigger': False}, {'...therId'], 'updateEventTrigger': False}], 'sourceProcessDefinitionId': 'anId', 'targetProcessDefinitionId': 'anotherId'}\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_execute_calls_requests(mock, engine_url, my_plan_json):\n        migration_plan = pycamunda.migration.MigrationPlan.load(data=my_plan_json)\n        execute_migration = pycamunda.migration.Execute.from_migration_plan(\n            url=engine_url,\n            migration_plan=migration_plan,\n            process_instance_ids=['anId'],\n            skip_custom_listeners=True,\n            skip_io_mappings=True,\n            async_=False\n        )\n>       execute_migration()\n\ntests\\migration\\test_execute.py:103: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\migration.py:304: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Execute(url='http://localhost/engine-rest/migration/execute', migration_plan=MigrationPlan(source_process_definition_i...rId'], update_event_trigger=False))), process_instance_ids=['anId'], skip_custom_listeners=True, skip_io_mappings=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0D6340>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0D6390>\nbody = '{\"migrationPlan\": {\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"..., \"updateEventTrigger\": false}]}, \"processInstanceIds\": [\"anId\"], \"skipCustomListeners\": true, \"skipIoMappings\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2240 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_execute.py::test_execute_raises_pycamunda_exception",
      "lineno": 108,
      "outcome": "passed",
      "keywords": [
        "test_execute_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_execute.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_execute.py::test_execute_raises_for_status",
      "lineno": 123,
      "outcome": "failed",
      "keywords": [
        "test_execute_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_execute.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2517 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\migration\\test_execute.py",
            "lineno": 136,
            "message": ""
          },
          {
            "path": "pycamunda\\migration.py",
            "lineno": 304,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Execute(url='http://localhost/engine-rest/migration/execute', migration_plan=MigrationPlan(source_process_definition_i...rId'], update_event_trigger=False))), process_instance_ids=['anId'], skip_custom_listeners=True, skip_io_mappings=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17F30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1084F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D108810>\nbody = '{\"migrationPlan\": {\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"..., \"updateEventTrigger\": false}]}, \"processInstanceIds\": [\"anId\"], \"skipCustomListeners\": true, \"skipIoMappings\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2517 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200231597040'>\nengine_url = 'http://localhost/engine-rest'\nmy_plan_json = {'instructions': [{'sourceActivityIds': ['anId'], 'targetActivityIds': ['anotherId'], 'updateEventTrigger': False}, {'...therId'], 'updateEventTrigger': False}], 'sourceProcessDefinitionId': 'anId', 'targetProcessDefinitionId': 'anotherId'}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_execute_raises_for_status(mock, engine_url, my_plan_json):\n        migration_plan = pycamunda.migration.MigrationPlan.load(data=my_plan_json)\n        execute_migration = pycamunda.migration.Execute.from_migration_plan(\n            url=engine_url,\n            migration_plan=migration_plan,\n            process_instance_ids=['anId'],\n            skip_custom_listeners=True,\n            skip_io_mappings=True,\n            async_=False\n        )\n>       execute_migration()\n\ntests\\migration\\test_execute.py:136: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\migration.py:304: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Execute(url='http://localhost/engine-rest/migration/execute', migration_plan=MigrationPlan(source_process_definition_i...rId'], update_event_trigger=False))), process_instance_ids=['anId'], skip_custom_listeners=True, skip_io_mappings=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17F30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1084F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D108810>\nbody = '{\"migrationPlan\": {\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"..., \"updateEventTrigger\": false}]}, \"processInstanceIds\": [\"anId\"], \"skipCustomListeners\": true, \"skipIoMappings\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2517 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_execute.py::test_execute_returns_none",
      "lineno": 140,
      "outcome": "failed",
      "keywords": [
        "test_execute_returns_none",
        "__wrapped__",
        "patchings",
        "test_execute.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\migration\\test_execute.py",
            "lineno": 152,
            "message": ""
          },
          {
            "path": "pycamunda\\migration.py",
            "lineno": 304,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Execute(url='http://localhost/engine-rest/migration/execute', migration_plan=MigrationPlan(source_process_definition_i...rId'], update_event_trigger=False))), process_instance_ids=['anId'], skip_custom_listeners=True, skip_io_mappings=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17630>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D10A840>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D10A8E0>\nbody = '{\"migrationPlan\": {\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"..., \"updateEventTrigger\": false}]}, \"processInstanceIds\": [\"anId\"], \"skipCustomListeners\": true, \"skipIoMappings\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\nmy_plan_json = {'instructions': [{'sourceActivityIds': ['anId'], 'targetActivityIds': ['anotherId'], 'updateEventTrigger': False}, {'...therId'], 'updateEventTrigger': False}], 'sourceProcessDefinitionId': 'anId', 'targetProcessDefinitionId': 'anotherId'}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_execute_returns_none(engine_url, my_plan_json):\n        migration_plan = pycamunda.migration.MigrationPlan.load(data=my_plan_json)\n        execute_migration = pycamunda.migration.Execute.from_migration_plan(\n            url=engine_url,\n            migration_plan=migration_plan,\n            process_instance_ids=['anId'],\n            skip_custom_listeners=True,\n            skip_io_mappings=True,\n            async_=False\n        )\n>       result = execute_migration()\n\ntests\\migration\\test_execute.py:152: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\migration.py:304: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Execute(url='http://localhost/engine-rest/migration/execute', migration_plan=MigrationPlan(source_process_definition_i...rId'], update_event_trigger=False))), process_instance_ids=['anId'], skip_custom_listeners=True, skip_io_mappings=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17630>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D10A840>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D10A8E0>\nbody = '{\"migrationPlan\": {\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"..., \"updateEventTrigger\": false}]}, \"processInstanceIds\": [\"anId\"], \"skipCustomListeners\": true, \"skipIoMappings\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_execute.py::test_execute_async_returns_batch",
      "lineno": 156,
      "outcome": "failed",
      "keywords": [
        "test_execute_async_returns_batch",
        "__wrapped__",
        "patchings",
        "test_execute.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\migration\\test_execute.py",
            "lineno": 168,
            "message": ""
          },
          {
            "path": "pycamunda\\migration.py",
            "lineno": 304,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Execute(url='http://localhost/engine-rest/migration/executeAsync', migration_plan=MigrationPlan(source_process_definit...rId'], update_event_trigger=False))), process_instance_ids=['anId'], skip_custom_listeners=True, skip_io_mappings=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18EF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D10B5B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D10BC90>\nbody = '{\"migrationPlan\": {\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"..., \"updateEventTrigger\": false}]}, \"processInstanceIds\": [\"anId\"], \"skipCustomListeners\": true, \"skipIoMappings\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\nmy_plan_json = {'instructions': [{'sourceActivityIds': ['anId'], 'targetActivityIds': ['anotherId'], 'updateEventTrigger': False}, {'...therId'], 'updateEventTrigger': False}], 'sourceProcessDefinitionId': 'anId', 'targetProcessDefinitionId': 'anotherId'}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_execute_async_returns_batch(engine_url, my_plan_json):\n        migration_plan = pycamunda.migration.MigrationPlan.load(data=my_plan_json)\n        execute_migration = pycamunda.migration.Execute.from_migration_plan(\n            url=engine_url,\n            migration_plan=migration_plan,\n            process_instance_ids=['anId'],\n            skip_custom_listeners=True,\n            skip_io_mappings=True,\n            async_=True\n        )\n>       batch = execute_migration()\n\ntests\\migration\\test_execute.py:168: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\migration.py:304: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Execute(url='http://localhost/engine-rest/migration/executeAsync', migration_plan=MigrationPlan(source_process_definit...rId'], update_event_trigger=False))), process_instance_ids=['anId'], skip_custom_listeners=True, skip_io_mappings=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18EF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D10B5B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D10BC90>\nbody = '{\"migrationPlan\": {\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"..., \"updateEventTrigger\": false}]}, \"processInstanceIds\": [\"anId\"], \"skipCustomListeners\": true, \"skipIoMappings\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_generate.py::test_generate_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_generate_params",
        "test_generate.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_generate.py::test_generate_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_generate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_generate.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\migration\\test_generate.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\migration.py",
            "lineno": 97,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Generate(url='http://localhost/engine-rest/migration/generate', source_process_definition_id='anId', target_process_definition_id='anotherId', update_event_triggers=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18A70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0FC040>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0FC090>\nbody = '{\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"updateEventTriggers\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200236914928'>\nengine_url = 'http://localhost/engine-rest'\ngenerate_input = {'source_process_definition_id': 'anId', 'target_process_definition_id': 'anotherId', 'update_event_triggers': True}\n\n    @unittest.mock.patch('pycamunda.migration.MigrationPlan', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_generate_calls_requests(mock, engine_url, generate_input):\n        generate_migration = pycamunda.migration.Generate(url=engine_url, **generate_input)\n>       generate_migration()\n\ntests\\migration\\test_generate.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\migration.py:97: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Generate(url='http://localhost/engine-rest/migration/generate', source_process_definition_id='anId', target_process_definition_id='anotherId', update_event_triggers=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18A70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0FC040>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0FC090>\nbody = '{\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"updateEventTriggers\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_generate.py::test_generate_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_generate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_generate.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_generate.py::test_generate_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_generate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_generate.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\migration\\test_generate.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\migration.py",
            "lineno": 97,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Generate(url='http://localhost/engine-rest/migration/generate', source_process_definition_id='anId', target_process_definition_id='anotherId', update_event_triggers=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0FC770>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0FD6C0>\nbody = '{\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"updateEventTriggers\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200238161504'>\nengine_url = 'http://localhost/engine-rest'\ngenerate_input = {'source_process_definition_id': 'anId', 'target_process_definition_id': 'anotherId', 'update_event_triggers': True}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.migration.MigrationPlan', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_generate_raises_for_status(mock, engine_url, generate_input):\n        generate_migration = pycamunda.migration.Generate(url=engine_url, **generate_input)\n>       generate_migration()\n\ntests\\migration\\test_generate.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\migration.py:97: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Generate(url='http://localhost/engine-rest/migration/generate', source_process_definition_id='anId', target_process_definition_id='anotherId', update_event_triggers=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0FC770>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0FD6C0>\nbody = '{\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"updateEventTriggers\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_generate.py::test_generate_returns_migrationplan",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_generate_returns_migrationplan",
        "__wrapped__",
        "patchings",
        "test_generate.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\migration\\test_generate.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\migration.py",
            "lineno": 97,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Generate(url='http://localhost/engine-rest/migration/generate', source_process_definition_id='anId', target_process_definition_id='anotherId', update_event_triggers=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0FDBC0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0FDC10>\nbody = '{\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"updateEventTriggers\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\ngenerate_input = {'source_process_definition_id': 'anId', 'target_process_definition_id': 'anotherId', 'update_event_triggers': True}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_generate_returns_migrationplan(engine_url, generate_input):\n        generate_migration = pycamunda.migration.Generate(url=engine_url, **generate_input)\n>       migration_plan = generate_migration()\n\ntests\\migration\\test_generate.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\migration.py:97: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Generate(url='http://localhost/engine-rest/migration/generate', source_process_definition_id='anId', target_process_definition_id='anotherId', update_event_triggers=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0FDBC0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0FDC10>\nbody = '{\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"updateEventTriggers\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_instructionreport.py::test_instructionreport_load_definition",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_instructionreport_load_definition",
        "test_instructionreport.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_instructionreport.py::test_instructionreport_load_raises_key_error",
      "lineno": 17,
      "outcome": "passed",
      "keywords": [
        "test_instructionreport_load_raises_key_error",
        "test_instructionreport.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_migrationinstruction.py::test_migrationinstruction_load_definition",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_migrationinstruction_load_definition",
        "test_migrationinstruction.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_migrationinstruction.py::test_migrationinstruction_load_raises_key_error",
      "lineno": 16,
      "outcome": "passed",
      "keywords": [
        "test_migrationinstruction_load_raises_key_error",
        "test_migrationinstruction.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_migrationplan.py::test_migrationplan_load_definition",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_migrationplan_load_definition",
        "test_migrationplan.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_migrationplan.py::test_migrationplan_load_raises_key_error",
      "lineno": 19,
      "outcome": "passed",
      "keywords": [
        "test_migrationplan_load_raises_key_error",
        "test_migrationplan.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_validate.py::test_validate_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_validate_params",
        "test_validate.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_validate.py::test_validate_from_migration_plan_params",
      "lineno": 35,
      "outcome": "passed",
      "keywords": [
        "test_validate_from_migration_plan_params",
        "test_validate.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_validate.py::test_validate_calls_requests",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_validate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_validate.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2490 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\migration\\test_validate.py",
            "lineno": 53,
            "message": ""
          },
          {
            "path": "pycamunda\\migration.py",
            "lineno": 176,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Validate(url='http://localhost/engine-rest/migration/validate', source_process_definition_id='anId', target_process_de...e), MigrationInstruction(source_activity_ids=['anId'], target_activity_ids=['anotherId'], update_event_trigger=False)))\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0A4AE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0A4B30>\nbody = '{\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"sourceActivityIds\"...ntTrigger\": false}, {\"sourceActivityIds\": [\"anId\"], \"targetActivityIds\": [\"anotherId\"], \"updateEventTrigger\": false}]}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2490 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200238027792'>\nengine_url = 'http://localhost/engine-rest'\nmy_plan_json = {'instructions': [{'sourceActivityIds': ['anId'], 'targetActivityIds': ['anotherId'], 'updateEventTrigger': False}, {'...therId'], 'updateEventTrigger': False}], 'sourceProcessDefinitionId': 'anId', 'targetProcessDefinitionId': 'anotherId'}\n\n    @unittest.mock.patch('pycamunda.migration.InstructionReport', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_validate_calls_requests(mock, engine_url, my_plan_json):\n        migration_plan = pycamunda.migration.MigrationPlan.load(data=my_plan_json)\n        validate_migration = pycamunda.migration.Validate.from_migration_plan(\n            url=engine_url,\n            migration_plan=migration_plan\n        )\n>       validate_migration()\n\ntests\\migration\\test_validate.py:53: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\migration.py:176: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Validate(url='http://localhost/engine-rest/migration/validate', source_process_definition_id='anId', target_process_de...e), MigrationInstruction(source_activity_ids=['anId'], target_activity_ids=['anotherId'], update_event_trigger=False)))\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0A4AE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0A4B30>\nbody = '{\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"sourceActivityIds\"...ntTrigger\": false}, {\"sourceActivityIds\": [\"anId\"], \"targetActivityIds\": [\"anotherId\"], \"updateEventTrigger\": false}]}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2490 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_validate.py::test_validate_raises_pycamunda_exception",
      "lineno": 58,
      "outcome": "passed",
      "keywords": [
        "test_validate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_validate.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_validate.py::test_validate_raises_for_status",
      "lineno": 68,
      "outcome": "failed",
      "keywords": [
        "test_validate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_validate.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\migration\\test_validate.py",
            "lineno": 77,
            "message": ""
          },
          {
            "path": "pycamunda\\migration.py",
            "lineno": 176,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Validate(url='http://localhost/engine-rest/migration/validate', source_process_definition_id='anId', target_process_de...e), MigrationInstruction(source_activity_ids=['anId'], target_activity_ids=['anotherId'], update_event_trigger=False)))\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1EB30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0A5580>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0A5440>\nbody = '{\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"sourceActivityIds\"...ntTrigger\": false}, {\"sourceActivityIds\": [\"anId\"], \"targetActivityIds\": [\"anotherId\"], \"updateEventTrigger\": false}]}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200238164912'>\nengine_url = 'http://localhost/engine-rest'\nmy_plan_json = {'instructions': [{'sourceActivityIds': ['anId'], 'targetActivityIds': ['anotherId'], 'updateEventTrigger': False}, {'...therId'], 'updateEventTrigger': False}], 'sourceProcessDefinitionId': 'anId', 'targetProcessDefinitionId': 'anotherId'}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.migration.InstructionReport', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_validate_raises_for_status(mock, engine_url, my_plan_json):\n        migration_plan = pycamunda.migration.MigrationPlan.load(data=my_plan_json)\n        validate_migration = pycamunda.migration.Validate.from_migration_plan(\n            url=engine_url, migration_plan=migration_plan\n        )\n>       validate_migration()\n\ntests\\migration\\test_validate.py:77: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\migration.py:176: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Validate(url='http://localhost/engine-rest/migration/validate', source_process_definition_id='anId', target_process_de...e), MigrationInstruction(source_activity_ids=['anId'], target_activity_ids=['anotherId'], update_event_trigger=False)))\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1EB30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0A5580>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0A5440>\nbody = '{\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"sourceActivityIds\"...ntTrigger\": false}, {\"sourceActivityIds\": [\"anId\"], \"targetActivityIds\": [\"anotherId\"], \"updateEventTrigger\": false}]}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/migration/test_validate.py::test_validate_returns_migrationplan",
      "lineno": 81,
      "outcome": "failed",
      "keywords": [
        "test_validate_returns_migrationplan",
        "__wrapped__",
        "patchings",
        "test_validate.py",
        "migration",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2520 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\migration\\test_validate.py",
            "lineno": 88,
            "message": ""
          },
          {
            "path": "pycamunda\\migration.py",
            "lineno": 176,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Validate(url='http://localhost/engine-rest/migration/validate', source_process_definition_id='anId', target_process_de...e), MigrationInstruction(source_activity_ids=['anId'], target_activity_ids=['anotherId'], update_event_trigger=False)))\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18A70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0A6160>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0A60C0>\nbody = '{\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"sourceActivityIds\"...ntTrigger\": false}, {\"sourceActivityIds\": [\"anId\"], \"targetActivityIds\": [\"anotherId\"], \"updateEventTrigger\": false}]}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2520 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\nmy_plan_json = {'instructions': [{'sourceActivityIds': ['anId'], 'targetActivityIds': ['anotherId'], 'updateEventTrigger': False}, {'...therId'], 'updateEventTrigger': False}], 'sourceProcessDefinitionId': 'anId', 'targetProcessDefinitionId': 'anotherId'}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_validate_returns_migrationplan(engine_url, my_plan_json):\n        migration_plan = pycamunda.migration.MigrationPlan.load(data=my_plan_json)\n        validate_migration = pycamunda.migration.Validate.from_migration_plan(\n            url=engine_url, migration_plan=migration_plan\n        )\n>       instruction_reports = validate_migration()\n\ntests\\migration\\test_validate.py:88: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\migration.py:176: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Validate(url='http://localhost/engine-rest/migration/validate', source_process_definition_id='anId', target_process_de...e), MigrationInstruction(source_activity_ids=['anId'], target_activity_ids=['anotherId'], update_event_trigger=False)))\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18A70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0A6160>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0A60C0>\nbody = '{\"sourceProcessDefinitionId\": \"anId\", \"targetProcessDefinitionId\": \"anotherId\", \"instructions\": [{\"sourceActivityIds\"...ntTrigger\": false}, {\"sourceActivityIds\": [\"anId\"], \"targetActivityIds\": [\"anotherId\"], \"updateEventTrigger\": false}]}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2520 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py::test_activate_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_activate_params",
        "test_activatesuspend.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py::test_activate_path",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_activate_path",
        "test_activatesuspend.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py::test_activate_calls_requests",
      "lineno": 42,
      "outcome": "failed",
      "keywords": [
        "test_activate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2302 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_activatesuspend.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 827,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Activate(url='http://localhost/engine-rest/process-definition/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0A6250>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0A6CF0>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2302 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200236862928'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_activate_calls_requests(mock, engine_url):\n        activate_definition = pycamunda.processdef.Activate(url=engine_url, id_='anId')\n>       activate_definition()\n\ntests\\processdef\\test_activatesuspend.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:827: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Activate(url='http://localhost/engine-rest/process-definition/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D0A6250>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D0A6CF0>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2302 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py::test_activate_raises_pycamunda_exception",
      "lineno": 51,
      "outcome": "passed",
      "keywords": [
        "test_activate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py::test_activate_raises_for_status",
      "lineno": 58,
      "outcome": "failed",
      "keywords": [
        "test_activate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_activatesuspend.py",
            "lineno": 63,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 827,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Activate(url='http://localhost/engine-rest/process-definition/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E230>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1A61B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1A5440>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200238042672'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_activate_raises_for_status(mock, engine_url):\n        activate_definition = pycamunda.processdef.Activate(url=engine_url, id_='anId')\n>       activate_definition()\n\ntests\\processdef\\test_activatesuspend.py:63: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:827: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Activate(url='http://localhost/engine-rest/process-definition/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E230>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1A61B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1A5440>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py::test_activate_returns_none",
      "lineno": 67,
      "outcome": "failed",
      "keywords": [
        "test_activate_returns_none",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2596 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_activatesuspend.py",
            "lineno": 71,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 827,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Activate(url='http://localhost/engine-rest/process-definition/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C070>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1A6B60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1A69D0>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2596 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_activate_returns_none(engine_url):\n        activate_definition = pycamunda.processdef.Activate(url=engine_url, id_='anId')\n>       result = activate_definition()\n\ntests\\processdef\\test_activatesuspend.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:827: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Activate(url='http://localhost/engine-rest/process-definition/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C070>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1A6B60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1A69D0>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2596 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py::test_suspend_params",
      "lineno": 75,
      "outcome": "passed",
      "keywords": [
        "test_suspend_params",
        "test_activatesuspend.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py::test_suspend_path",
      "lineno": 92,
      "outcome": "passed",
      "keywords": [
        "test_suspend_path",
        "test_activatesuspend.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py::test_suspend_calls_requests",
      "lineno": 105,
      "outcome": "failed",
      "keywords": [
        "test_suspend_calls_requests",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2389 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_activatesuspend.py",
            "lineno": 109,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 827,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Suspend(url='http://localhost/engine-rest/process-definition/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1A7A10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1A7A60>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2389 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200205563392'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_suspend_calls_requests(mock, engine_url):\n        suspend_definition = pycamunda.processdef.Suspend(url=engine_url, id_='anId')\n>       suspend_definition()\n\ntests\\processdef\\test_activatesuspend.py:109: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:827: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Suspend(url='http://localhost/engine-rest/process-definition/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1A7A10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1A7A60>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2389 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py::test_suspend_raises_pycamunda_exception",
      "lineno": 113,
      "outcome": "passed",
      "keywords": [
        "test_suspend_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py::test_suspend_raises_for_status",
      "lineno": 120,
      "outcome": "failed",
      "keywords": [
        "test_suspend_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2360 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_activatesuspend.py",
            "lineno": 125,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 827,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Suspend(url='http://localhost/engine-rest/process-definition/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18A70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1CC310>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1CCAE0>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2360 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200237541216'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_suspend_raises_for_status(mock, engine_url):\n        suspend_definition = pycamunda.processdef.Suspend(url=engine_url, id_='anId')\n>       suspend_definition()\n\ntests\\processdef\\test_activatesuspend.py:125: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:827: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Suspend(url='http://localhost/engine-rest/process-definition/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18A70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1CC310>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1CCAE0>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2360 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activatesuspend.py::test_suspend_returns_none",
      "lineno": 129,
      "outcome": "failed",
      "keywords": [
        "test_suspend_returns_none",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2423 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_activatesuspend.py",
            "lineno": 133,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 827,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Suspend(url='http://localhost/engine-rest/process-definition/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E470>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1CDE40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1CDD50>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2423 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_suspend_returns_none(engine_url):\n        suspend_definition = pycamunda.processdef.Suspend(url=engine_url, id_='anId')\n>       result = suspend_definition()\n\ntests\\processdef\\test_activatesuspend.py:133: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:827: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Suspend(url='http://localhost/engine-rest/process-definition/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E470>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1CDE40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1CDD50>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2423 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activitystats.py::test_activitystats_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_activitystats_load",
        "test_activitystats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_activitystats.py::test_activitystats_load_raises_keyerror",
      "lineno": 15,
      "outcome": "passed",
      "keywords": [
        "test_activitystats_load_raises_keyerror",
        "test_activitystats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_count.py::test_count_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_count_params",
        "test_count.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_count.py::test_count_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_count_calls_requests",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2596 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_count.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 335,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/process-definition/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1CED90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1CEDE0>\nquery_string = 'processDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2596 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200238158672'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_count_calls_requests(mock, engine_url):\n        count_definitions = pycamunda.processdef.Count(url=engine_url, id_='anId')\n>       count_definitions()\n\ntests\\processdef\\test_count.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:335: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/process-definition/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1CED90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1CEDE0>\nquery_string = 'processDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2596 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_count.py::test_count_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_count_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_count.py::test_count_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_count_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2508 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_count.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 335,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/process-definition/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2747C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D274270>\nquery_string = 'processDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2508 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200237549184'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_count_raises_for_status(mock, engine_url):\n        count_definitions = pycamunda.processdef.Count(url=engine_url, id_='anId')\n>       count_definitions()\n\ntests\\processdef\\test_count.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:335: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/process-definition/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2747C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D274270>\nquery_string = 'processDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2508 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_count.py::test_count_returns_response_content",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_count_returns_response_content",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2240 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_count.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 335,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/process-definition/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2753F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D274EA0>\nquery_string = 'processDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2240 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', count_response_mock)\n    def test_count_returns_response_content(engine_url):\n        count_definitions = pycamunda.processdef.Count(url=engine_url, id_='anId')\n>       result = count_definitions()\n\ntests\\processdef\\test_count.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:335: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/process-definition/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2753F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D274EA0>\nquery_string = 'processDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2240 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_delete.py::test_delete_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_delete_params",
        "test_delete.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_delete.py::test_delete_path",
      "lineno": 23,
      "outcome": "passed",
      "keywords": [
        "test_delete_path",
        "test_delete.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_delete.py::test_delete_calls_requests",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_delete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_delete.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 970,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/process-definition/anId', id_='anId', cascade=False, skip_custom_listeners=False, skip_io_mappings=False)\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17AB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D276840>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2767F0>\nquery_string = 'cascade=false&skipCustomListeners=false&skipIoMappings=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200240277296'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_delete_calls_requests(mock, engine_url):\n        delete_definition = pycamunda.processdef.Delete(url=engine_url, id_='anId')\n>       delete_definition()\n\ntests\\processdef\\test_delete.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:970: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/process-definition/anId', id_='anId', cascade=False, skip_custom_listeners=False, skip_io_mappings=False)\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17AB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D276840>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2767F0>\nquery_string = 'cascade=false&skipCustomListeners=false&skipIoMappings=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_delete.py::test_delete_raises_pycamunda_exception",
      "lineno": 45,
      "outcome": "passed",
      "keywords": [
        "test_delete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_delete.py::test_delete_raises_for_status",
      "lineno": 52,
      "outcome": "failed",
      "keywords": [
        "test_delete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2374 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_delete.py",
            "lineno": 57,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 970,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/process-definition/anId', id_='anId', cascade=False, skip_custom_listeners=False, skip_io_mappings=False)\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17F30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D276E30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D277CE0>\nquery_string = 'cascade=false&skipCustomListeners=false&skipIoMappings=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2374 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200237541696'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_delete_raises_for_status(mock, engine_url):\n        delete_definition = pycamunda.processdef.Delete(url=engine_url, id_='anId')\n>       delete_definition()\n\ntests\\processdef\\test_delete.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:970: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/process-definition/anId', id_='anId', cascade=False, skip_custom_listeners=False, skip_io_mappings=False)\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17F30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D276E30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D277CE0>\nquery_string = 'cascade=false&skipCustomListeners=false&skipIoMappings=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2374 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_delete.py::test_delete_returns_none",
      "lineno": 61,
      "outcome": "failed",
      "keywords": [
        "test_delete_returns_none",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_delete.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 970,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/process-definition/anId', id_='anId', cascade=False, skip_custom_listeners=False, skip_io_mappings=False)\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E8F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D274EA0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2746D0>\nquery_string = 'cascade=false&skipCustomListeners=false&skipIoMappings=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', response_mock)\n    def test_delete_returns_none(engine_url):\n        delete_definition = pycamunda.processdef.Delete(url=engine_url, id_='anId')\n>       result = delete_definition()\n\ntests\\processdef\\test_delete.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:970: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/process-definition/anId', id_='anId', cascade=False, skip_custom_listeners=False, skip_io_mappings=False)\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E8F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D274EA0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2746D0>\nquery_string = 'cascade=false&skipCustomListeners=false&skipIoMappings=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_get.py::test_get_path",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_get_path",
        "test_get.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_get.py::test_get_calls_requests",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2513 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_get.py",
            "lineno": 33,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 620,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/process-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2D59E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2D5A80>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2513 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231688048'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n        get_definition = pycamunda.processdef.Get(url=engine_url, id_='anId')\n>       get_definition()\n\ntests\\processdef\\test_get.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:620: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/process-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2D59E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2D5A80>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2513 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 38,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_get.py::test_get_raises_for_status",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_get.py",
            "lineno": 51,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 620,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/process-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C2B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2D5E40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2D67A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200240081888'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.processdef.ProcessDefinition', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_definition = pycamunda.processdef.Get(url=engine_url, id_='anId')\n>       get_definition()\n\ntests\\processdef\\test_get.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:620: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/process-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C2B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2D5E40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2D67A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_get.py::test_get_returns_processdefinition",
      "lineno": 55,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_processdefinition",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2218 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_get.py",
            "lineno": 59,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 620,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/process-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17CF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2D72E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2D7240>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2218 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_get_returns_processdefinition(engine_url):\n        get_definition = pycamunda.processdef.Get(url=engine_url, id_='anId')\n>       process_definition = get_definition()\n\ntests\\processdef\\test_get.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:620: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/process-definition/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17CF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2D72E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2D7240>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2218 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getactivityinstancestats.py::test_getactivityinstancestats_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getactivityinstancestats_params",
        "test_getactivityinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getactivityinstancestats.py::test_getactivityinstancestats_path",
      "lineno": 20,
      "outcome": "passed",
      "keywords": [
        "test_getactivityinstancestats_path",
        "test_getactivityinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getactivityinstancestats.py::test_getactivityinstancestats_calls_requests",
      "lineno": 37,
      "outcome": "failed",
      "keywords": [
        "test_getactivityinstancestats_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getactivityinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getactivityinstancestats.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 156,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetActivityInstanceStats(url='http://localhost/engine-rest/process-definition/anId/statistics', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D4B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D32CD10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D32CEA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200237551344'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getactivityinstancestats_calls_requests(mock, engine_url):\n        get_instance_stats = pycamunda.processdef.GetActivityInstanceStats(url=engine_url, id_='anId')\n>       get_instance_stats()\n\ntests\\processdef\\test_getactivityinstancestats.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:156: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetActivityInstanceStats(url='http://localhost/engine-rest/process-definition/anId/statistics', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D4B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D32CD10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D32CEA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2251 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getactivityinstancestats.py::test_getactivityinstancestats_raises_pycamunda_exception",
      "lineno": 46,
      "outcome": "passed",
      "keywords": [
        "test_getactivityinstancestats_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getactivityinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getactivityinstancestats.py::test_getactivityinstancestats_raises_for_status",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_getactivityinstancestats_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getactivityinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getactivityinstancestats.py",
            "lineno": 59,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 156,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetActivityInstanceStats(url='http://localhost/engine-rest/process-definition/anId/statistics', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D32D490>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D32CBD0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200240080640'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.processdef.ActivityStats', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getactivityinstancestats_raises_for_status(mock, engine_url):\n        get_instance_stats = pycamunda.processdef.GetActivityInstanceStats(url=engine_url, id_='anId')\n>       get_instance_stats()\n\ntests\\processdef\\test_getactivityinstancestats.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:156: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetActivityInstanceStats(url='http://localhost/engine-rest/process-definition/anId/statistics', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D32D490>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D32CBD0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getactivityinstancestats.py::test_getactivityinstancestats_returns_activitystats",
      "lineno": 63,
      "outcome": "failed",
      "keywords": [
        "test_getactivityinstancestats_returns_activitystats",
        "__wrapped__",
        "patchings",
        "test_getactivityinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2330 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getactivityinstancestats.py",
            "lineno": 67,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 156,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetActivityInstanceStats(url='http://localhost/engine-rest/process-definition/anId/statistics', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D32C1D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D32ECF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2330 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getactivityinstancestats_returns_activitystats(engine_url):\n        get_instance_stats = pycamunda.processdef.GetActivityInstanceStats(url=engine_url, id_='anId')\n>       instance_stats = get_instance_stats()\n\ntests\\processdef\\test_getactivityinstancestats.py:67: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:156: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetActivityInstanceStats(url='http://localhost/engine-rest/process-definition/anId/statistics', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D32C1D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D32ECF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2330 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getlist.py::test_getlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2406 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getlist.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 523,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/process-definition', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18830>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D32FE20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D32FE70>\nquery_string = 'processDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2406 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200205838272'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_definitions = pycamunda.processdef.GetList(url=engine_url, id_='anId')\n>       get_definitions()\n\ntests\\processdef\\test_getlist.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:523: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/process-definition', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18830>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D32FE20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D32FE70>\nquery_string = 'processDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2406 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2392 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getlist.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 523,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/process-definition', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D284FE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D284D10>\nquery_string = 'processDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2392 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200238040848'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.processdef.ProcessDefinition', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_definitions = pycamunda.processdef.GetList(url=engine_url, id_='anId')\n>       get_definitions()\n\ntests\\processdef\\test_getlist.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:523: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/process-definition', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D284FE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D284D10>\nquery_string = 'processDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2392 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getlist.py::test_getlist_returns_response_content",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_response_content",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2383 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getlist.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 523,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/process-definition', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D285D50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D285800>\nquery_string = 'processDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2383 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getlist_returns_response_content(engine_url):\n        get_definitions = pycamunda.processdef.GetList(url=engine_url, id_='anId')\n>       definitions = get_definitions()\n\ntests\\processdef\\test_getlist.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:523: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/process-definition', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D285D50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D285800>\nquery_string = 'processDefinitionId=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2383 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessdiagram.py::test_getprocessdiagram_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getprocessdiagram_params",
        "test_getprocessdiagram.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessdiagram.py::test_getprocessdiagram_path",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_getprocessdiagram_path",
        "test_getprocessdiagram.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessdiagram.py::test_getprocessdiagram_calls_requests",
      "lineno": 31,
      "outcome": "failed",
      "keywords": [
        "test_getprocessdiagram_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getprocessdiagram.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2378 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getprocessdiagram.py",
            "lineno": 35,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 181,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetProcessDiagram(url='http://localhost/engine-rest/process-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2871A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D287150>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2378 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200239712208'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getprocessdiagram_calls_requests(mock, engine_url):\n        get_process_diagram = pycamunda.processdef.GetProcessDiagram(url=engine_url, id_='anId')\n>       get_process_diagram()\n\ntests\\processdef\\test_getprocessdiagram.py:35: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:181: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetProcessDiagram(url='http://localhost/engine-rest/process-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2871A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D287150>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2378 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessdiagram.py::test_getprocessdiagram_raises_pycamunda_exception",
      "lineno": 40,
      "outcome": "passed",
      "keywords": [
        "test_getprocessdiagram_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getprocessdiagram.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessdiagram.py::test_getprocessdiagram_raises_for_status",
      "lineno": 47,
      "outcome": "failed",
      "keywords": [
        "test_getprocessdiagram_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getprocessdiagram.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2624 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getprocessdiagram.py",
            "lineno": 53,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 181,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetProcessDiagram(url='http://localhost/engine-rest/process-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D32FF10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D32FE70>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2624 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200239705776'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.processdef.ActivityStats', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getprocessdiagram_raises_for_status(mock, engine_url):\n        get_process_diagram = pycamunda.processdef.GetProcessDiagram(url=engine_url, id_='anId')\n>       get_process_diagram()\n\ntests\\processdef\\test_getprocessdiagram.py:53: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:181: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetProcessDiagram(url='http://localhost/engine-rest/process-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D32FF10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D32FE70>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2624 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessdiagram.py::test_getprocessdiagram_returns_response_content",
      "lineno": 57,
      "outcome": "failed",
      "keywords": [
        "test_getprocessdiagram_returns_response_content",
        "__wrapped__",
        "patchings",
        "test_getprocessdiagram.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2441 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getprocessdiagram.py",
            "lineno": 61,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 181,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetProcessDiagram(url='http://localhost/engine-rest/process-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D10A8E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D10AC00>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2441 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', response_mock)\n    def test_getprocessdiagram_returns_response_content(engine_url):\n        get_process_diagram = pycamunda.processdef.GetProcessDiagram(url=engine_url, id_='anId')\n>       result = get_process_diagram()\n\ntests\\processdef\\test_getprocessdiagram.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:181: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetProcessDiagram(url='http://localhost/engine-rest/process-definition/anId/diagram', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D10A8E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D10AC00>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2441 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagram_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_getprocessdiagram_params",
        "test_getprocessinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagram_path",
      "lineno": 21,
      "outcome": "passed",
      "keywords": [
        "test_getprocessdiagram_path",
        "test_getprocessinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagramm_raises_exception_on_invalid_inputs",
      "lineno": 44,
      "outcome": "passed",
      "keywords": [
        "test_getprocessdiagramm_raises_exception_on_invalid_inputs",
        "test_getprocessinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagram_calls_requests",
      "lineno": 70,
      "outcome": "failed",
      "keywords": [
        "test_getprocessdiagram_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getprocessinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2570 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getprocessinstancestats.py",
            "lineno": 74,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 567,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetProcessInstanceStats(url='http://localhost/engine-rest/process-definition/statistics', failed_jobs=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D294720>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D294810>\nquery_string = 'failedJobs=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2570 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200240280944'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getprocessdiagram_calls_requests(mock, engine_url):\n        get_process_instance_stats = pycamunda.processdef.GetProcessInstanceStats(url=engine_url)\n>       get_process_instance_stats()\n\ntests\\processdef\\test_getprocessinstancestats.py:74: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:567: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetProcessInstanceStats(url='http://localhost/engine-rest/process-definition/statistics', failed_jobs=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D294720>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D294810>\nquery_string = 'failedJobs=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2570 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagram_raises_pycamunda_exception",
      "lineno": 79,
      "outcome": "passed",
      "keywords": [
        "test_getprocessdiagram_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getprocessinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagram_raises_for_status",
      "lineno": 86,
      "outcome": "failed",
      "keywords": [
        "test_getprocessdiagram_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getprocessinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2411 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getprocessinstancestats.py",
            "lineno": 92,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 181,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetProcessDiagram(url='http://localhost/engine-rest/process-definition/key/None/diagram')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D294900>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2959E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2411 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200238031536'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.processdef.ActivityStats', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getprocessdiagram_raises_for_status(mock, engine_url):\n        get_process_instance_stats = pycamunda.processdef.GetProcessDiagram(url=engine_url)\n>       get_process_instance_stats()\n\ntests\\processdef\\test_getprocessinstancestats.py:92: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:181: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetProcessDiagram(url='http://localhost/engine-rest/process-definition/key/None/diagram')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D294900>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2959E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2411 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getprocessinstancestats.py::test_getprocessdiagram_returns_response_content",
      "lineno": 96,
      "outcome": "failed",
      "keywords": [
        "test_getprocessdiagram_returns_response_content",
        "__wrapped__",
        "patchings",
        "test_getprocessinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getprocessinstancestats.py",
            "lineno": 100,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 181,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetProcessDiagram(url='http://localhost/engine-rest/process-definition/key/None/diagram')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D295CB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D296B10>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', response_mock)\n    def test_getprocessdiagram_returns_response_content(engine_url):\n        get_process_instance_stats = pycamunda.processdef.GetProcessDiagram(url=engine_url)\n>       result = get_process_instance_stats()\n\ntests\\processdef\\test_getprocessinstancestats.py:100: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:181: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetProcessDiagram(url='http://localhost/engine-rest/process-definition/key/None/diagram')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D295CB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D296B10>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getxml.py::test_getxml_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getxml_params",
        "test_getxml.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getxml.py::test_getxml_path",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_getxml_path",
        "test_getxml.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getxml.py::test_getxml_calls_requests",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_getxml_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getxml.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2263 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getxml.py",
            "lineno": 32,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 593,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetXML(url='http://localhost/engine-rest/process-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D297600>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2975B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2263 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200240279792'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getxml_calls_requests(mock, engine_url):\n        get_xml = pycamunda.processdef.GetXML(url=engine_url, id_='anId')\n>       get_xml()\n\ntests\\processdef\\test_getxml.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:593: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetXML(url='http://localhost/engine-rest/process-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D297600>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2975B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2263 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getxml.py::test_getxml_raises_pycamunda_exception",
      "lineno": 37,
      "outcome": "passed",
      "keywords": [
        "test_getxml_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getxml.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getxml.py::test_getxml_raises_for_status",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_getxml_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getxml.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getxml.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 593,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetXML(url='http://localhost/engine-rest/process-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D24CBD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D24C040>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200239701168'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getxml_raises_for_status(mock, engine_url):\n        get_xml = pycamunda.processdef.GetXML(url=engine_url, id_='anId')\n>       get_xml()\n\ntests\\processdef\\test_getxml.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:593: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetXML(url='http://localhost/engine-rest/process-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D24CBD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D24C040>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_getxml.py::test_getxml_returns_bpmn20Xml",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_getxml_returns_bpmn20Xml",
        "__wrapped__",
        "patchings",
        "test_getxml.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_getxml.py",
            "lineno": 57,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 593,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetXML(url='http://localhost/engine-rest/process-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D24D1C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D24D120>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', response_mock)\n    def test_getxml_returns_bpmn20Xml(engine_url):\n        get_xml = pycamunda.processdef.GetXML(url=engine_url, id_='anId')\n>       result = get_xml()\n\ntests\\processdef\\test_getxml.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:593: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetXML(url='http://localhost/engine-rest/process-definition/anId/xml', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D24D1C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D24D120>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_processdef.py::test_processdefinition_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_processdefinition_load",
        "test_processdef.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_processdef.py::test_processdefinition_load_raises_keyerror",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_processdefinition_load_raises_keyerror",
        "test_processdef.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_processinstancestats.py::test_processinstancestats_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_processinstancestats_load",
        "test_processinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_processinstancestats.py::test_processinstancestats_load_raises_keyerror",
      "lineno": 19,
      "outcome": "passed",
      "keywords": [
        "test_processinstancestats_load_raises_keyerror",
        "test_processinstancestats.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_restartprocessinstance.py::test_restartprocessinstance_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_restartprocessinstance_params",
        "test_restartprocessinstance.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_restartprocessinstance.py::test_restartprocessinstance_calls_requests",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_restartprocessinstance_calls_requests",
        "__wrapped__",
        "patchings",
        "test_restartprocessinstance.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_restartprocessinstance.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 1079,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = RestartProcessInstance(url='http://localhost/engine-rest/process-definition/anId/restart', id_='anId', process_instanc...ip_custom_listeners=False, skip_io_mappings=False, initial_variables=True, without_business_key=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C070>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D24FC40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D24FC90>\nbody = '{\"historicProcessInstanceQuery\": {}, \"processInstanceIds\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"initialVariables\": true, \"withoutBusinessKey\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200236856112'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_restartprocessinstance_calls_requests(mock, engine_url):\n        start_instance = pycamunda.processdef.RestartProcessInstance(\n            url=engine_url, id_='anId', process_instance_ids=[]\n        )\n>       start_instance()\n\ntests\\processdef\\test_restartprocessinstance.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:1079: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = RestartProcessInstance(url='http://localhost/engine-rest/process-definition/anId/restart', id_='anId', process_instanc...ip_custom_listeners=False, skip_io_mappings=False, initial_variables=True, without_business_key=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C070>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D24FC40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D24FC90>\nbody = '{\"historicProcessInstanceQuery\": {}, \"processInstanceIds\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"initialVariables\": true, \"withoutBusinessKey\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_restartprocessinstance.py::test_restartprocessinstance_raises_pycamunda_exception",
      "lineno": 55,
      "outcome": "passed",
      "keywords": [
        "test_restartprocessinstance_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_restartprocessinstance.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_restartprocessinstance.py::test_restartprocessinstance_raises_for_status",
      "lineno": 64,
      "outcome": "failed",
      "keywords": [
        "test_restartprocessinstance_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_restartprocessinstance.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_restartprocessinstance.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 1079,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = RestartProcessInstance(url='http://localhost/engine-rest/process-definition/anId/restart', id_='anId', process_instanc...ip_custom_listeners=False, skip_io_mappings=False, initial_variables=True, without_business_key=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D4B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2C8BD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2C8720>\nbody = '{\"historicProcessInstanceQuery\": {}, \"processInstanceIds\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"initialVariables\": true, \"withoutBusinessKey\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200239701168'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.processinst.ProcessInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_restartprocessinstance_raises_for_status(mock, engine_url):\n        restart_instance = pycamunda.processdef.RestartProcessInstance(\n            url=engine_url, id_='anId', process_instance_ids=[]\n        )\n>       restart_instance()\n\ntests\\processdef\\test_restartprocessinstance.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:1079: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = RestartProcessInstance(url='http://localhost/engine-rest/process-definition/anId/restart', id_='anId', process_instanc...ip_custom_listeners=False, skip_io_mappings=False, initial_variables=True, without_business_key=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D4B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2C8BD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2C8720>\nbody = '{\"historicProcessInstanceQuery\": {}, \"processInstanceIds\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"initialVariables\": true, \"withoutBusinessKey\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_restartprocessinstance.py::test_restartprocessinstance_returns_none",
      "lineno": 76,
      "outcome": "failed",
      "keywords": [
        "test_restartprocessinstance_returns_none",
        "__wrapped__",
        "patchings",
        "test_restartprocessinstance.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_restartprocessinstance.py",
            "lineno": 82,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 1079,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = RestartProcessInstance(url='http://localhost/engine-rest/process-definition/anId/restart', id_='anId', process_instanc...ip_custom_listeners=False, skip_io_mappings=False, initial_variables=True, without_business_key=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2C8C20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2C8A90>\nbody = '{\"historicProcessInstanceQuery\": {}, \"processInstanceIds\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"initialVariables\": true, \"withoutBusinessKey\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_restartprocessinstance_returns_none(engine_url):\n        restart_instance = pycamunda.processdef.RestartProcessInstance(\n            url=engine_url, id_='anId', process_instance_ids=[]\n        )\n>       result = restart_instance()\n\ntests\\processdef\\test_restartprocessinstance.py:82: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:1079: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = RestartProcessInstance(url='http://localhost/engine-rest/process-definition/anId/restart', id_='anId', process_instanc...ip_custom_listeners=False, skip_io_mappings=False, initial_variables=True, without_business_key=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2C8C20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2C8A90>\nbody = '{\"historicProcessInstanceQuery\": {}, \"processInstanceIds\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"initialVariables\": true, \"withoutBusinessKey\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_restartprocessinstance.py::test_restartprocessinstance_async_returns_batch",
      "lineno": 86,
      "outcome": "failed",
      "keywords": [
        "test_restartprocessinstance_async_returns_batch",
        "__wrapped__",
        "patchings",
        "test_restartprocessinstance.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2240 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_restartprocessinstance.py",
            "lineno": 92,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 1079,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = RestartProcessInstance(url='http://localhost/engine-rest/process-definition/anId/restart-async', id_='anId', process_i...ip_custom_listeners=False, skip_io_mappings=False, initial_variables=True, without_business_key=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AE70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2C8FE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2C8CC0>\nbody = '{\"historicProcessInstanceQuery\": {}, \"processInstanceIds\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"initialVariables\": true, \"withoutBusinessKey\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2240 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_restartprocessinstance_async_returns_batch(engine_url):\n        restart_instance = pycamunda.processdef.RestartProcessInstance(\n            url=engine_url, id_='anId', process_instance_ids=[], async_=True\n        )\n>       batch = restart_instance()\n\ntests\\processdef\\test_restartprocessinstance.py:92: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:1079: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = RestartProcessInstance(url='http://localhost/engine-rest/process-definition/anId/restart-async', id_='anId', process_i...ip_custom_listeners=False, skip_io_mappings=False, initial_variables=True, without_business_key=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AE70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2C8FE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2C8CC0>\nbody = '{\"historicProcessInstanceQuery\": {}, \"processInstanceIds\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"initialVariables\": true, \"withoutBusinessKey\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2240 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_startinstance.py::test_startinstance_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_startinstance_params",
        "test_startinstance.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_startinstance.py::test_startinstance_path",
      "lineno": 39,
      "outcome": "passed",
      "keywords": [
        "test_startinstance_path",
        "test_startinstance.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_startinstance.py::test_startinstance_calls_requests",
      "lineno": 56,
      "outcome": "failed",
      "keywords": [
        "test_startinstance_calls_requests",
        "__wrapped__",
        "patchings",
        "test_startinstance.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_startinstance.py",
            "lineno": 60,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 782,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = StartInstance(url='http://localhost/engine-rest/process-definition/anId/start', id_='anId', variables={}, start_instructions=[], skip_custom_listeners=False, skip_io_mappings=False, with_variables_in_return=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17AB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2CBC40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2CBCE0>\nbody = '{\"variables\": {}, \"startInstructions\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"withVariablesInReturn\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200240086400'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_startinstance_calls_requests(mock, engine_url):\n        start_instance = pycamunda.processdef.StartInstance(url=engine_url, id_='anId')\n>       start_instance()\n\ntests\\processdef\\test_startinstance.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:782: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = StartInstance(url='http://localhost/engine-rest/process-definition/anId/start', id_='anId', variables={}, start_instructions=[], skip_custom_listeners=False, skip_io_mappings=False, with_variables_in_return=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17AB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2CBC40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2CBCE0>\nbody = '{\"variables\": {}, \"startInstructions\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"withVariablesInReturn\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_startinstance.py::test_startinstance_raises_pycamunda_exception",
      "lineno": 65,
      "outcome": "passed",
      "keywords": [
        "test_startinstance_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_startinstance.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_startinstance.py::test_startinstance_raises_for_status",
      "lineno": 72,
      "outcome": "failed",
      "keywords": [
        "test_startinstance_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_startinstance.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2265 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_startinstance.py",
            "lineno": 78,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 782,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = StartInstance(url='http://localhost/engine-rest/process-definition/anId/start', id_='anId', variables={}, start_instructions=[], skip_custom_listeners=False, skip_io_mappings=False, with_variables_in_return=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D304F40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D304C70>\nbody = '{\"variables\": {}, \"startInstructions\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"withVariablesInReturn\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2265 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200238041952'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.processinst.ProcessInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_startinstance_raises_for_status(mock, engine_url):\n        start_instance = pycamunda.processdef.StartInstance(url=engine_url, id_='anId')\n>       start_instance()\n\ntests\\processdef\\test_startinstance.py:78: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:782: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = StartInstance(url='http://localhost/engine-rest/process-definition/anId/start', id_='anId', variables={}, start_instructions=[], skip_custom_listeners=False, skip_io_mappings=False, with_variables_in_return=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D304F40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D304C70>\nbody = '{\"variables\": {}, \"startInstructions\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"withVariablesInReturn\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2265 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_startinstance.py::test_startinstance_returns_activitystats",
      "lineno": 82,
      "outcome": "failed",
      "keywords": [
        "test_startinstance_returns_activitystats",
        "__wrapped__",
        "patchings",
        "test_startinstance.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_startinstance.py",
            "lineno": 86,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 782,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = StartInstance(url='http://localhost/engine-rest/process-definition/anId/start', id_='anId', variables={}, start_instructions=[], skip_custom_listeners=False, skip_io_mappings=False, with_variables_in_return=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE16F70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D306110>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D304FE0>\nbody = '{\"variables\": {}, \"startInstructions\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"withVariablesInReturn\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_startinstance_returns_activitystats(engine_url):\n        start_instance = pycamunda.processdef.StartInstance(url=engine_url, id_='anId')\n>       instance = start_instance()\n\ntests\\processdef\\test_startinstance.py:86: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:782: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = StartInstance(url='http://localhost/engine-rest/process-definition/anId/start', id_='anId', variables={}, start_instructions=[], skip_custom_listeners=False, skip_io_mappings=False, with_variables_in_return=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE16F70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D306110>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D304FE0>\nbody = '{\"variables\": {}, \"startInstructions\": [], \"skipCustomListeners\": false, \"skipIoMappings\": false, \"withVariablesInReturn\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_updatehistorytimetolive_params",
        "test_updatehistorytimetolive.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_path",
      "lineno": 21,
      "outcome": "passed",
      "keywords": [
        "test_updatehistorytimetolive_path",
        "test_updatehistorytimetolive.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_calls_requests",
      "lineno": 39,
      "outcome": "failed",
      "keywords": [
        "test_updatehistorytimetolive_calls_requests",
        "__wrapped__",
        "patchings",
        "test_updatehistorytimetolive.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2287 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_updatehistorytimetolive.py",
            "lineno": 45,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 927,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UpdateHistoryTimeToLive(url='http://localhost/engine-rest/process-definition/anId/history-time-to-live', id_='anId', history_time_to_live=10)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CBB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D307010>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3071F0>\nbody = '{\"historyTimeToLive\": 10}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2287 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200237547552'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_updatehistorytimetolive_calls_requests(mock, engine_url):\n        update_definition = pycamunda.processdef.UpdateHistoryTimeToLive(\n            url=engine_url, id_='anId', history_time_to_live=10\n        )\n>       update_definition()\n\ntests\\processdef\\test_updatehistorytimetolive.py:45: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:927: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UpdateHistoryTimeToLive(url='http://localhost/engine-rest/process-definition/anId/history-time-to-live', id_='anId', history_time_to_live=10)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CBB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D307010>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3071F0>\nbody = '{\"historyTimeToLive\": 10}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2287 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_raises_pycamunda_exception",
      "lineno": 50,
      "outcome": "passed",
      "keywords": [
        "test_updatehistorytimetolive_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_updatehistorytimetolive.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_raises_for_status",
      "lineno": 59,
      "outcome": "failed",
      "keywords": [
        "test_updatehistorytimetolive_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_updatehistorytimetolive.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_updatehistorytimetolive.py",
            "lineno": 66,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 927,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UpdateHistoryTimeToLive(url='http://localhost/engine-rest/process-definition/anId/history-time-to-live', id_='anId', history_time_to_live=10)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E230>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1FC630>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1FC4F0>\nbody = '{\"historyTimeToLive\": 10}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200240430800'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_updatehistorytimetolive_raises_for_status(mock, engine_url):\n        update_definition = pycamunda.processdef.UpdateHistoryTimeToLive(\n            url=engine_url, id_='anId', history_time_to_live=10\n        )\n>       update_definition()\n\ntests\\processdef\\test_updatehistorytimetolive.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:927: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UpdateHistoryTimeToLive(url='http://localhost/engine-rest/process-definition/anId/history-time-to-live', id_='anId', history_time_to_live=10)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E230>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1FC630>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1FC4F0>\nbody = '{\"historyTimeToLive\": 10}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processdef/test_updatehistorytimetolive.py::test_updatehistorytimetolive_returns_none",
      "lineno": 70,
      "outcome": "failed",
      "keywords": [
        "test_updatehistorytimetolive_returns_none",
        "__wrapped__",
        "patchings",
        "test_updatehistorytimetolive.py",
        "processdef",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processdef\\test_updatehistorytimetolive.py",
            "lineno": 76,
            "message": ""
          },
          {
            "path": "pycamunda\\processdef.py",
            "lineno": 927,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UpdateHistoryTimeToLive(url='http://localhost/engine-rest/process-definition/anId/history-time-to-live', id_='anId', history_time_to_live=10)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17630>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1FCD10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1FCB80>\nbody = '{\"historyTimeToLive\": 10}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', response_mock)\n    def test_updatehistorytimetolive_returns_none(engine_url):\n        update_definition = pycamunda.processdef.UpdateHistoryTimeToLive(\n            url=engine_url, id_='anId', history_time_to_live=10\n        )\n>       result = update_definition()\n\ntests\\processdef\\test_updatehistorytimetolive.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processdef.py:927: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UpdateHistoryTimeToLive(url='http://localhost/engine-rest/process-definition/anId/history-time-to-live', id_='anId', history_time_to_live=10)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17630>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1FCD10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1FCB80>\nbody = '{\"historyTimeToLive\": 10}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_activatesuspend.py::test_activate_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_activate_params",
        "test_activatesuspend.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_activatesuspend.py::test_activate_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_activate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2491 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_activatesuspend.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 548,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Activate(url='http://localhost/engine-rest/process-instance/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1FE160>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1FD170>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2491 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200235413648'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_activate_calls_requests(mock, engine_url):\n        activate_instance = pycamunda.processinst.Activate(url=engine_url, id_='anId')\n>       activate_instance()\n\ntests\\processinst\\test_activatesuspend.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:548: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Activate(url='http://localhost/engine-rest/process-instance/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1FE160>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1FD170>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2491 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_activatesuspend.py::test_activate_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_activate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_activatesuspend.py::test_activate_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_activate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_activatesuspend.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 548,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Activate(url='http://localhost/engine-rest/process-instance/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D030>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1D3D80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1D1F30>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200240426624'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_activate_raises_for_status(mock, engine_url):\n        activate_instance = pycamunda.processinst.Activate(url=engine_url, id_='anId')\n>       activate_instance()\n\ntests\\processinst\\test_activatesuspend.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:548: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Activate(url='http://localhost/engine-rest/process-instance/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D030>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1D3D80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1D1F30>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_activatesuspend.py::test_activate_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_activate_returns_none",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_activatesuspend.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 548,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Activate(url='http://localhost/engine-rest/process-instance/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E470>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1D1DF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1D3FB0>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_activate_returns_none(engine_url):\n        activate_instance = pycamunda.processinst.Activate(url=engine_url, id_='anId')\n>       result = activate_instance()\n\ntests\\processinst\\test_activatesuspend.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:548: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Activate(url='http://localhost/engine-rest/process-instance/anId/suspended', id_='anId', suspended=False)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E470>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1D1DF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1D3FB0>\nbody = '{\"suspended\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_activatesuspend.py::test_suspend_params",
      "lineno": 51,
      "outcome": "passed",
      "keywords": [
        "test_suspend_params",
        "test_activatesuspend.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_activatesuspend.py::test_suspend_calls_requests",
      "lineno": 59,
      "outcome": "failed",
      "keywords": [
        "test_suspend_calls_requests",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_activatesuspend.py",
            "lineno": 63,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 548,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Suspend(url='http://localhost/engine-rest/process-instance/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1D2F70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1D36F0>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200235415520'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_suspend_calls_requests(mock, engine_url):\n        suspend_instance = pycamunda.processinst.Suspend(url=engine_url, id_='anId')\n>       suspend_instance()\n\ntests\\processinst\\test_activatesuspend.py:63: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:548: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Suspend(url='http://localhost/engine-rest/process-instance/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1D2F70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1D36F0>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_activatesuspend.py::test_suspend_raises_pycamunda_exception",
      "lineno": 67,
      "outcome": "passed",
      "keywords": [
        "test_suspend_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_activatesuspend.py::test_suspend_raises_for_status",
      "lineno": 74,
      "outcome": "failed",
      "keywords": [
        "test_suspend_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2559 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_activatesuspend.py",
            "lineno": 79,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 548,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Suspend(url='http://localhost/engine-rest/process-instance/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D232B60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2328E0>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2559 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200237536560'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_suspend_raises_for_status(mock, engine_url):\n        suspend_instance = pycamunda.processinst.Suspend(url=engine_url, id_='anId')\n>       suspend_instance()\n\ntests\\processinst\\test_activatesuspend.py:79: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:548: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Suspend(url='http://localhost/engine-rest/process-instance/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D232B60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D2328E0>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2559 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_activatesuspend.py::test_suspend_returns_none",
      "lineno": 83,
      "outcome": "failed",
      "keywords": [
        "test_suspend_returns_none",
        "__wrapped__",
        "patchings",
        "test_activatesuspend.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2255 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_activatesuspend.py",
            "lineno": 87,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 548,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Suspend(url='http://localhost/engine-rest/process-instance/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D230E50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D230F90>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2255 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_suspend_returns_none(engine_url):\n        suspend_instance = pycamunda.processinst.Suspend(url=engine_url, id_='anId')\n>       result = suspend_instance()\n\ntests\\processinst\\test_activatesuspend.py:87: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:548: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Suspend(url='http://localhost/engine-rest/process-instance/anId/suspended', id_='anId', suspended=True)\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D230E50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D230F90>\nbody = '{\"suspended\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2255 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_delete.py::test_delete_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_delete_params",
        "test_delete.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_delete.py::test_delete_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_delete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_delete.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 96,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/process-instance/anId', id_='anId', skip_custom_listeners=False, skip_io_mappings=False, skip_subprocesses=False, fail_if_not_exists=False)\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18830>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D232660>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D232750>\nquery_string = 'skipCustomListeners=false&skipIoMappings=false&skipSubprocesses=false&failIfNotExists=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200239530736'>\nengine_url = 'http://localhost/engine-rest'\ndelete_input = {'fail_if_not_exists': False, 'id_': 'anId', 'skip_custom_listeners': False, 'skip_io_mappings': False, ...}\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_delete_calls_requests(mock, engine_url, delete_input):\n        delete_instance = pycamunda.processinst.Delete(url=engine_url, **delete_input)\n>       delete_instance()\n\ntests\\processinst\\test_delete.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:96: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/process-instance/anId', id_='anId', skip_custom_listeners=False, skip_io_mappings=False, skip_subprocesses=False, fail_if_not_exists=False)\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18830>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D232660>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D232750>\nquery_string = 'skipCustomListeners=false&skipIoMappings=false&skipSubprocesses=false&failIfNotExists=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_delete.py::test_delete_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_delete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_delete.py::test_delete_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_delete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2255 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_delete.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 96,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/process-instance/anId', id_='anId', skip_custom_listeners=False, skip_io_mappings=False, skip_subprocesses=False, fail_if_not_exists=False)\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2339C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D233880>\nquery_string = 'skipCustomListeners=false&skipIoMappings=false&skipSubprocesses=false&failIfNotExists=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2255 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200239533040'>\nengine_url = 'http://localhost/engine-rest'\ndelete_input = {'fail_if_not_exists': False, 'id_': 'anId', 'skip_custom_listeners': False, 'skip_io_mappings': False, ...}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_delete_raises_for_status(mock, engine_url, delete_input):\n        delete_instance = pycamunda.processinst.Delete(url=engine_url, **delete_input)\n>       delete_instance()\n\ntests\\processinst\\test_delete.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:96: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/process-instance/anId', id_='anId', skip_custom_listeners=False, skip_io_mappings=False, skip_subprocesses=False, fail_if_not_exists=False)\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2339C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D233880>\nquery_string = 'skipCustomListeners=false&skipIoMappings=false&skipSubprocesses=false&failIfNotExists=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2255 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_delete.py::test_delete_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_delete_returns_none",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_delete.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 96,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/process-instance/anId', id_='anId', skip_custom_listeners=False, skip_io_mappings=False, skip_subprocesses=False, fail_if_not_exists=False)\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D20ACF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D20ABB0>\nquery_string = 'skipCustomListeners=false&skipIoMappings=false&skipSubprocesses=false&failIfNotExists=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\ndelete_input = {'fail_if_not_exists': False, 'id_': 'anId', 'skip_custom_listeners': False, 'skip_io_mappings': False, ...}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_delete_returns_none(engine_url, delete_input):\n        delete_instance = pycamunda.processinst.Delete(url=engine_url, **delete_input)\n>       result = delete_instance()\n\ntests\\processinst\\test_delete.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:96: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/process-instance/anId', id_='anId', skip_custom_listeners=False, skip_io_mappings=False, skip_subprocesses=False, fail_if_not_exists=False)\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D20ACF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D20ABB0>\nquery_string = 'skipCustomListeners=false&skipIoMappings=false&skipSubprocesses=false&failIfNotExists=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_get.py::test_get_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_get.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 310,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/process-instance/anProcessInstanceId', id_='anProcessInstanceId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D930>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2081D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D208770>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200239465392'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    @unittest.mock.patch('pycamunda.processinst.ProcessInstance', unittest.mock.MagicMock())\n    def test_get_calls_requests(mock, engine_url):\n        get_instance = pycamunda.processinst.Get(url=engine_url, id_='anProcessInstanceId')\n>       get_instance()\n\ntests\\processinst\\test_get.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:310: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/process-instance/anProcessInstanceId', id_='anProcessInstanceId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D930>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D2081D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D208770>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_get.py::test_get_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_get.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 310,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/process-instance/anProcessInstanceId', id_='anProcessInstanceId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D20AC00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D20A980>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200239462896'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.processinst.ProcessInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_instance = pycamunda.processinst.Get(url=engine_url, id_='anProcessInstanceId')\n>       get_instance()\n\ntests\\processinst\\test_get.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:310: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/process-instance/anProcessInstanceId', id_='anProcessInstanceId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D20AC00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D20A980>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_get.py::test_get_returns_none",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_none",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_get.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 310,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/process-instance/anProcessInstanceId', id_='anProcessInstanceId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D20B470>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D20BA10>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_get_returns_none(engine_url):\n        get_instance = pycamunda.processinst.Get(url=engine_url, id_='anProcessInstanceId')\n>       instance = get_instance()\n\ntests\\processinst\\test_get.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:310: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/process-instance/anProcessInstanceId', id_='anProcessInstanceId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D20B470>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D20BA10>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_getactivityinstance.py::test_getactivityinstance_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_getactivityinstance_params",
        "test_getactivityinstance.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_getactivityinstance.py::test_getactivityinstance_calls_requests",
      "lineno": 19,
      "outcome": "failed",
      "keywords": [
        "test_getactivityinstance_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getactivityinstance.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_getactivityinstance.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 114,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetActivityInstance(url='http://localhost/engine-rest/process-instance/anId/activity-instances', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17630>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1AA840>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1AA980>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200239519072'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getactivityinstance_calls_requests(mock, engine_url):\n        get_activity_instance = pycamunda.processinst.GetActivityInstance(url=engine_url, id_='anId')\n>       get_activity_instance()\n\ntests\\processinst\\test_getactivityinstance.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:114: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetActivityInstance(url='http://localhost/engine-rest/process-instance/anId/activity-instances', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17630>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1AA840>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1AA980>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2248 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_getactivityinstance.py::test_getactivityinstance_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_getactivityinstance_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getactivityinstance.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_getactivityinstance.py::test_getactivityinstance_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_getactivityinstance_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getactivityinstance.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_getactivityinstance.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 114,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetActivityInstance(url='http://localhost/engine-rest/process-instance/anId/activity-instances', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1A8B30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1A95D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200239426672'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.activityinst.ActivityInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getactivityinstance_raises_for_status(mock, engine_url):\n        get_activity_instance = pycamunda.processinst.GetActivityInstance(url=engine_url, id_='anId')\n>       get_activity_instance()\n\ntests\\processinst\\test_getactivityinstance.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:114: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetActivityInstance(url='http://localhost/engine-rest/process-instance/anId/activity-instances', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1A8B30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1A95D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_getactivityinstance.py::test_getactivityinstance_returns_none",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_getactivityinstance_returns_none",
        "__wrapped__",
        "patchings",
        "test_getactivityinstance.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2499 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_getactivityinstance.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 114,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetActivityInstance(url='http://localhost/engine-rest/process-instance/anId/activity-instances', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1A9B70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1A8FE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2499 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getactivityinstance_returns_none(engine_url):\n        get_activity_instance = pycamunda.processinst.GetActivityInstance(url=engine_url, id_='anId')\n>       activity_instance = get_activity_instance()\n\ntests\\processinst\\test_getactivityinstance.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:114: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetActivityInstance(url='http://localhost/engine-rest/process-instance/anId/activity-instances', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D1A9B70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D1A8FE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2499 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_getlist.py::test_getlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_getlist.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 290,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/process-instance')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D375B70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D375CB0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200239435312'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    @unittest.mock.patch('pycamunda.processinst.ProcessInstance', unittest.mock.MagicMock())\n    def test_getlist_calls_requests(mock, engine_url):\n        get_instances = pycamunda.processinst.GetList(url=engine_url)\n>       get_instances()\n\ntests\\processinst\\test_getlist.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:290: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/process-instance')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D375B70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D375CB0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2588 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_getlist.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 290,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/process-instance')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D270>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D376980>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D374270>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2588 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200239422928'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.processinst.ProcessInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_instances = pycamunda.processinst.GetList(url=engine_url)\n>       get_instances()\n\ntests\\processinst\\test_getlist.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:290: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/process-instance')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D270>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D376980>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D374270>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2588 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_getlist.py::test_getlist_returns_none",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_none",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_getlist.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 290,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/process-instance')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3744F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D374D60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.processinst.ProcessInstance', unittest.mock.MagicMock())\n    def test_getlist_returns_none(engine_url):\n        get_instances = pycamunda.processinst.GetList(url=engine_url)\n>       instances = get_instances()\n\ntests\\processinst\\test_getlist.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:290: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/process-instance')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3744F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D374D60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2233 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_params_default",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_modify_params_default",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_params_non_default",
      "lineno": 23,
      "outcome": "passed",
      "keywords": [
        "test_modify_params_non_default",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_params_async",
      "lineno": 40,
      "outcome": "passed",
      "keywords": [
        "test_modify_params_async",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_params_before_activity_instruction",
      "lineno": 52,
      "outcome": "passed",
      "keywords": [
        "test_modify_params_before_activity_instruction",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_params_after_activity_instruction",
      "lineno": 63,
      "outcome": "passed",
      "keywords": [
        "test_modify_params_after_activity_instruction",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_params_cancel_instruction",
      "lineno": 74,
      "outcome": "passed",
      "keywords": [
        "test_modify_params_cancel_instruction",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_params_transition_instruction",
      "lineno": 85,
      "outcome": "passed",
      "keywords": [
        "test_modify_params_transition_instruction",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_params_cancel_activity_instance_instruction",
      "lineno": 96,
      "outcome": "passed",
      "keywords": [
        "test_modify_params_cancel_activity_instance_instruction",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_params_cancel_transition_instance_instruction",
      "lineno": 107,
      "outcome": "passed",
      "keywords": [
        "test_modify_params_cancel_transition_instance_instruction",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_params_start_before_ancestor_instance_instruction",
      "lineno": 118,
      "outcome": "passed",
      "keywords": [
        "test_modify_params_start_before_ancestor_instance_instruction",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_params_start_after_ancestor_instance_instruction",
      "lineno": 134,
      "outcome": "passed",
      "keywords": [
        "test_modify_params_start_after_ancestor_instance_instruction",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_params_cancel_ancestor_instance_instruction",
      "lineno": 150,
      "outcome": "passed",
      "keywords": [
        "test_modify_params_cancel_ancestor_instance_instruction",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_calls_requests",
      "lineno": 162,
      "outcome": "failed",
      "keywords": [
        "test_modify_calls_requests",
        "__wrapped__",
        "patchings",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2270 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_modify.py",
            "lineno": 166,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 524,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Modify(url='http://localhost/engine-rest/process-instance/anInstanceId/modification', id_='anInstanceId', skip_custom_listeners=False, skip_io_mappings=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19EB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D360860>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3608B0>\nbody = '{\"skipCustomListeners\": false, \"skipIoMappings\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2270 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200240688000'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_modify_calls_requests(mock, engine_url):\n        modify_instance = pycamunda.processinst.Modify(url=engine_url, id_='anInstanceId')\n>       modify_instance()\n\ntests\\processinst\\test_modify.py:166: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:524: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Modify(url='http://localhost/engine-rest/process-instance/anInstanceId/modification', id_='anInstanceId', skip_custom_listeners=False, skip_io_mappings=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19EB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D360860>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3608B0>\nbody = '{\"skipCustomListeners\": false, \"skipIoMappings\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2270 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_raises_pycamunda_exception",
      "lineno": 171,
      "outcome": "passed",
      "keywords": [
        "test_modify_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_raises_for_status",
      "lineno": 178,
      "outcome": "failed",
      "keywords": [
        "test_modify_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_modify.py",
            "lineno": 183,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 524,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Modify(url='http://localhost/engine-rest/process-instance/anInstanceId/modification', id_='anInstanceId', skip_custom_listeners=False, skip_io_mappings=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18A70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D360900>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D361F80>\nbody = '{\"skipCustomListeners\": false, \"skipIoMappings\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241009248'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_modify_raises_for_status(mock, engine_url):\n        modify_instance = pycamunda.processinst.Modify(url=engine_url, id_='anInstanceId')\n>       modify_instance()\n\ntests\\processinst\\test_modify.py:183: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:524: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Modify(url='http://localhost/engine-rest/process-instance/anInstanceId/modification', id_='anInstanceId', skip_custom_listeners=False, skip_io_mappings=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18A70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D360900>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D361F80>\nbody = '{\"skipCustomListeners\": false, \"skipIoMappings\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_returns_none",
      "lineno": 187,
      "outcome": "failed",
      "keywords": [
        "test_modify_returns_none",
        "__wrapped__",
        "patchings",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_modify.py",
            "lineno": 191,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 524,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Modify(url='http://localhost/engine-rest/process-instance/anInstanceId/modification', id_='anInstanceId', skip_custom_listeners=False, skip_io_mappings=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17CF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3634C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D363380>\nbody = '{\"skipCustomListeners\": false, \"skipIoMappings\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_modify_returns_none(engine_url):\n        modify_instance = pycamunda.processinst.Modify(url=engine_url, id_='anInstanceId')\n>       result = modify_instance()\n\ntests\\processinst\\test_modify.py:191: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:524: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Modify(url='http://localhost/engine-rest/process-instance/anInstanceId/modification', id_='anInstanceId', skip_custom_listeners=False, skip_io_mappings=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17CF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3634C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D363380>\nbody = '{\"skipCustomListeners\": false, \"skipIoMappings\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_modify.py::test_modify_async_returns_batch",
      "lineno": 195,
      "outcome": "failed",
      "keywords": [
        "test_modify_async_returns_batch",
        "__wrapped__",
        "patchings",
        "test_modify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_modify.py",
            "lineno": 199,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 524,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Modify(url='http://localhost/engine-rest/process-instance/anInstanceId/modification-async', id_='anInstanceId', skip_custom_listeners=False, skip_io_mappings=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D360860>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D360400>\nbody = '{\"skipCustomListeners\": false, \"skipIoMappings\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_modify_async_returns_batch(engine_url):\n        modify_instance = pycamunda.processinst.Modify(url=engine_url, id_='anInstanceId', async_=True)\n>       batch = modify_instance()\n\ntests\\processinst\\test_modify.py:199: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:524: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Modify(url='http://localhost/engine-rest/process-instance/anInstanceId/modification-async', id_='anInstanceId', skip_custom_listeners=False, skip_io_mappings=False, instructions=[])\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D360860>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D360400>\nbody = '{\"skipCustomListeners\": false, \"skipIoMappings\": false, \"instructions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_processinst.py::test_processinstance_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_processinstance_load",
        "test_processinst.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_processinst.py::test_processinstance_load_raises_keyerror",
      "lineno": 19,
      "outcome": "passed",
      "keywords": [
        "test_processinstance_load_raises_keyerror",
        "test_processinst.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesdelete.py::test_variablesdelete_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_variablesdelete_params",
        "test_variablesdelete.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesdelete.py::test_variablesdelete_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_variablesdelete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_variablesdelete.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesdelete.py",
            "lineno": 26,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 599,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesDelete(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3ACE00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3ACEA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200239421152'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_variablesdelete_calls_requests(mock, engine_url):\n        delete_var = pycamunda.processinst.VariablesDelete(\n            url=engine_url, process_instance_id='anId', var_name='aVar'\n        )\n>       delete_var()\n\ntests\\processinst\\test_variablesdelete.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:599: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesDelete(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3ACE00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3ACEA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesdelete.py::test_variablesdelete_raises_pycamunda_exception",
      "lineno": 31,
      "outcome": "passed",
      "keywords": [
        "test_variablesdelete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_variablesdelete.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesdelete.py::test_variablesdelete_raises_for_status",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_variablesdelete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_variablesdelete.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesdelete.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 599,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesDelete(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3AE570>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3AD3A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241017504'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_variablesdelete_raises_for_status(mock, engine_url):\n        delete_var = pycamunda.processinst.VariablesDelete(\n            url=engine_url, process_instance_id='anId', var_name='aVar'\n        )\n>       delete_var()\n\ntests\\processinst\\test_variablesdelete.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:599: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesDelete(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3AE570>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3AD3A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesdelete.py::test_variablesdelete_returns_none",
      "lineno": 51,
      "outcome": "failed",
      "keywords": [
        "test_variablesdelete_returns_none",
        "__wrapped__",
        "patchings",
        "test_variablesdelete.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesdelete.py",
            "lineno": 57,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 599,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesDelete(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3AE9D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3AE890>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_variablesdelete_returns_none(engine_url):\n        delete_var = pycamunda.processinst.VariablesDelete(\n            url=engine_url, process_instance_id='anId', var_name='aVar'\n        )\n>       result = delete_var()\n\ntests\\processinst\\test_variablesdelete.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:599: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesDelete(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3AE9D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3AE890>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesget.py::test_variablesget_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_variablesget_params",
        "test_variablesget.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesget.py::test_variablesget_binary_params",
      "lineno": 21,
      "outcome": "passed",
      "keywords": [
        "test_variablesget_binary_params",
        "test_variablesget.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesget.py::test_variablesget_calls_requests",
      "lineno": 33,
      "outcome": "failed",
      "keywords": [
        "test_variablesget_calls_requests",
        "__wrapped__",
        "patchings",
        "test_variablesget.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesget.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 637,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesGet(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DB70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D43D490>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43C040>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200240689968'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_variablesget_calls_requests(mock, engine_url):\n        get_var = pycamunda.processinst.VariablesGet(\n            url=engine_url, process_instance_id='anId', var_name='aVar'\n        )\n>       get_var()\n\ntests\\processinst\\test_variablesget.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:637: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesGet(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DB70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D43D490>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43C040>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesget.py::test_variablesget_raises_pycamunda_exception",
      "lineno": 44,
      "outcome": "passed",
      "keywords": [
        "test_variablesget_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_variablesget.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesget.py::test_variablesget_raises_for_status",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_variablesget_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_variablesget.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2450 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesget.py",
            "lineno": 61,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 637,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesGet(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D43C540>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43F8D0>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2450 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241563744'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.variable.Variable', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_variablesget_raises_for_status(mock, engine_url):\n        get_var = pycamunda.processinst.VariablesGet(\n            url=engine_url, process_instance_id='anId', var_name='aVar'\n        )\n>       get_var()\n\ntests\\processinst\\test_variablesget.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:637: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesGet(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D43C540>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43F8D0>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2450 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesget.py::test_variablesget_returns_variable",
      "lineno": 65,
      "outcome": "failed",
      "keywords": [
        "test_variablesget_returns_variable",
        "__wrapped__",
        "patchings",
        "test_variablesget.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesget.py",
            "lineno": 71,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 637,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesGet(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17F30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D43E930>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43E250>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_variablesget_returns_variable(engine_url):\n        get_var = pycamunda.processinst.VariablesGet(\n            url=engine_url, process_instance_id='anId', var_name='aVar'\n        )\n>       variable = get_var()\n\ntests\\processinst\\test_variablesget.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:637: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesGet(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17F30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D43E930>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43E250>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesgetlist.py::test_variablesgetlist_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_variablesgetlist_params",
        "test_variablesgetlist.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesgetlist.py::test_variablesgetlist_calls_requests",
      "lineno": 21,
      "outcome": "failed",
      "keywords": [
        "test_variablesgetlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_variablesgetlist.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2440 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesgetlist.py",
            "lineno": 27,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 668,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesGetList(url='http://localhost/engine-rest/process-instance/anId/variables', process_instance_id='anId', deserialize_values=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D43FF60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43D8A0>\nquery_string = 'deserializeValues=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2440 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200240688336'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_variablesgetlist_calls_requests(mock, engine_url):\n        get_vars = pycamunda.processinst.VariablesGetList(\n            url=engine_url, process_instance_id='anId', deserialize_values=True\n        )\n>       get_vars()\n\ntests\\processinst\\test_variablesgetlist.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:668: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesGetList(url='http://localhost/engine-rest/process-instance/anId/variables', process_instance_id='anId', deserialize_values=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D43FF60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43D8A0>\nquery_string = 'deserializeValues=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2440 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesgetlist.py::test_variablesgetlist_raises_pycamunda_exception",
      "lineno": 32,
      "outcome": "passed",
      "keywords": [
        "test_variablesgetlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_variablesgetlist.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesgetlist.py::test_variablesgetlist_raises_for_status",
      "lineno": 41,
      "outcome": "failed",
      "keywords": [
        "test_variablesgetlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_variablesgetlist.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesgetlist.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 668,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesGetList(url='http://localhost/engine-rest/process-instance/anId/variables', process_instance_id='anId', deserialize_values=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E8F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3F2D40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3F2CF0>\nquery_string = 'deserializeValues=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241556256'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.variable.Variable', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_variablesgetlist_raises_for_status(mock, engine_url):\n        get_vars = pycamunda.processinst.VariablesGetList(\n            url=engine_url, process_instance_id='anId', deserialize_values=True\n        )\n>       get_vars()\n\ntests\\processinst\\test_variablesgetlist.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:668: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesGetList(url='http://localhost/engine-rest/process-instance/anId/variables', process_instance_id='anId', deserialize_values=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E8F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3F2D40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3F2CF0>\nquery_string = 'deserializeValues=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesgetlist.py::test_variablesgetlist_returns_dict",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_variablesgetlist_returns_dict",
        "__wrapped__",
        "patchings",
        "test_variablesgetlist.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2614 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesgetlist.py",
            "lineno": 59,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 668,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesGetList(url='http://localhost/engine-rest/process-instance/anId/variables', process_instance_id='anId', deserialize_values=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3F0D60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3F0D10>\nquery_string = 'deserializeValues=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2614 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_variablesgetlist_returns_dict(engine_url):\n        get_vars = pycamunda.processinst.VariablesGetList(\n            url=engine_url, process_instance_id='anId', deserialize_values=True\n        )\n>       variables = get_vars()\n\ntests\\processinst\\test_variablesgetlist.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:668: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesGetList(url='http://localhost/engine-rest/process-instance/anId/variables', process_instance_id='anId', deserialize_values=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3F0D60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3F0D10>\nquery_string = 'deserializeValues=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2614 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesmodify.py::test_variablesmodify_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_variablesmodify_params",
        "test_variablesmodify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesmodify.py::test_variablesmodify_calls_requests",
      "lineno": 24,
      "outcome": "failed",
      "keywords": [
        "test_variablesmodify_calls_requests",
        "__wrapped__",
        "patchings",
        "test_variablesmodify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2310 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesmodify.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 719,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesModify(url='http://localhost/engine-rest/process-instance/anId/variables', process_instance_id='anId', modifications={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17630>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3F2A70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3F2E80>\nbody = '{\"modifications\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2310 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200231692992'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_variablesmodify_calls_requests(mock, engine_url):\n        modify_vars = pycamunda.processinst.VariablesModify(url=engine_url, process_instance_id='anId')\n>       modify_vars()\n\ntests\\processinst\\test_variablesmodify.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:719: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesModify(url='http://localhost/engine-rest/process-instance/anId/variables', process_instance_id='anId', modifications={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17630>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3F2A70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3F2E80>\nbody = '{\"modifications\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2310 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesmodify.py::test_variablesmodify_raises_pycamunda_exception",
      "lineno": 33,
      "outcome": "passed",
      "keywords": [
        "test_variablesmodify_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_variablesmodify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesmodify.py::test_variablesmodify_raises_for_status",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_variablesmodify_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_variablesmodify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2513 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesmodify.py",
            "lineno": 45,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 719,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesModify(url='http://localhost/engine-rest/process-instance/anId/variables', process_instance_id='anId', modifications={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D43C540>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43FE70>\nbody = '{\"modifications\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2513 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241022352'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_variablesmodify_raises_for_status(mock, engine_url):\n        modify_vars = pycamunda.processinst.VariablesModify(url=engine_url, process_instance_id='anId')\n>       modify_vars()\n\ntests\\processinst\\test_variablesmodify.py:45: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:719: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesModify(url='http://localhost/engine-rest/process-instance/anId/variables', process_instance_id='anId', modifications={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D43C540>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43FE70>\nbody = '{\"modifications\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2513 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesmodify.py::test_variablesmodify_returns_none",
      "lineno": 49,
      "outcome": "failed",
      "keywords": [
        "test_variablesmodify_returns_none",
        "__wrapped__",
        "patchings",
        "test_variablesmodify.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesmodify.py",
            "lineno": 53,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 719,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesModify(url='http://localhost/engine-rest/process-instance/anId/variables', process_instance_id='anId', modifications={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D438400>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43AF20>\nbody = '{\"modifications\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_variablesmodify_returns_none(engine_url):\n        modify_vars = pycamunda.processinst.VariablesModify(url=engine_url, process_instance_id='anId')\n>       result = modify_vars()\n\ntests\\processinst\\test_variablesmodify.py:53: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:719: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesModify(url='http://localhost/engine-rest/process-instance/anId/variables', process_instance_id='anId', modifications={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D438400>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43AF20>\nbody = '{\"modifications\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_variablesupdate_params",
        "test_variablesupdate.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_binary_params",
      "lineno": 26,
      "outcome": "passed",
      "keywords": [
        "test_variablesupdate_binary_params",
        "test_variablesupdate.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_calls_requests",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_variablesupdate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_variablesupdate.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2395 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesupdate.py",
            "lineno": 61,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 780,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesUpdate(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar', value='aVal', type_='String', value_info={})\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18EF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D439B20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D439B70>\nbody = '{\"value\": \"aVal\", \"type\": \"String\", \"valueInfo\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2395 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200240667344'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_variablesupdate_calls_requests(mock, engine_url):\n        update_var = pycamunda.processinst.VariablesUpdate(\n            url=engine_url,\n            process_instance_id='anId',\n            var_name='aVar',\n            value='aVal',\n            type_='String',\n            value_info={}\n        )\n>       update_var()\n\ntests\\processinst\\test_variablesupdate.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:780: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesUpdate(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar', value='aVal', type_='String', value_info={})\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18EF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D439B20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D439B70>\nbody = '{\"value\": \"aVal\", \"type\": \"String\", \"valueInfo\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2395 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_binary_calls_requests",
      "lineno": 66,
      "outcome": "failed",
      "keywords": [
        "test_variablesupdate_binary_calls_requests",
        "__wrapped__",
        "patchings",
        "test_variablesupdate.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesupdate.py",
            "lineno": 76,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 778,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesUpdate(url='http://localhost/engine-rest/process-instance/anId/variables/aVar/data', process_instance_id='anId', var_name='aVar', value=<_io.StringIO object at 0x000002E91CF84B80>, type_='Bytes')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D43B790>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43B880>\nbody = '{\"valueType\": \"Bytes\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200241542512'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_variablesupdate_binary_calls_requests(mock, engine_url):\n        update_var = pycamunda.processinst.VariablesUpdate(\n            url=engine_url,\n            process_instance_id='anId',\n            var_name='aVar',\n            value=io.StringIO('myfile'),\n            type_='Bytes'\n        )\n>       update_var()\n\ntests\\processinst\\test_variablesupdate.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:778: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesUpdate(url='http://localhost/engine-rest/process-instance/anId/variables/aVar/data', process_instance_id='anId', var_name='aVar', value=<_io.StringIO object at 0x000002E91CF84B80>, type_='Bytes')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D43B790>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D43B880>\nbody = '{\"valueType\": \"Bytes\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_raises_pycamunda_exception",
      "lineno": 80,
      "outcome": "passed",
      "keywords": [
        "test_variablesupdate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_variablesupdate.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_binary_raises_pycamunda_exception",
      "lineno": 94,
      "outcome": "passed",
      "keywords": [
        "test_variablesupdate_binary_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_variablesupdate.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_raises_for_status",
      "lineno": 107,
      "outcome": "failed",
      "keywords": [
        "test_variablesupdate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_variablesupdate.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2307 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesupdate.py",
            "lineno": 119,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 780,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesUpdate(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar', value='aVal', type_='String', value_info={})\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D372020>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D370860>\nbody = '{\"value\": \"aVal\", \"type\": \"String\", \"valueInfo\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2307 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241548128'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_variablesupdate_raises_for_status(mock, engine_url):\n        update_var = pycamunda.processinst.VariablesUpdate(\n            url=engine_url,\n            process_instance_id='anId',\n            var_name='aVar',\n            value='aVal',\n            type_='String',\n            value_info={}\n        )\n>       update_var()\n\ntests\\processinst\\test_variablesupdate.py:119: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:780: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesUpdate(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar', value='aVal', type_='String', value_info={})\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D372020>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D370860>\nbody = '{\"value\": \"aVal\", \"type\": \"String\", \"valueInfo\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2307 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/processinst/test_variablesupdate.py::test_variablesupdate_returns_none",
      "lineno": 123,
      "outcome": "failed",
      "keywords": [
        "test_variablesupdate_returns_none",
        "__wrapped__",
        "patchings",
        "test_variablesupdate.py",
        "processinst",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\processinst\\test_variablesupdate.py",
            "lineno": 134,
            "message": ""
          },
          {
            "path": "pycamunda\\processinst.py",
            "lineno": 780,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = VariablesUpdate(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar', value='aVal', type_='String', value_info={})\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19EB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4382C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D376020>\nbody = '{\"value\": \"aVal\", \"type\": \"String\", \"valueInfo\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_variablesupdate_returns_none(engine_url):\n        update_var = pycamunda.processinst.VariablesUpdate(\n            url=engine_url,\n            process_instance_id='anId',\n            var_name='aVar',\n            value='aVal',\n            type_='String',\n            value_info={}\n        )\n>       result = update_var()\n\ntests\\processinst\\test_variablesupdate.py:134: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\processinst.py:780: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = VariablesUpdate(url='http://localhost/engine-rest/process-instance/anId/variables/aVar', process_instance_id='anId', var_name='aVar', value='aVal', type_='String', value_info={})\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19EB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4382C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D376020>\nbody = '{\"value\": \"aVal\", \"type\": \"String\", \"valueInfo\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/resource/test_link.py::test_link_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_link_load",
        "test_link.py",
        "resource",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/resource/test_link.py::test_link_load_raises_keyerror",
      "lineno": 15,
      "outcome": "passed",
      "keywords": [
        "test_link_load_raises_keyerror",
        "test_link.py",
        "resource",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/resource/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "resource",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/resource/test_resourceoptions.py::test_resourceoptions_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_resourceoptions_load",
        "test_resourceoptions.py",
        "resource",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/resource/test_resourceoptions.py::test_link_load_raises_keyerror",
      "lineno": 15,
      "outcome": "passed",
      "keywords": [
        "test_link_load_raises_keyerror",
        "test_resourceoptions.py",
        "resource",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_event.py::test_eventall_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_eventall_params",
        "test_event.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_event.py::test_eventall_variables_params",
      "lineno": 25,
      "outcome": "passed",
      "keywords": [
        "test_eventall_variables_params",
        "test_event.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_event.py::test_eventall_calls_requests",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_eventall_calls_requests",
        "__wrapped__",
        "patchings",
        "test_event.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\signal\\test_event.py",
            "lineno": 38,
            "message": ""
          },
          {
            "path": "pycamunda\\signal.py",
            "lineno": 73,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = EventAll(url='http://localhost/engine-rest/signal', name='aName', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D371710>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D371760>\nbody = '{\"name\": \"aName\", \"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200236855392'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_eventall_calls_requests(mock, engine_url):\n        event = pycamunda.signal.EventAll(url=engine_url, name='aName')\n>       event()\n\ntests\\signal\\test_event.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\signal.py:73: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = EventAll(url='http://localhost/engine-rest/signal', name='aName', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D371710>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D371760>\nbody = '{\"name\": \"aName\", \"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_event.py::test_eventall_raises_pycamunda_exception",
      "lineno": 43,
      "outcome": "passed",
      "keywords": [
        "test_eventall_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_event.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_event.py::test_eventall_raises_for_status",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_eventall_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_event.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\signal\\test_event.py",
            "lineno": 55,
            "message": ""
          },
          {
            "path": "pycamunda\\signal.py",
            "lineno": 73,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = EventAll(url='http://localhost/engine-rest/signal', name='aName', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A0F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3C8220>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3C82C0>\nbody = '{\"name\": \"aName\", \"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200239703184'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_eventall_raises_for_status(mock, engine_url):\n        event = pycamunda.signal.EventAll(url=engine_url, name='aName')\n>       event()\n\ntests\\signal\\test_event.py:55: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\signal.py:73: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = EventAll(url='http://localhost/engine-rest/signal', name='aName', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A0F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3C8220>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3C82C0>\nbody = '{\"name\": \"aName\", \"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_event.py::test_eventall_returns_none",
      "lineno": 59,
      "outcome": "failed",
      "keywords": [
        "test_eventall_returns_none",
        "__wrapped__",
        "patchings",
        "test_event.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2460 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\signal\\test_event.py",
            "lineno": 63,
            "message": ""
          },
          {
            "path": "pycamunda\\signal.py",
            "lineno": 73,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = EventAll(url='http://localhost/engine-rest/signal', name='aName', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DDB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3C83B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3C8450>\nbody = '{\"name\": \"aName\", \"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2460 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_eventall_returns_none(engine_url):\n        event = pycamunda.signal.EventAll(url=engine_url, name='aName')\n>       result = event()\n\ntests\\signal\\test_event.py:63: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\signal.py:73: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = EventAll(url='http://localhost/engine-rest/signal', name='aName', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DDB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3C83B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3C8450>\nbody = '{\"name\": \"aName\", \"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2460 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_event.py::test_eventsingle_params",
      "lineno": 67,
      "outcome": "passed",
      "keywords": [
        "test_eventsingle_params",
        "test_event.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_event.py::test_eventsingle_variables_params",
      "lineno": 79,
      "outcome": "passed",
      "keywords": [
        "test_eventsingle_variables_params",
        "test_event.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_event.py::test_eventsingle_calls_requests",
      "lineno": 88,
      "outcome": "failed",
      "keywords": [
        "test_eventsingle_calls_requests",
        "__wrapped__",
        "patchings",
        "test_event.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\signal\\test_event.py",
            "lineno": 92,
            "message": ""
          },
          {
            "path": "pycamunda\\signal.py",
            "lineno": 73,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = EventSingle(url='http://localhost/engine-rest/signal', name='aName', execution_id='anExecutionId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D270>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3CA570>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3CA5C0>\nbody = '{\"name\": \"aName\", \"executionId\": \"anExecutionId\", \"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200206974096'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_eventsingle_calls_requests(mock, engine_url):\n        event = pycamunda.signal.EventSingle(url=engine_url, name='aName', execution_id='anExecutionId')\n>       event()\n\ntests\\signal\\test_event.py:92: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\signal.py:73: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = EventSingle(url='http://localhost/engine-rest/signal', name='aName', execution_id='anExecutionId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D270>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3CA570>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3CA5C0>\nbody = '{\"name\": \"aName\", \"executionId\": \"anExecutionId\", \"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_event.py::test_eventsingle_raises_pycamunda_exception",
      "lineno": 97,
      "outcome": "passed",
      "keywords": [
        "test_eventsingle_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_event.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_event.py::test_eventsingle_raises_for_status",
      "lineno": 104,
      "outcome": "failed",
      "keywords": [
        "test_eventsingle_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_event.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\signal\\test_event.py",
            "lineno": 109,
            "message": ""
          },
          {
            "path": "pycamunda\\signal.py",
            "lineno": 73,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = EventSingle(url='http://localhost/engine-rest/signal', name='aName', execution_id='anExecutionId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D4B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3CAD90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3CA890>\nbody = '{\"name\": \"aName\", \"executionId\": \"anExecutionId\", \"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241543904'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_eventsingle_raises_for_status(mock, engine_url):\n        event = pycamunda.signal.EventSingle(url=engine_url, name='aName', execution_id='anExecutionId')\n>       event()\n\ntests\\signal\\test_event.py:109: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\signal.py:73: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = EventSingle(url='http://localhost/engine-rest/signal', name='aName', execution_id='anExecutionId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D4B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3CAD90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3CA890>\nbody = '{\"name\": \"aName\", \"executionId\": \"anExecutionId\", \"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_event.py::test_eventsingle_returns_none",
      "lineno": 113,
      "outcome": "failed",
      "keywords": [
        "test_eventsingle_returns_none",
        "__wrapped__",
        "patchings",
        "test_event.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\signal\\test_event.py",
            "lineno": 117,
            "message": ""
          },
          {
            "path": "pycamunda\\signal.py",
            "lineno": 73,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = EventSingle(url='http://localhost/engine-rest/signal', name='aName', execution_id='anExecutionId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3CB240>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3CBF10>\nbody = '{\"name\": \"aName\", \"executionId\": \"anExecutionId\", \"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_eventsingle_returns_none(engine_url):\n        event = pycamunda.signal.EventSingle(url=engine_url, name='aName', execution_id='anExecutionId')\n>       result = event()\n\ntests\\signal\\test_event.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\signal.py:73: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = EventSingle(url='http://localhost/engine-rest/signal', name='aName', execution_id='anExecutionId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3CB240>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3CBF10>\nbody = '{\"name\": \"aName\", \"executionId\": \"anExecutionId\", \"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/signal/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "signal",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_claim.py::test_claim_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_claim_params",
        "test_claim.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_claim.py::test_claim_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_claim_calls_requests",
        "__wrapped__",
        "patchings",
        "test_claim.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_claim.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 523,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Claim(url='http://localhost/engine-rest/task/anId/claim', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17CF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4F10D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4F1120>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200240082320'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_claim_calls_requests(mock, engine_url):\n        claim_task = pycamunda.task.Claim(url=engine_url, id_='anId', user_id='anUserId')\n>       claim_task()\n\ntests\\task\\test_claim.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:523: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Claim(url='http://localhost/engine-rest/task/anId/claim', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17CF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4F10D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4F1120>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_claim.py::test_claim_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_claim_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_claim.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_claim.py::test_claim_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_claim_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_claim.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_claim.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 523,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Claim(url='http://localhost/engine-rest/task/anId/claim', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18A70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3C3560>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3C3380>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200240673536'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_claim_raises_for_status(mock, engine_url):\n        claim_task = pycamunda.task.Claim(url=engine_url, id_='anId', user_id='anUserId')\n>       claim_task()\n\ntests\\task\\test_claim.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:523: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Claim(url='http://localhost/engine-rest/task/anId/claim', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18A70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3C3560>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3C3380>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_claim.py::test_claim_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_claim_returns_none",
        "__wrapped__",
        "patchings",
        "test_claim.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_claim.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 523,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Claim(url='http://localhost/engine-rest/task/anId/claim', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18EF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3C3A10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3C3920>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_claim_returns_none(engine_url):\n        claim_task = pycamunda.task.Claim(url=engine_url, id_='anId', user_id='anUserId')\n>       result = claim_task()\n\ntests\\task\\test_claim.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:523: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Claim(url='http://localhost/engine-rest/task/anId/claim', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18EF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3C3A10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3C3920>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_comment.py::test_comment_load",
      "lineno": 8,
      "outcome": "passed",
      "keywords": [
        "test_comment_load",
        "test_comment.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_comment.py::test_comment_load_raises_key_error",
      "lineno": 14,
      "outcome": "passed",
      "keywords": [
        "test_comment_load_raises_key_error",
        "test_comment.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentcreate.py::test_commentcreate_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_commentcreate_params",
        "test_commentcreate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentcreate.py::test_commentcreate_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_commentcreate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_commentcreate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_commentcreate.py",
            "lineno": 27,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 961,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CommentCreate(url='http://localhost/engine-rest/task/anId/comment/create', task_id='anId', message='aMessage')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D50C9F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D50CAE0>\nbody = '{\"message\": \"aMessage\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200240677616'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.task.Comment.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_commentcreate_calls_requests(mock, engine_url):\n        create_comment = pycamunda.task.CommentCreate(\n            url=engine_url, task_id='anId', message='aMessage'\n        )\n>       create_comment()\n\ntests\\task\\test_commentcreate.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:961: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CommentCreate(url='http://localhost/engine-rest/task/anId/comment/create', task_id='anId', message='aMessage')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D50C9F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D50CAE0>\nbody = '{\"message\": \"aMessage\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentcreate.py::test_commentcreate_raises_pycamunda_exception",
      "lineno": 32,
      "outcome": "passed",
      "keywords": [
        "test_commentcreate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_commentcreate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentcreate.py::test_commentcreate_raises_for_status",
      "lineno": 41,
      "outcome": "failed",
      "keywords": [
        "test_commentcreate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_commentcreate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_commentcreate.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 961,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CommentCreate(url='http://localhost/engine-rest/task/anId/comment/create', task_id='anId', message='aMessage')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D50E390>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D50CA40>\nbody = '{\"message\": \"aMessage\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200236860672'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.task.Comment.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_commentcreate_raises_for_status(mock, engine_url):\n        create_comment = pycamunda.task.CommentCreate(\n            url=engine_url, task_id='anId', message='aMessage'\n        )\n>       create_comment()\n\ntests\\task\\test_commentcreate.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:961: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CommentCreate(url='http://localhost/engine-rest/task/anId/comment/create', task_id='anId', message='aMessage')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D50E390>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D50CA40>\nbody = '{\"message\": \"aMessage\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentcreate.py::test_commentcreate_returns_comment",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_commentcreate_returns_comment",
        "__wrapped__",
        "patchings",
        "test_commentcreate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2218 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_commentcreate.py",
            "lineno": 60,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 961,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CommentCreate(url='http://localhost/engine-rest/task/anId/comment/create', task_id='anId', message='aMessage')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D50E980>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D50E840>\nbody = '{\"message\": \"aMessage\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2218 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_commentcreate_returns_comment(engine_url):\n        create_comment = pycamunda.task.CommentCreate(\n            url=engine_url, task_id='anId', message='aMessage'\n        )\n>       comment = create_comment()\n\ntests\\task\\test_commentcreate.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:961: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CommentCreate(url='http://localhost/engine-rest/task/anId/comment/create', task_id='anId', message='aMessage')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D50E980>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D50E840>\nbody = '{\"message\": \"aMessage\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2218 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentget.py::test_commentget_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_commentget_params",
        "test_commentget.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentget.py::test_commentget_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_commentget_calls_requests",
        "__wrapped__",
        "patchings",
        "test_commentget.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2255 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_commentget.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 938,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CommentGet(url='http://localhost/engine-rest/task/anId/comment/anotherId', task_id='anId', comment_id='anotherId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DB70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4AD260>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4AD300>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2255 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200239531888'>\nengine_url = 'http://localhost/engine-rest'\ntask_input = {'assignee': 'anAssignee', 'case_instance_id': 'anInstanceId', 'delegation_state': 'PENDING', 'description': 'aDescription', ...}\n\n    @unittest.mock.patch('pycamunda.task.Comment.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_commentget_calls_requests(mock, engine_url, task_input):\n        get_comment = pycamunda.task.CommentGet(url=engine_url, task_id='anId', comment_id='anotherId')\n>       get_comment()\n\ntests\\task\\test_commentget.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:938: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CommentGet(url='http://localhost/engine-rest/task/anId/comment/anotherId', task_id='anId', comment_id='anotherId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DB70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4AD260>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4AD300>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2255 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentget.py::test_commentget_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_commentget_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_commentget.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentget.py::test_commentget_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_commentget_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_commentget.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_commentget.py",
            "lineno": 42,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 938,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CommentGet(url='http://localhost/engine-rest/task/anId/comment/anotherId', task_id='anId', comment_id='anotherId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4ADD00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4ACC20>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200206180368'>\nengine_url = 'http://localhost/engine-rest'\ntask_input = {'assignee': 'anAssignee', 'case_instance_id': 'anInstanceId', 'delegation_state': 'PENDING', 'description': 'aDescription', ...}\n\n    @unittest.mock.patch('pycamunda.task.Comment.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_commentget_raises_for_status(mock, engine_url, task_input):\n        get_comment = pycamunda.task.CommentGet(url=engine_url, task_id='anId', comment_id='anotherId')\n>       get_comment()\n\ntests\\task\\test_commentget.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:938: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CommentGet(url='http://localhost/engine-rest/task/anId/comment/anotherId', task_id='anId', comment_id='anotherId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4ADD00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4ACC20>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentget.py::test_commentget_returns_comment",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_commentget_returns_comment",
        "__wrapped__",
        "patchings",
        "test_commentget.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_commentget.py",
            "lineno": 51,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 938,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CommentGet(url='http://localhost/engine-rest/task/anId/comment/anotherId', task_id='anId', comment_id='anotherId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4ACAE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4AD800>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\ntask_input = {'assignee': 'anAssignee', 'case_instance_id': 'anInstanceId', 'delegation_state': 'PENDING', 'description': 'aDescription', ...}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    def test_commentget_returns_comment(engine_url, task_input):\n        get_comment = pycamunda.task.CommentGet(url=engine_url, task_id='anId', comment_id='anotherId')\n>       comment = get_comment()\n\ntests\\task\\test_commentget.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:938: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CommentGet(url='http://localhost/engine-rest/task/anId/comment/anotherId', task_id='anId', comment_id='anotherId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4ACAE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4AD800>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentgetlist.py::test_commentgetlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_commentgetlist_params",
        "test_commentgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentgetlist.py::test_commentgetlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_commentgetlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_commentgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2607 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_commentgetlist.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 915,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CommentGetList(url='http://localhost/engine-rest/task/anId/comment', task_id='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4AF560>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4AF600>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2607 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200241012464'>\nengine_url = 'http://localhost/engine-rest'\ntask_input = {'assignee': 'anAssignee', 'case_instance_id': 'anInstanceId', 'delegation_state': 'PENDING', 'description': 'aDescription', ...}\n\n    @unittest.mock.patch('pycamunda.task.Comment.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_commentgetlist_calls_requests(mock, engine_url, task_input):\n        get_comments = pycamunda.task.CommentGetList(url=engine_url, task_id='anId')\n>       get_comments()\n\ntests\\task\\test_commentgetlist.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:915: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CommentGetList(url='http://localhost/engine-rest/task/anId/comment', task_id='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4AF560>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4AF600>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2607 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentgetlist.py::test_commentgetlist_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_commentgetlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_commentgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentgetlist.py::test_commentgetlist_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_commentgetlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_commentgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2249 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_commentgetlist.py",
            "lineno": 42,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 915,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CommentGetList(url='http://localhost/engine-rest/task/anId/comment', task_id='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5309F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D531A80>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2249 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241564752'>\nengine_url = 'http://localhost/engine-rest'\ntask_input = {'assignee': 'anAssignee', 'case_instance_id': 'anInstanceId', 'delegation_state': 'PENDING', 'description': 'aDescription', ...}\n\n    @unittest.mock.patch('pycamunda.task.Comment.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_commentgetlist_raises_for_status(mock, engine_url, task_input):\n        get_comments = pycamunda.task.CommentGetList(url=engine_url, task_id='anId')\n>       get_comments()\n\ntests\\task\\test_commentgetlist.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:915: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CommentGetList(url='http://localhost/engine-rest/task/anId/comment', task_id='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5309F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D531A80>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2249 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_commentgetlist.py::test_commentgetlist_returns_comment",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_commentgetlist_returns_comment",
        "__wrapped__",
        "patchings",
        "test_commentgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2265 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_commentgetlist.py",
            "lineno": 51,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 915,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = CommentGetList(url='http://localhost/engine-rest/task/anId/comment', task_id='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D531800>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5313A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2265 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\ntask_input = {'assignee': 'anAssignee', 'case_instance_id': 'anInstanceId', 'delegation_state': 'PENDING', 'description': 'aDescription', ...}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat', unittest.mock.MagicMock())\n    def test_commentgetlist_returns_comment(engine_url, task_input):\n        get_comments = pycamunda.task.CommentGetList(url=engine_url, task_id='anId')\n>       comments = get_comments()\n\ntests\\task\\test_commentgetlist.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:915: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = CommentGetList(url='http://localhost/engine-rest/task/anId/comment', task_id='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D531800>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5313A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2265 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_complete.py::test_complete_params",
      "lineno": 19,
      "outcome": "passed",
      "keywords": [
        "test_complete_params",
        "test_complete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_complete.py::test_complete_calls_requests",
      "lineno": 33,
      "outcome": "failed",
      "keywords": [
        "test_complete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_complete.py",
            "lineno": 37,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 578,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Complete(url='http://localhost/engine-rest/task/anId/complete', id_='anId', variables={}, with_variables_in_return=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D4B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5322F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D530A90>\nbody = '{\"variables\": {}, \"withVariablesInReturn\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200240683296'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_complete_calls_requests(mock, engine_url):\n        complete_task = pycamunda.task.Complete(url=engine_url, id_='anId')\n>       complete_task()\n\ntests\\task\\test_complete.py:37: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:578: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Complete(url='http://localhost/engine-rest/task/anId/complete', id_='anId', variables={}, with_variables_in_return=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D4B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5322F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D530A90>\nbody = '{\"variables\": {}, \"withVariablesInReturn\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_complete.py::test_complete_raises_pycamunda_exception",
      "lineno": 42,
      "outcome": "passed",
      "keywords": [
        "test_complete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_complete.py::test_complete_raises_for_status",
      "lineno": 49,
      "outcome": "failed",
      "keywords": [
        "test_complete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_complete.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 578,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Complete(url='http://localhost/engine-rest/task/anId/complete', id_='anId', variables={}, with_variables_in_return=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D533A10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D532D90>\nbody = '{\"variables\": {}, \"withVariablesInReturn\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241563456'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_complete_raises_for_status(mock, engine_url):\n        complete_task = pycamunda.task.Complete(url=engine_url, id_='anId')\n>       complete_task()\n\ntests\\task\\test_complete.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:578: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Complete(url='http://localhost/engine-rest/task/anId/complete', id_='anId', variables={}, with_variables_in_return=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D533A10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D532D90>\nbody = '{\"variables\": {}, \"withVariablesInReturn\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_complete.py::test_complete_returns_none",
      "lineno": 58,
      "outcome": "failed",
      "keywords": [
        "test_complete_returns_none",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_complete.py",
            "lineno": 62,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 578,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Complete(url='http://localhost/engine-rest/task/anId/complete', id_='anId', variables={}, with_variables_in_return=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17CF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5331A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D533D30>\nbody = '{\"variables\": {}, \"withVariablesInReturn\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_complete_returns_none(engine_url):\n        complete_task = pycamunda.task.Complete(url=engine_url, id_='anId')\n>       result = complete_task()\n\ntests\\task\\test_complete.py:62: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:578: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Complete(url='http://localhost/engine-rest/task/anId/complete', id_='anId', variables={}, with_variables_in_return=False)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17CF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5331A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D533D30>\nbody = '{\"variables\": {}, \"withVariablesInReturn\": false}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_complete.py::test_complete_returns_variables",
      "lineno": 66,
      "outcome": "failed",
      "keywords": [
        "test_complete_returns_variables",
        "__wrapped__",
        "patchings",
        "test_complete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_complete.py",
            "lineno": 73,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 578,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Complete(url='http://localhost/engine-rest/task/anId/complete', id_='anId', variables={'aVar': {'value': 'aVal', 'type': None, 'valueInfo': None}}, with_variables_in_return=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4E43B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4E58A0>\nbody = '{\"variables\": {\"aVar\": {\"value\": \"aVal\", \"type\": null, \"valueInfo\": null}}, \"withVariablesInReturn\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', mock_post_with_variables_in_return)\n    def test_complete_returns_variables(engine_url):\n        complete_task = pycamunda.task.Complete(\n            url=engine_url, id_='anId', with_variables_in_return=True\n        )\n        complete_task.add_variable(name='aVar', value='aVal')\n>       variables = complete_task()\n\ntests\\task\\test_complete.py:73: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:578: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Complete(url='http://localhost/engine-rest/task/anId/complete', id_='anId', variables={'aVar': {'value': 'aVal', 'type': None, 'valueInfo': None}}, with_variables_in_return=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4E43B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4E58A0>\nbody = '{\"variables\": {\"aVar\": {\"value\": \"aVal\", \"type\": null, \"valueInfo\": null}}, \"withVariablesInReturn\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_countbycandidategroup.py::test_countbycandidategroup_load",
      "lineno": 8,
      "outcome": "passed",
      "keywords": [
        "test_countbycandidategroup_load",
        "test_countbycandidategroup.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_countbycandidategroup.py::test_countbycandidategroup_load_raises_key_error",
      "lineno": 14,
      "outcome": "passed",
      "keywords": [
        "test_countbycandidategroup_load_raises_key_error",
        "test_countbycandidategroup.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_create.py::test_create_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_create_params",
        "test_create.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_create.py::test_create_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_create_calls_requests",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_create.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 729,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/task/create', id_='anId', name='aName', description='aDescription', assignee=...=datetime.timezone.utc), priority=10, parent_task_id='aTaskId', case_instance_id='anInstanceId', tenant_id='aTenantId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CDF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4E6700>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4E6750>\nbody = '{\"id\": \"anId\", \"name\": \"aName\", \"description\": \"aDescription\", \"assignee\": \"anAssignee\", \"owner\": \"anOwner\", \"delegat...01:01.000+0000\", \"priority\": 10, \"parentTaskId\": \"aTaskId\", \"caseInstanceId\": \"anInstanceId\", \"tenantId\": \"aTenantId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200207221008'>\nengine_url = 'http://localhost/engine-rest'\ntask_input = {'assignee': 'anAssignee', 'case_instance_id': 'anInstanceId', 'delegation_state': 'PENDING', 'description': 'aDescription', ...}\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_create_calls_requests(mock, engine_url, task_input):\n        create_task = pycamunda.task.Create(url=engine_url, id_='anId', **task_input)\n>       create_task()\n\ntests\\task\\test_create.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:729: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/task/create', id_='anId', name='aName', description='aDescription', assignee=...=datetime.timezone.utc), priority=10, parent_task_id='aTaskId', case_instance_id='anInstanceId', tenant_id='aTenantId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CDF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4E6700>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4E6750>\nbody = '{\"id\": \"anId\", \"name\": \"aName\", \"description\": \"aDescription\", \"assignee\": \"anAssignee\", \"owner\": \"anOwner\", \"delegat...01:01.000+0000\", \"priority\": 10, \"parentTaskId\": \"aTaskId\", \"caseInstanceId\": \"anInstanceId\", \"tenantId\": \"aTenantId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2258 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_create.py::test_create_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_create_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_create.py::test_create_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_create_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_create.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 729,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/task/create', id_='anId', name='aName', description='aDescription', assignee=...=datetime.timezone.utc), priority=10, parent_task_id='aTaskId', case_instance_id='anInstanceId', tenant_id='aTenantId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17870>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4E67F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4E6AC0>\nbody = '{\"id\": \"anId\", \"name\": \"aName\", \"description\": \"aDescription\", \"assignee\": \"anAssignee\", \"owner\": \"anOwner\", \"delegat...01:01.000+0000\", \"priority\": 10, \"parentTaskId\": \"aTaskId\", \"caseInstanceId\": \"anInstanceId\", \"tenantId\": \"aTenantId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241479616'>\nengine_url = 'http://localhost/engine-rest'\ntask_input = {'assignee': 'anAssignee', 'case_instance_id': 'anInstanceId', 'delegation_state': 'PENDING', 'description': 'aDescription', ...}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_create_raises_for_status(mock, engine_url, task_input):\n        create_task = pycamunda.task.Create(url=engine_url, id_='anId', **task_input)\n>       create_task()\n\ntests\\task\\test_create.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:729: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/task/create', id_='anId', name='aName', description='aDescription', assignee=...=datetime.timezone.utc), priority=10, parent_task_id='aTaskId', case_instance_id='anInstanceId', tenant_id='aTenantId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17870>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4E67F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4E6AC0>\nbody = '{\"id\": \"anId\", \"name\": \"aName\", \"description\": \"aDescription\", \"assignee\": \"anAssignee\", \"owner\": \"anOwner\", \"delegat...01:01.000+0000\", \"priority\": 10, \"parentTaskId\": \"aTaskId\", \"caseInstanceId\": \"anInstanceId\", \"tenantId\": \"aTenantId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_create.py::test_create_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_create_returns_none",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2505 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_create.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 729,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/task/create', id_='anId', name='aName', description='aDescription', assignee=...=datetime.timezone.utc), priority=10, parent_task_id='aTaskId', case_instance_id='anInstanceId', tenant_id='aTenantId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17AB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4E7F60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4E7CE0>\nbody = '{\"id\": \"anId\", \"name\": \"aName\", \"description\": \"aDescription\", \"assignee\": \"anAssignee\", \"owner\": \"anOwner\", \"delegat...01:01.000+0000\", \"priority\": 10, \"parentTaskId\": \"aTaskId\", \"caseInstanceId\": \"anInstanceId\", \"tenantId\": \"aTenantId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2505 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\ntask_input = {'assignee': 'anAssignee', 'case_instance_id': 'anInstanceId', 'delegation_state': 'PENDING', 'description': 'aDescription', ...}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_create_returns_none(engine_url, task_input):\n        create_task = pycamunda.task.Create(url=engine_url, id_='anId', **task_input)\n>       result = create_task()\n\ntests\\task\\test_create.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:729: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/task/create', id_='anId', name='aName', description='aDescription', assignee=...=datetime.timezone.utc), priority=10, parent_task_id='aTaskId', case_instance_id='anInstanceId', tenant_id='aTenantId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17AB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4E7F60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4E7CE0>\nbody = '{\"id\": \"anId\", \"name\": \"aName\", \"description\": \"aDescription\", \"assignee\": \"anAssignee\", \"owner\": \"anOwner\", \"delegat...01:01.000+0000\", \"priority\": 10, \"parentTaskId\": \"aTaskId\", \"caseInstanceId\": \"anInstanceId\", \"tenantId\": \"aTenantId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2505 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_delegate.py::test_delegate_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_delegate_params",
        "test_delegate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_delegate.py::test_delegate_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_delegate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_delegate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_delegate.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 661,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delegate(url='http://localhost/engine-rest/task/anId/delegate', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D489670>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4898A0>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200241749216'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_delegate_calls_requests(mock, engine_url):\n        delegate_task = pycamunda.task.Delegate(url=engine_url, id_='anId', user_id='anUserId')\n>       delegate_task()\n\ntests\\task\\test_delegate.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:661: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delegate(url='http://localhost/engine-rest/task/anId/delegate', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D489670>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D4898A0>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_delegate.py::test_delegate_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_delegate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_delegate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_delegate.py::test_delegate_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_delegate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_delegate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2565 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_delegate.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 661,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delegate(url='http://localhost/engine-rest/task/anId/delegate', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D48A7A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D48A660>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2565 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241472704'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_delegate_raises_for_status(mock, engine_url):\n        delegate_task = pycamunda.task.Delegate(url=engine_url, id_='anId', user_id='anUserId')\n>       delegate_task()\n\ntests\\task\\test_delegate.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:661: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delegate(url='http://localhost/engine-rest/task/anId/delegate', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D48A7A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D48A660>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2565 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_delegate.py::test_delegate_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_delegate_returns_none",
        "__wrapped__",
        "patchings",
        "test_delegate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2608 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_delegate.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 661,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delegate(url='http://localhost/engine-rest/task/anId/delegate', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D48B6F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D48B740>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2608 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_delegate_returns_none(engine_url):\n        delegate_task = pycamunda.task.Delegate(url=engine_url, id_='anId', user_id='anUserId')\n>       result = delegate_task()\n\ntests\\task\\test_delegate.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:661: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delegate(url='http://localhost/engine-rest/task/anId/delegate', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D48B6F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D48B740>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2608 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_get.py::test_get_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2518 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_get.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 161,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/task/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D629620>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D629260>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2518 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200239456224'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.task.Task.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n        get_task = pycamunda.task.Get(url=engine_url, id_='anId')\n>       get_task()\n\ntests\\task\\test_get.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:161: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/task/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D629620>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D629260>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2518 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_get.py::test_get_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2308 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_get.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 161,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/task/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D629C60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6297B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2308 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241756032'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.task.Task', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_task = pycamunda.task.Get(url=engine_url, id_='anId')\n>       get_task()\n\ntests\\task\\test_get.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:161: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/task/anId', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D629C60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6297B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2308 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_get.py::test_get_returns_task",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_task",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 50,
          "message": "TypeError: functions are not supported for this option"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_get.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 161,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 50,
            "message": "TypeError"
          }
        ],
        "longrepr": "engine_url = <MagicMock name='from_isoformat' id='3200241759872'>\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat')\n    def test_get_returns_task(engine_url):\n        get_task = pycamunda.task.Get(url=engine_url, id_='anId')\n>       task = get_task()\n\ntests\\task\\test_get.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:161: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url=<MagicMock name='from_isoformat.__add__().__add__().format().rstrip()' id='3200242422688'>, id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18170>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D62B100>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D62B0B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n>           curl.setopt(pycurl.URL, self.url)\nE           TypeError: functions are not supported for this option\n\npycamunda\\base.py:50: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_getcountbycandidategroup.py::test_getcountbycandidategroup_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getcountbycandidategroup_params",
        "test_getcountbycandidategroup.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_getcountbycandidategroup.py::test_getcountbycandidategroup_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getcountbycandidategroup_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getcountbycandidategroup.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_getcountbycandidategroup.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1190,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetCountByCandidateGroup(url='http://localhost/engine-rest/task/report/candidate-group-count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4E7DD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D48ACA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200242429648'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.task.CountByCandidateGroup.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_getcountbycandidategroup_calls_requests(mock, engine_url):\n        get_task_counts = pycamunda.task.GetCountByCandidateGroup(url=engine_url)\n>       get_task_counts()\n\ntests\\task\\test_getcountbycandidategroup.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1190: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetCountByCandidateGroup(url='http://localhost/engine-rest/task/report/candidate-group-count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D4E7DD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D48ACA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_getcountbycandidategroup.py::test_getcountbycandidategroup_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_getcountbycandidategroup_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getcountbycandidategroup.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_getcountbycandidategroup.py::test_getcountbycandidategroup_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_getcountbycandidategroup_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getcountbycandidategroup.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2246 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_getcountbycandidategroup.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1190,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetCountByCandidateGroup(url='http://localhost/engine-rest/task/report/candidate-group-count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D534770>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D534090>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2246 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200242535024'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.task.CountByCandidateGroup', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getcountbycandidategroup_raises_for_status(mock, engine_url):\n        get_task_counts = pycamunda.task.GetCountByCandidateGroup(url=engine_url)\n>       get_task_counts()\n\ntests\\task\\test_getcountbycandidategroup.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1190: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetCountByCandidateGroup(url='http://localhost/engine-rest/task/report/candidate-group-count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D534770>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D534090>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2246 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_getcountbycandidategroup.py::test_getcountbycandidategroup_returns_coundbycandidategroup",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_getcountbycandidategroup_returns_coundbycandidategroup",
        "__wrapped__",
        "patchings",
        "test_getcountbycandidategroup.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2680 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_getcountbycandidategroup.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1190,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetCountByCandidateGroup(url='http://localhost/engine-rest/task/report/candidate-group-count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D535120>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D535030>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2680 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getcountbycandidategroup_returns_coundbycandidategroup(engine_url):\n        get_task_counts = pycamunda.task.GetCountByCandidateGroup(url=engine_url)\n>       task_counts = get_task_counts()\n\ntests\\task\\test_getcountbycandidategroup.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1190: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetCountByCandidateGroup(url='http://localhost/engine-rest/task/report/candidate-group-count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D535120>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D535030>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2680 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_getlist.py::test_getlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_getlist.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 498,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/task')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE16F70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D536D40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D536DE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200241474720'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.task.Task.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_tasks = pycamunda.task.GetList(url=engine_url)\n>       get_tasks()\n\ntests\\task\\test_getlist.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:498: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/task')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE16F70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D536D40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D536DE0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2241 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_getlist.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 498,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/task')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5372E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D537560>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200242433776'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.task.Task', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_tasks = pycamunda.task.GetList(url=engine_url)\n>       get_tasks()\n\ntests\\task\\test_getlist.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:498: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/task')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5372E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D537560>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2257 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_getlist.py::test_getlist_returns_group",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_group",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 50,
          "message": "TypeError: functions are not supported for this option"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_getlist.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 498,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 50,
            "message": "TypeError"
          }
        ],
        "longrepr": "engine_url = <MagicMock name='from_isoformat' id='3200242422880'>\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base.from_isoformat')\n    def test_getlist_returns_group(engine_url):\n        get_tasks = pycamunda.task.GetList(url=engine_url)\n>       tasks = get_tasks()\n\ntests\\task\\test_getlist.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:498: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url=<MagicMock name='from_isoformat.__add__().format().rstrip()' id='3200242547216'>)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D62BB00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D62B240>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n>           curl.setopt(pycurl.URL, self.url)\nE           TypeError: functions are not supported for this option\n\npycamunda\\base.py:50: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylink.py::test_identitylink_load",
      "lineno": 9,
      "outcome": "passed",
      "keywords": [
        "test_identitylink_load",
        "test_identitylink.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylink.py::test_identitylink_load_raises_key_error",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_identitylink_load_raises_key_error",
        "test_identitylink.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksadd.py::test_identitylinksadd_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_identitylinksadd_params",
        "test_identitylinksadd.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksadd.py::test_identitylinksadd_raises_assertion_error",
      "lineno": 20,
      "outcome": "passed",
      "keywords": [
        "test_identitylinksadd_raises_assertion_error",
        "test_identitylinksadd.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksadd.py::test_identitylinksadd_calls_requests",
      "lineno": 27,
      "outcome": "failed",
      "keywords": [
        "test_identitylinksadd_calls_requests",
        "__wrapped__",
        "patchings",
        "test_identitylinksadd.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_identitylinksadd.py",
            "lineno": 33,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 861,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = IdentityLinksAdd(url='http://localhost/engine-rest/task/anId/identity-links', task_id='anId', user_id='anotherId', type_='assignee')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE171B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D581620>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D581670>\nbody = '{\"userId\": \"anotherId\", \"type\": \"assignee\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200243695888'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_identitylinksadd_calls_requests(mock, engine_url):\n        add_link = pycamunda.task.IdentityLinksAdd(\n            url=engine_url, task_id='anId', user_id='anotherId', type_='assignee'\n        )\n>       add_link()\n\ntests\\task\\test_identitylinksadd.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:861: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = IdentityLinksAdd(url='http://localhost/engine-rest/task/anId/identity-links', task_id='anId', user_id='anotherId', type_='assignee')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE171B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D581620>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D581670>\nbody = '{\"userId\": \"anotherId\", \"type\": \"assignee\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksadd.py::test_identitylinksadd_raises_pycamunda_exception",
      "lineno": 38,
      "outcome": "passed",
      "keywords": [
        "test_identitylinksadd_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_identitylinksadd.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksadd.py::test_identitylinksadd_raises_for_status",
      "lineno": 47,
      "outcome": "failed",
      "keywords": [
        "test_identitylinksadd_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_identitylinksadd.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2503 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_identitylinksadd.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 861,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = IdentityLinksAdd(url='http://localhost/engine-rest/task/anId/identity-links', task_id='anId', user_id='anotherId', type_='assignee')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CBB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5818F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D581C60>\nbody = '{\"userId\": \"anotherId\", \"type\": \"assignee\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2503 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200242333216'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_identitylinksadd_raises_for_status(mock, engine_url):\n        add_link = pycamunda.task.IdentityLinksAdd(\n            url=engine_url, task_id='anId', user_id='anotherId', type_='assignee'\n        )\n>       add_link()\n\ntests\\task\\test_identitylinksadd.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:861: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = IdentityLinksAdd(url='http://localhost/engine-rest/task/anId/identity-links', task_id='anId', user_id='anotherId', type_='assignee')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CBB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5818F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D581C60>\nbody = '{\"userId\": \"anotherId\", \"type\": \"assignee\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2503 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksadd.py::test_identitylinksadd_returns_group",
      "lineno": 58,
      "outcome": "failed",
      "keywords": [
        "test_identitylinksadd_returns_group",
        "__wrapped__",
        "patchings",
        "test_identitylinksadd.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_identitylinksadd.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 861,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = IdentityLinksAdd(url='http://localhost/engine-rest/task/anId/identity-links', task_id='anId', user_id='anotherId', type_='assignee')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D583830>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D583330>\nbody = '{\"userId\": \"anotherId\", \"type\": \"assignee\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_identitylinksadd_returns_group(engine_url):\n        add_link = pycamunda.task.IdentityLinksAdd(\n            url=engine_url, task_id='anId', user_id='anotherId', type_='assignee'\n        )\n>       result = add_link()\n\ntests\\task\\test_identitylinksadd.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:861: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = IdentityLinksAdd(url='http://localhost/engine-rest/task/anId/identity-links', task_id='anId', user_id='anotherId', type_='assignee')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D583830>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D583330>\nbody = '{\"userId\": \"anotherId\", \"type\": \"assignee\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksdelete.py::test_identitylinksdelete_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_identitylinksdelete_params",
        "test_identitylinksdelete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksdelete.py::test_identitylinksdelete_raises_assertion_error",
      "lineno": 20,
      "outcome": "passed",
      "keywords": [
        "test_identitylinksdelete_raises_assertion_error",
        "test_identitylinksdelete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksdelete.py::test_identitylinksdelete_calls_requests",
      "lineno": 27,
      "outcome": "failed",
      "keywords": [
        "test_identitylinksdelete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_identitylinksdelete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_identitylinksdelete.py",
            "lineno": 33,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 897,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = IdentityLinksDelete(url='http://localhost/engine-rest/task/anId/identity-links/delete', task_id='anId', user_id='anotherId', type_='assignee')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D536E30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D534130>\nbody = '{\"userId\": \"anotherId\", \"type\": \"assignee\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200242538192'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_identitylinksdelete_calls_requests(mock, engine_url):\n        delete_link = pycamunda.task.IdentityLinksDelete(\n            url=engine_url, task_id='anId', user_id='anotherId', type_='assignee'\n        )\n>       delete_link()\n\ntests\\task\\test_identitylinksdelete.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:897: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = IdentityLinksDelete(url='http://localhost/engine-rest/task/anId/identity-links/delete', task_id='anId', user_id='anotherId', type_='assignee')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D536E30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D534130>\nbody = '{\"userId\": \"anotherId\", \"type\": \"assignee\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksdelete.py::test_identitylinksdelete_raises_pycamunda_exception",
      "lineno": 38,
      "outcome": "passed",
      "keywords": [
        "test_identitylinksdelete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_identitylinksdelete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksdelete.py::test_identitylinksdelete_raises_for_status",
      "lineno": 47,
      "outcome": "failed",
      "keywords": [
        "test_identitylinksdelete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_identitylinksdelete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2425 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_identitylinksdelete.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 897,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = IdentityLinksDelete(url='http://localhost/engine-rest/task/anId/identity-links/delete', task_id='anId', user_id='anotherId', type_='assignee')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E470>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D58CD10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D58C090>\nbody = '{\"userId\": \"anotherId\", \"type\": \"assignee\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2425 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200242430272'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_identitylinksdelete_raises_for_status(mock, engine_url):\n        delete_link = pycamunda.task.IdentityLinksDelete(\n            url=engine_url, task_id='anId', user_id='anotherId', type_='assignee'\n        )\n>       delete_link()\n\ntests\\task\\test_identitylinksdelete.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:897: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = IdentityLinksDelete(url='http://localhost/engine-rest/task/anId/identity-links/delete', task_id='anId', user_id='anotherId', type_='assignee')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E470>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D58CD10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D58C090>\nbody = '{\"userId\": \"anotherId\", \"type\": \"assignee\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2425 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksdelete.py::test_identitylinksdelete_returns_group",
      "lineno": 58,
      "outcome": "failed",
      "keywords": [
        "test_identitylinksdelete_returns_group",
        "__wrapped__",
        "patchings",
        "test_identitylinksdelete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2393 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_identitylinksdelete.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 897,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = IdentityLinksDelete(url='http://localhost/engine-rest/task/anId/identity-links/delete', task_id='anId', user_id='anotherId', type_='assignee')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D58D7B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D58D0D0>\nbody = '{\"userId\": \"anotherId\", \"type\": \"assignee\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2393 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_identitylinksdelete_returns_group(engine_url):\n        delete_link = pycamunda.task.IdentityLinksDelete(\n            url=engine_url, task_id='anId', user_id='anotherId', type_='assignee'\n        )\n>       result = delete_link()\n\ntests\\task\\test_identitylinksdelete.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:897: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = IdentityLinksDelete(url='http://localhost/engine-rest/task/anId/identity-links/delete', task_id='anId', user_id='anotherId', type_='assignee')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D58D7B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D58D0D0>\nbody = '{\"userId\": \"anotherId\", \"type\": \"assignee\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2393 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksgetlist.py::test_identitylinksgetlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_identitylinksgetlist_params",
        "test_identitylinksgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksgetlist.py::test_identitylinksgetlist_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_identitylinksgetlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_identitylinksgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2519 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_identitylinksgetlist.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 823,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = IdentityLinksGetList(url='http://localhost/engine-rest/task/None/identity-links')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DDB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D58D080>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D58F100>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2519 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200242329424'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('pycamunda.task.IdentityLink.load', unittest.mock.MagicMock())\n    @unittest.mock.patch('requests.Session.request')\n    def test_identitylinksgetlist_calls_requests(mock, engine_url):\n        get_links = pycamunda.task.IdentityLinksGetList(url=engine_url)\n>       get_links()\n\ntests\\task\\test_identitylinksgetlist.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:823: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = IdentityLinksGetList(url='http://localhost/engine-rest/task/None/identity-links')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DDB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D58D080>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D58F100>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2519 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksgetlist.py::test_identitylinksgetlist_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_identitylinksgetlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_identitylinksgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksgetlist.py::test_identitylinksgetlist_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_identitylinksgetlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_identitylinksgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_identitylinksgetlist.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 823,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = IdentityLinksGetList(url='http://localhost/engine-rest/task/None/identity-links')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18830>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D58F330>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D581990>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200242429792'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.task.IdentityLink', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_identitylinksgetlist_raises_for_status(mock, engine_url):\n        get_links = pycamunda.task.IdentityLinksGetList(url=engine_url)\n>       get_links()\n\ntests\\task\\test_identitylinksgetlist.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:823: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = IdentityLinksGetList(url='http://localhost/engine-rest/task/None/identity-links')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18830>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D58F330>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D581990>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_identitylinksgetlist.py::test_identitylinksgetlist_returns_group",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_identitylinksgetlist_returns_group",
        "__wrapped__",
        "patchings",
        "test_identitylinksgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2597 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_identitylinksgetlist.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 823,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = IdentityLinksGetList(url='http://localhost/engine-rest/task/None/identity-links')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D544E50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D544D60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2597 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_identitylinksgetlist_returns_group(engine_url):\n        get_links = pycamunda.task.IdentityLinksGetList(url=engine_url)\n>       links = get_links()\n\ntests\\task\\test_identitylinksgetlist.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:823: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = IdentityLinksGetList(url='http://localhost/engine-rest/task/None/identity-links')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D544E50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D544D60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2597 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesdelete.py::test_localvariablesdelete_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesdelete_params",
        "test_localvariablesdelete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesdelete.py::test_localvariablesdelete_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesdelete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_localvariablesdelete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesdelete.py",
            "lineno": 26,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1176,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesDelete(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A0F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D545670>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D545C60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200242429936'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_localvariablesdelete_calls_requests(mock, engine_url):\n        delete_var = pycamunda.task.LocalVariablesDelete(\n            url=engine_url, task_id='anId', var_name='aVar'\n        )\n>       delete_var()\n\ntests\\task\\test_localvariablesdelete.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1176: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesDelete(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A0F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D545670>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D545C60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2229 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesdelete.py::test_localvariablesdelete_raises_pycamunda_exception",
      "lineno": 31,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesdelete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_localvariablesdelete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesdelete.py::test_localvariablesdelete_raises_for_status",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesdelete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_localvariablesdelete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2249 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesdelete.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1176,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesDelete(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18EF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D530950>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5309F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2249 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200242419616'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_localvariablesdelete_raises_for_status(mock, engine_url):\n        delete_var = pycamunda.task.LocalVariablesDelete(\n            url=engine_url, task_id='anId', var_name='aVar'\n        )\n>       delete_var()\n\ntests\\task\\test_localvariablesdelete.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1176: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesDelete(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18EF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D530950>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5309F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2249 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesdelete.py::test_localvariablesdelete_returns_none",
      "lineno": 51,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesdelete_returns_none",
        "__wrapped__",
        "patchings",
        "test_localvariablesdelete.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesdelete.py",
            "lineno": 57,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1176,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesDelete(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3C9580>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3CA4D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_localvariablesdelete_returns_none(engine_url):\n        delete_var = pycamunda.task.LocalVariablesDelete(\n            url=engine_url, task_id='anId', var_name='aVar'\n        )\n>       result = delete_var()\n\ntests\\task\\test_localvariablesdelete.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1176: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesDelete(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D3C9580>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D3CA4D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesget.py::test_localvariablesget_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesget_params",
        "test_localvariablesget.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesget.py::test_localvariablesget_binary_params",
      "lineno": 21,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesget_binary_params",
        "test_localvariablesget.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesget.py::test_localvariablesget_calls_requests",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesget_calls_requests",
        "__wrapped__",
        "patchings",
        "test_localvariablesget.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2280 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesget.py",
            "lineno": 33,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1003,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesGet(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D547420>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D547470>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2280 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200241014288'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_localvariablesget_calls_requests(mock, engine_url):\n        get_var = pycamunda.task.LocalVariablesGet(url=engine_url, task_id='anId', var_name='aVar')\n>       get_var()\n\ntests\\task\\test_localvariablesget.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1003: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesGet(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D547420>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D547470>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2280 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesget.py::test_localvariablesget_raises_pycamunda_exception",
      "lineno": 38,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesget_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_localvariablesget.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesget.py::test_localvariablesget_raises_for_status",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesget_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_localvariablesget.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesget.py",
            "lineno": 51,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1003,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesGet(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D55CEF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D55D7B0>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200239420240'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.variable.Variable', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_localvariablesget_raises_for_status(mock, engine_url):\n        get_var = pycamunda.task.LocalVariablesGet(url=engine_url, task_id='anId', var_name='aVar')\n>       get_var()\n\ntests\\task\\test_localvariablesget.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1003: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesGet(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D55CEF0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D55D7B0>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesget.py::test_localvariablesget_returns_variable",
      "lineno": 55,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesget_returns_variable",
        "__wrapped__",
        "patchings",
        "test_localvariablesget.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesget.py",
            "lineno": 59,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1003,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesGet(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE16F70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D55CE00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D55D940>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_localvariablesget_returns_variable(engine_url):\n        get_var = pycamunda.task.LocalVariablesGet(url=engine_url, task_id='anId', var_name='aVar')\n>       variable = get_var()\n\ntests\\task\\test_localvariablesget.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1003: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesGet(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE16F70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D55CE00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D55D940>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesgetlist.py::test_localvariablesgetlist_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesgetlist_params",
        "test_localvariablesgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesgetlist.py::test_localvariablesgetlist_calls_requests",
      "lineno": 21,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesgetlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_localvariablesgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2268 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesgetlist.py",
            "lineno": 27,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1036,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesGetList(url='http://localhost/engine-rest/task/anId/localVariables', task_id='anId', deserialize_values=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D55E980>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D55D530>\nquery_string = 'deserializeValues=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2268 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200232187632'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_localvariablesgetlist_calls_requests(mock, engine_url):\n        get_vars = pycamunda.task.LocalVariablesGetList(\n            url=engine_url, task_id='anId', deserialize_values=True\n        )\n>       get_vars()\n\ntests\\task\\test_localvariablesgetlist.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1036: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesGetList(url='http://localhost/engine-rest/task/anId/localVariables', task_id='anId', deserialize_values=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D55E980>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D55D530>\nquery_string = 'deserializeValues=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2268 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesgetlist.py::test_localvariablesgetlist_raises_pycamunda_exception",
      "lineno": 32,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesgetlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_localvariablesgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesgetlist.py::test_localvariablesgetlist_raises_for_status",
      "lineno": 41,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesgetlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_localvariablesgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesgetlist.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1036,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesGetList(url='http://localhost/engine-rest/task/anId/localVariables', task_id='anId', deserialize_values=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D55FCE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D55ED90>\nquery_string = 'deserializeValues=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200206967616'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.variable.Variable', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_localvariablesgetlist_raises_for_status(mock, engine_url):\n        get_vars = pycamunda.task.LocalVariablesGetList(\n            url=engine_url, task_id='anId', deserialize_values=True\n        )\n>       get_vars()\n\ntests\\task\\test_localvariablesgetlist.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1036: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesGetList(url='http://localhost/engine-rest/task/anId/localVariables', task_id='anId', deserialize_values=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D55FCE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D55ED90>\nquery_string = 'deserializeValues=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesgetlist.py::test_localvariablesgetlist_returns_dict",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesgetlist_returns_dict",
        "__wrapped__",
        "patchings",
        "test_localvariablesgetlist.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesgetlist.py",
            "lineno": 59,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1036,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesGetList(url='http://localhost/engine-rest/task/anId/localVariables', task_id='anId', deserialize_values=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5478D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D547290>\nquery_string = 'deserializeValues=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_localvariablesgetlist_returns_dict(engine_url):\n        get_vars = pycamunda.task.LocalVariablesGetList(\n            url=engine_url, task_id='anId', deserialize_values=True\n        )\n>       variables = get_vars()\n\ntests\\task\\test_localvariablesgetlist.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1036: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesGetList(url='http://localhost/engine-rest/task/anId/localVariables', task_id='anId', deserialize_values=True)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C730>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5478D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D547290>\nquery_string = 'deserializeValues=true'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesmodify.py::test_localvariablesmodify_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesmodify_params",
        "test_localvariablesmodify.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesmodify.py::test_localvariablesmodify_calls_requests",
      "lineno": 24,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesmodify_calls_requests",
        "__wrapped__",
        "patchings",
        "test_localvariablesmodify.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2518 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesmodify.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1089,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesModify(url='http://localhost/engine-rest/task/anId/localVariables', task_id='anId', modifications={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BBF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D569030>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D568E50>\nbody = '{\"modifications\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2518 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200242328560'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_localvariablesmodify_calls_requests(mock, engine_url):\n        modify_vars = pycamunda.task.LocalVariablesModify(url=engine_url, task_id='anId')\n>       modify_vars()\n\ntests\\task\\test_localvariablesmodify.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1089: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesModify(url='http://localhost/engine-rest/task/anId/localVariables', task_id='anId', modifications={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BBF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D569030>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D568E50>\nbody = '{\"modifications\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2518 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesmodify.py::test_localvariablesmodify_raises_pycamunda_exception",
      "lineno": 33,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesmodify_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_localvariablesmodify.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesmodify.py::test_localvariablesmodify_raises_for_status",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesmodify_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_localvariablesmodify.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesmodify.py",
            "lineno": 45,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1089,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesModify(url='http://localhost/engine-rest/task/anId/localVariables', task_id='anId', modifications={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D56A700>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5695D0>\nbody = '{\"modifications\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200242419280'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_localvariablesmodify_raises_for_status(mock, engine_url):\n        modify_vars = pycamunda.task.LocalVariablesModify(url=engine_url, task_id='anId')\n>       modify_vars()\n\ntests\\task\\test_localvariablesmodify.py:45: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1089: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesModify(url='http://localhost/engine-rest/task/anId/localVariables', task_id='anId', modifications={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D56A700>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5695D0>\nbody = '{\"modifications\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesmodify.py::test_localvariablesmodify_returns_none",
      "lineno": 49,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesmodify_returns_none",
        "__wrapped__",
        "patchings",
        "test_localvariablesmodify.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2388 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesmodify.py",
            "lineno": 53,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1089,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesModify(url='http://localhost/engine-rest/task/anId/localVariables', task_id='anId', modifications={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D56B830>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D56AA70>\nbody = '{\"modifications\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2388 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_localvariablesmodify_returns_none(engine_url):\n        modify_vars = pycamunda.task.LocalVariablesModify(url=engine_url, task_id='anId')\n>       result = modify_vars()\n\ntests\\task\\test_localvariablesmodify.py:53: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1089: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesModify(url='http://localhost/engine-rest/task/anId/localVariables', task_id='anId', modifications={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D56B830>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D56AA70>\nbody = '{\"modifications\": {}, \"deletions\": []}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2388 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesupdate_params",
        "test_localvariablesupdate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_binary_params",
      "lineno": 21,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesupdate_binary_params",
        "test_localvariablesupdate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_calls_requests",
      "lineno": 37,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesupdate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_localvariablesupdate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2368 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesupdate.py",
            "lineno": 43,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1150,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesUpdate(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar', value='aVal', type_='String', value_info={})\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CDF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5E0590>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5E05E0>\nbody = '{\"value\": \"aVal\", \"type\": \"String\", \"valueInfo\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2368 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200242543376'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_localvariablesupdate_calls_requests(mock, engine_url):\n        update_var = pycamunda.task.LocalVariablesUpdate(\n            url=engine_url, task_id='anId', var_name='aVar', value='aVal', type_='String', value_info={}\n        )\n>       update_var()\n\ntests\\task\\test_localvariablesupdate.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1150: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesUpdate(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar', value='aVal', type_='String', value_info={})\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CDF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5E0590>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5E05E0>\nbody = '{\"value\": \"aVal\", \"type\": \"String\", \"valueInfo\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2368 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_binary_calls_requests",
      "lineno": 48,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesupdate_binary_calls_requests",
        "__wrapped__",
        "patchings",
        "test_localvariablesupdate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2219 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesupdate.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1148,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesUpdate(url='http://localhost/engine-rest/task/anId/localVariables/aVar/data', task_id='anId', var_name='aVar', value=<_io.StringIO object at 0x000002E91CF85180>, type_='Bytes')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5E0A40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5E0BD0>\nbody = '{\"valueType\": \"Bytes\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2219 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200241019136'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_localvariablesupdate_binary_calls_requests(mock, engine_url):\n        update_var = pycamunda.task.LocalVariablesUpdate(\n            url=engine_url, task_id='anId', var_name='aVar', value=io.StringIO('myfile'), type_='Bytes'\n        )\n>       update_var()\n\ntests\\task\\test_localvariablesupdate.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1148: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesUpdate(url='http://localhost/engine-rest/task/anId/localVariables/aVar/data', task_id='anId', var_name='aVar', value=<_io.StringIO object at 0x000002E91CF85180>, type_='Bytes')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5E0A40>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5E0BD0>\nbody = '{\"valueType\": \"Bytes\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2219 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_raises_pycamunda_exception",
      "lineno": 58,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesupdate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_localvariablesupdate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_binary_raises_pycamunda_exception",
      "lineno": 67,
      "outcome": "passed",
      "keywords": [
        "test_localvariablesupdate_binary_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_localvariablesupdate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_raises_for_status",
      "lineno": 76,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesupdate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_localvariablesupdate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2455 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesupdate.py",
            "lineno": 83,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1150,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesUpdate(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar', value='aVal', type_='String', value_info={})\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5E2750>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5E1FD0>\nbody = '{\"value\": \"aVal\", \"type\": \"String\", \"valueInfo\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2455 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241479424'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_localvariablesupdate_raises_for_status(mock, engine_url):\n        update_var = pycamunda.task.LocalVariablesUpdate(\n            url=engine_url, task_id='anId', var_name='aVar', value='aVal', type_='String', value_info={}\n        )\n>       update_var()\n\ntests\\task\\test_localvariablesupdate.py:83: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1150: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesUpdate(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar', value='aVal', type_='String', value_info={})\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5E2750>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5E1FD0>\nbody = '{\"value\": \"aVal\", \"type\": \"String\", \"valueInfo\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2455 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_localvariablesupdate.py::test_localvariablesupdate_returns_none",
      "lineno": 87,
      "outcome": "failed",
      "keywords": [
        "test_localvariablesupdate_returns_none",
        "__wrapped__",
        "patchings",
        "test_localvariablesupdate.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_localvariablesupdate.py",
            "lineno": 93,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 1150,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = LocalVariablesUpdate(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar', value='aVal', type_='String', value_info={})\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5E27A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5E29D0>\nbody = '{\"value\": \"aVal\", \"type\": \"String\", \"valueInfo\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_localvariablesupdate_returns_none(engine_url):\n        update_var = pycamunda.task.LocalVariablesUpdate(\n            url=engine_url, task_id='anId', var_name='aVar', value='aVal', type_='String', value_info={}\n        )\n>       result = update_var()\n\ntests\\task\\test_localvariablesupdate.py:93: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:1150: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = LocalVariablesUpdate(url='http://localhost/engine-rest/task/anId/localVariables/aVar', task_id='anId', var_name='aVar', value='aVal', type_='String', value_info={})\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D5E27A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D5E29D0>\nbody = '{\"value\": \"aVal\", \"type\": \"String\", \"valueInfo\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_resolve.py::test_resolve_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_resolve_params",
        "test_resolve.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_resolve.py::test_resolve_calls_requests",
      "lineno": 22,
      "outcome": "failed",
      "keywords": [
        "test_resolve_calls_requests",
        "__wrapped__",
        "patchings",
        "test_resolve.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_resolve.py",
            "lineno": 26,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 619,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Resolve(url='http://localhost/engine-rest/task/anId/resolve', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE16F70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D68D6C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D68D710>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200239455168'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_resolve_calls_requests(mock, engine_url):\n        resolve_task = pycamunda.task.Resolve(url=engine_url, id_='anId')\n>       resolve_task()\n\ntests\\task\\test_resolve.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:619: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Resolve(url='http://localhost/engine-rest/task/anId/resolve', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE16F70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D68D6C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D68D710>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_resolve.py::test_resolve_raises_pycamunda_exception",
      "lineno": 31,
      "outcome": "passed",
      "keywords": [
        "test_resolve_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_resolve.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_resolve.py::test_resolve_raises_for_status",
      "lineno": 38,
      "outcome": "failed",
      "keywords": [
        "test_resolve_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_resolve.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_resolve.py",
            "lineno": 43,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 619,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Resolve(url='http://localhost/engine-rest/task/anId/resolve', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D68DE90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D68C950>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200243695840'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_resolve_raises_for_status(mock, engine_url):\n        resolve_task = pycamunda.task.Resolve(url=engine_url, id_='anId')\n>       resolve_task()\n\ntests\\task\\test_resolve.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:619: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Resolve(url='http://localhost/engine-rest/task/anId/resolve', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D68DE90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D68C950>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_resolve.py::test_resolve_returns_none",
      "lineno": 47,
      "outcome": "failed",
      "keywords": [
        "test_resolve_returns_none",
        "__wrapped__",
        "patchings",
        "test_resolve.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_resolve.py",
            "lineno": 51,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 619,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Resolve(url='http://localhost/engine-rest/task/anId/resolve', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17F30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D68E200>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D68E110>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_resolve_returns_none(engine_url):\n        resolve_task = pycamunda.task.Resolve(url=engine_url, id_='anId')\n>       result = resolve_task()\n\ntests\\task\\test_resolve.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:619: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Resolve(url='http://localhost/engine-rest/task/anId/resolve', id_='anId', variables={})\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17F30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D68E200>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D68E110>\nbody = '{\"variables\": {}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2236 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_setassignee.py::test_setassignee_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_setassignee_params",
        "test_setassignee.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_setassignee.py::test_setassignee_calls_requests",
      "lineno": 19,
      "outcome": "failed",
      "keywords": [
        "test_setassignee_calls_requests",
        "__wrapped__",
        "patchings",
        "test_setassignee.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_setassignee.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 640,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = SetAssignee(url='http://localhost/engine-rest/task/anId/assignee', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D68DFD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D68F830>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200233453376'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_setassignee_calls_requests(mock, engine_url):\n        set_task_assignee = pycamunda.task.SetAssignee(url=engine_url, id_='anId', user_id='anUserId')\n>       set_task_assignee()\n\ntests\\task\\test_setassignee.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:640: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = SetAssignee(url='http://localhost/engine-rest/task/anId/assignee', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D68DFD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D68F830>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_setassignee.py::test_setassignee_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_setassignee_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_setassignee.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_setassignee.py::test_setassignee_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_setassignee_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_setassignee.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_setassignee.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 640,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = SetAssignee(url='http://localhost/engine-rest/task/anId/assignee', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73D440>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D73D530>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200243703376'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_setassignee_raises_for_status(mock, engine_url):\n        set_task_assignee = pycamunda.task.SetAssignee(url=engine_url, id_='anId', user_id='anUserId')\n>       set_task_assignee()\n\ntests\\task\\test_setassignee.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:640: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = SetAssignee(url='http://localhost/engine-rest/task/anId/assignee', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73D440>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D73D530>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_setassignee.py::test_setassignee_returns_none",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_setassignee_returns_none",
        "__wrapped__",
        "patchings",
        "test_setassignee.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2588 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_setassignee.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 640,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = SetAssignee(url='http://localhost/engine-rest/task/anId/assignee', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73DCB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D73DB70>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2588 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_setassignee_returns_none(engine_url):\n        set_task_assignee = pycamunda.task.SetAssignee(url=engine_url, id_='anId', user_id='anUserId')\n>       result = set_task_assignee()\n\ntests\\task\\test_setassignee.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:640: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = SetAssignee(url='http://localhost/engine-rest/task/anId/assignee', id_='anId', user_id='anUserId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73DCB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D73DB70>\nbody = '{\"userId\": \"anUserId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2588 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_task.py::test_task_load",
      "lineno": 8,
      "outcome": "passed",
      "keywords": [
        "test_task_load",
        "test_task.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_task.py::test_task_load_raises_key_error",
      "lineno": 14,
      "outcome": "passed",
      "keywords": [
        "test_task_load_raises_key_error",
        "test_task.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_unclaim.py::test_unclaim_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_unclaim_params",
        "test_unclaim.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_unclaim.py::test_unclaim_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_unclaim_calls_requests",
        "__wrapped__",
        "patchings",
        "test_unclaim.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2491 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_unclaim.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 541,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Unclaim(url='http://localhost/engine-rest/task/anId/unclaim', id_='anId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE16F70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73D530>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D73D580>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2491 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200243699968'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_unclaim_calls_requests(mock, engine_url):\n        unclaim_task = pycamunda.task.Unclaim(url=engine_url, id_='anId')\n>       unclaim_task()\n\ntests\\task\\test_unclaim.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:541: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Unclaim(url='http://localhost/engine-rest/task/anId/unclaim', id_='anId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE16F70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73D530>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D73D580>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2491 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_unclaim.py::test_unclaim_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_unclaim_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_unclaim.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_unclaim.py::test_unclaim_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_unclaim_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_unclaim.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2270 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_unclaim.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 541,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Unclaim(url='http://localhost/engine-rest/task/anId/unclaim', id_='anId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73F8D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D730040>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2270 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200242327984'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_unclaim_raises_for_status(mock, engine_url):\n        unclaim_task = pycamunda.task.Unclaim(url=engine_url, id_='anId')\n>       unclaim_task()\n\ntests\\task\\test_unclaim.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:541: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Unclaim(url='http://localhost/engine-rest/task/anId/unclaim', id_='anId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73F8D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D730040>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2270 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_unclaim.py::test_unclaim_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_unclaim_returns_none",
        "__wrapped__",
        "patchings",
        "test_unclaim.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_unclaim.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 541,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Unclaim(url='http://localhost/engine-rest/task/anId/unclaim', id_='anId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D730CC0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D730590>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_unclaim_returns_none(engine_url):\n        unclaim_task = pycamunda.task.Unclaim(url=engine_url, id_='anId')\n>       result = unclaim_task()\n\ntests\\task\\test_unclaim.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:541: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Unclaim(url='http://localhost/engine-rest/task/anId/unclaim', id_='anId')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D730CC0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D730590>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_update.py::test_update_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_update_params",
        "test_update.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_update.py::test_update_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_update_calls_requests",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_update.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 798,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/task/anId', id_='anId', name='aName', description='aDescription', assignee='a...=datetime.timezone.utc), priority=10, parent_task_id='aTaskId', case_instance_id='anInstanceId', tenant_id='aTenantId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7311C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D732020>\nbody = '{\"name\": \"aName\", \"description\": \"aDescription\", \"assignee\": \"anAssignee\", \"owner\": \"anOwner\", \"delegationState\": \"PE...01:01.000+0000\", \"priority\": 10, \"parentTaskId\": \"aTaskId\", \"caseInstanceId\": \"anInstanceId\", \"tenantId\": \"aTenantId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200243613232'>\nengine_url = 'http://localhost/engine-rest'\ntask_input = {'assignee': 'anAssignee', 'case_instance_id': 'anInstanceId', 'delegation_state': 'PENDING', 'description': 'aDescription', ...}\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_update_calls_requests(mock, engine_url, task_input):\n        update_task = pycamunda.task.Update(url=engine_url, id_='anId', **task_input)\n>       update_task()\n\ntests\\task\\test_update.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:798: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/task/anId', id_='anId', name='aName', description='aDescription', assignee='a...=datetime.timezone.utc), priority=10, parent_task_id='aTaskId', case_instance_id='anInstanceId', tenant_id='aTenantId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7311C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D732020>\nbody = '{\"name\": \"aName\", \"description\": \"aDescription\", \"assignee\": \"anAssignee\", \"owner\": \"anOwner\", \"delegationState\": \"PE...01:01.000+0000\", \"priority\": 10, \"parentTaskId\": \"aTaskId\", \"caseInstanceId\": \"anInstanceId\", \"tenantId\": \"aTenantId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_update.py::test_update_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_update_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_update.py::test_update_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_update_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2308 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_update.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 798,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/task/anId', id_='anId', name='aName', description='aDescription', assignee='a...=datetime.timezone.utc), priority=10, parent_task_id='aTaskId', case_instance_id='anInstanceId', tenant_id='aTenantId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D732110>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D733330>\nbody = '{\"name\": \"aName\", \"description\": \"aDescription\", \"assignee\": \"anAssignee\", \"owner\": \"anOwner\", \"delegationState\": \"PE...01:01.000+0000\", \"priority\": 10, \"parentTaskId\": \"aTaskId\", \"caseInstanceId\": \"anInstanceId\", \"tenantId\": \"aTenantId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2308 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200243917664'>\nengine_url = 'http://localhost/engine-rest'\ntask_input = {'assignee': 'anAssignee', 'case_instance_id': 'anInstanceId', 'delegation_state': 'PENDING', 'description': 'aDescription', ...}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_update_raises_for_status(mock, engine_url, task_input):\n        update_task = pycamunda.task.Update(url=engine_url, id_='anId', **task_input)\n>       update_task()\n\ntests\\task\\test_update.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:798: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/task/anId', id_='anId', name='aName', description='aDescription', assignee='a...=datetime.timezone.utc), priority=10, parent_task_id='aTaskId', case_instance_id='anInstanceId', tenant_id='aTenantId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D732110>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D733330>\nbody = '{\"name\": \"aName\", \"description\": \"aDescription\", \"assignee\": \"anAssignee\", \"owner\": \"anOwner\", \"delegationState\": \"PE...01:01.000+0000\", \"priority\": 10, \"parentTaskId\": \"aTaskId\", \"caseInstanceId\": \"anInstanceId\", \"tenantId\": \"aTenantId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2308 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/task/test_update.py::test_update_returns_none",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_update_returns_none",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "task",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2414 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\task\\test_update.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\task.py",
            "lineno": 798,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/task/anId', id_='anId', name='aName', description='aDescription', assignee='a...=datetime.timezone.utc), priority=10, parent_task_id='aTaskId', case_instance_id='anInstanceId', tenant_id='aTenantId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AE70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7336A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D733380>\nbody = '{\"name\": \"aName\", \"description\": \"aDescription\", \"assignee\": \"anAssignee\", \"owner\": \"anOwner\", \"delegationState\": \"PE...01:01.000+0000\", \"priority\": 10, \"parentTaskId\": \"aTaskId\", \"caseInstanceId\": \"anInstanceId\", \"tenantId\": \"aTenantId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2414 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\ntask_input = {'assignee': 'anAssignee', 'case_instance_id': 'anInstanceId', 'delegation_state': 'PENDING', 'description': 'aDescription', ...}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_update_returns_none(engine_url, task_input):\n        update_task = pycamunda.task.Update(url=engine_url, id_='anId', **task_input)\n>       result = update_task()\n\ntests\\task\\test_update.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\task.py:798: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/task/anId', id_='anId', name='aName', description='aDescription', assignee='a...=datetime.timezone.utc), priority=10, parent_task_id='aTaskId', case_instance_id='anInstanceId', tenant_id='aTenantId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AE70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7336A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D733380>\nbody = '{\"name\": \"aName\", \"description\": \"aDescription\", \"assignee\": \"anAssignee\", \"owner\": \"anOwner\", \"delegationState\": \"PE...01:01.000+0000\", \"priority\": 10, \"parentTaskId\": \"aTaskId\", \"caseInstanceId\": \"anInstanceId\", \"tenantId\": \"aTenantId\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2414 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/telemetry/test_configure.py::test_configure_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_configure_params",
        "test_configure.py",
        "telemetry",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/telemetry/test_configure.py::test_configure_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_configure_calls_requests",
        "__wrapped__",
        "patchings",
        "test_configure.py",
        "telemetry",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\telemetry\\test_configure.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\telemetry.py",
            "lineno": 33,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Configure(url='http://localhost/engine-rest/telemetry/configuration', enable_telemetry=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7393A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7393F0>\nbody = '{\"enableTelemetry\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200243612176'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    @unittest.mock.patch('pycamunda.processinst.ProcessInstance', unittest.mock.MagicMock())\n    def test_configure_calls_requests(mock, engine_url):\n        configure_telemetry = pycamunda.telemetry.Configure(url=engine_url, enable_telemetry=True)\n>       configure_telemetry()\n\ntests\\telemetry\\test_configure.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\telemetry.py:33: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Configure(url='http://localhost/engine-rest/telemetry/configuration', enable_telemetry=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7393A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7393F0>\nbody = '{\"enableTelemetry\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/telemetry/test_configure.py::test_configure_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_configure_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_configure.py",
        "telemetry",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/telemetry/test_configure.py::test_configure_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_configure_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_configure.py",
        "telemetry",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2503 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\telemetry\\test_configure.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\telemetry.py",
            "lineno": 33,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Configure(url='http://localhost/engine-rest/telemetry/configuration', enable_telemetry=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73A200>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D738B30>\nbody = '{\"enableTelemetry\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2503 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200243697280'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_configure_raises_for_status(mock, engine_url):\n        configure_telemetry = pycamunda.telemetry.Configure(url=engine_url, enable_telemetry=True)\n>       configure_telemetry()\n\ntests\\telemetry\\test_configure.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\telemetry.py:33: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Configure(url='http://localhost/engine-rest/telemetry/configuration', enable_telemetry=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73A200>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D738B30>\nbody = '{\"enableTelemetry\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2503 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/telemetry/test_configure.py::test_configure_returns_none",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_configure_returns_none",
        "__wrapped__",
        "patchings",
        "test_configure.py",
        "telemetry",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\telemetry\\test_configure.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\telemetry.py",
            "lineno": 33,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Configure(url='http://localhost/engine-rest/telemetry/configuration', enable_telemetry=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CBB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73A660>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D73A390>\nbody = '{\"enableTelemetry\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_configure_returns_none(engine_url):\n        configure_telemetry = pycamunda.telemetry.Configure(url=engine_url, enable_telemetry=True)\n>       result = configure_telemetry()\n\ntests\\telemetry\\test_configure.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\telemetry.py:33: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Configure(url='http://localhost/engine-rest/telemetry/configuration', enable_telemetry=True)\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CBB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73A660>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D73A390>\nbody = '{\"enableTelemetry\": true}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/telemetry/test_fetch.py::test_fetch_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_fetch_params",
        "test_fetch.py",
        "telemetry",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/telemetry/test_fetch.py::test_fetch_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_fetch_calls_requests",
        "__wrapped__",
        "patchings",
        "test_fetch.py",
        "telemetry",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2259 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\telemetry\\test_fetch.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\telemetry.py",
            "lineno": 47,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Fetch(url='http://localhost/engine-rest/telemetry/configuration')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6F83B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6F8400>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2259 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200244595168'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    @unittest.mock.patch('pycamunda.processinst.ProcessInstance', unittest.mock.MagicMock())\n    def test_fetch_calls_requests(mock, engine_url):\n        enable_telemetry = pycamunda.telemetry.Fetch(url=engine_url)\n>       enable_telemetry()\n\ntests\\telemetry\\test_fetch.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\telemetry.py:47: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Fetch(url='http://localhost/engine-rest/telemetry/configuration')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6F83B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6F8400>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2259 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/telemetry/test_fetch.py::test_fetch_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_fetch_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_fetch.py",
        "telemetry",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/telemetry/test_fetch.py::test_fetch_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_fetch_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_fetch.py",
        "telemetry",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\telemetry\\test_fetch.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\telemetry.py",
            "lineno": 47,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Fetch(url='http://localhost/engine-rest/telemetry/configuration')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6F8D60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6F90D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200243911184'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_fetch_raises_for_status(mock, engine_url):\n        enable_telemetry = pycamunda.telemetry.Fetch(url=engine_url)\n>       enable_telemetry()\n\ntests\\telemetry\\test_fetch.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\telemetry.py:47: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Fetch(url='http://localhost/engine-rest/telemetry/configuration')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6F8D60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6F90D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/telemetry/test_fetch.py::test_fetch_returns_bool",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_fetch_returns_bool",
        "__wrapped__",
        "patchings",
        "test_fetch.py",
        "telemetry",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\telemetry\\test_fetch.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\telemetry.py",
            "lineno": 47,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Fetch(url='http://localhost/engine-rest/telemetry/configuration')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19EB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6F93A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6F92B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', fetch_response_mock)\n    def test_fetch_returns_bool(engine_url):\n        fetch_telemetry = pycamunda.telemetry.Fetch(url=engine_url)\n>       enable_telemetry = fetch_telemetry()\n\ntests\\telemetry\\test_fetch.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\telemetry.py:47: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Fetch(url='http://localhost/engine-rest/telemetry/configuration')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19EB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6F93A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6F92B0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2261 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/telemetry/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "telemetry",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_count.py::test_count_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_count_params",
        "test_count.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_count.py::test_count_calls_requests",
      "lineno": 19,
      "outcome": "failed",
      "keywords": [
        "test_count_calls_requests",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_count.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 275,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/tenant/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6FB470>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6FB330>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200243604688'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_count_calls_requests(mock, engine_url):\n        count_tenants = pycamunda.tenant.Count(url=engine_url)\n>       count_tenants()\n\ntests\\tenant\\test_count.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:275: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/tenant/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6FB470>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6FB330>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_count.py::test_count_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_count_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_count.py::test_count_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_count_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_count.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 275,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/tenant/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6DE250>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6DE070>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200244596368'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.tenant.Tenant', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_count_raises_for_status(mock, engine_url):\n        count_tenants = pycamunda.tenant.Count(url=engine_url)\n>       count_tenants()\n\ntests\\tenant\\test_count.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:275: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/tenant/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A9F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6DE250>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6DE070>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_count.py::test_count_returns_integer",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_count_returns_integer",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_count.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 275,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/tenant/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18A70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6DF100>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6DEC00>\nquery_string = 'id=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', count_response_mock)\n    def test_count_returns_integer(engine_url):\n        count_tenants = pycamunda.tenant.Count(url=engine_url, id_='anId')\n>       tenants = count_tenants()\n\ntests\\tenant\\test_count.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:275: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/tenant/count', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18A70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6DF100>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6DEC00>\nquery_string = 'id=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2217 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_create.py::test_create_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_create_params",
        "test_create.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_create.py::test_create_calls_requests",
      "lineno": 19,
      "outcome": "failed",
      "keywords": [
        "test_create_calls_requests",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_create.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 318,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/tenant/create', id_='aTenant', name='a tenant')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6FB8D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6FA1B0>\nbody = '{\"id\": \"aTenant\", \"name\": \"a tenant\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200244581632'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_create_calls_requests(mock, engine_url):\n        create_tenant = pycamunda.tenant.Create(url=engine_url, id_='aTenant', name='a tenant')\n>       create_tenant()\n\ntests\\tenant\\test_create.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:318: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/tenant/create', id_='aTenant', name='a tenant')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B9B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6FB8D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6FA1B0>\nbody = '{\"id\": \"aTenant\", \"name\": \"a tenant\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2227 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_create.py::test_create_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_create_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_create.py::test_create_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_create_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_create.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 318,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/tenant/create', id_='aTenant', name='a tenant')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D694D10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D694DB0>\nbody = '{\"id\": \"aTenant\", \"name\": \"a tenant\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200243912048'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_create_raises_for_status(mock, engine_url):\n        create_tenant = pycamunda.tenant.Create(url=engine_url, id_='aTenant', name='a tenant')\n>       create_tenant()\n\ntests\\tenant\\test_create.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:318: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/tenant/create', id_='aTenant', name='a tenant')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D694D10>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D694DB0>\nbody = '{\"id\": \"aTenant\", \"name\": \"a tenant\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_create.py::test_create_returns_none",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_create_returns_none",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_create.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 318,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/tenant/create', id_='aTenant', name='a tenant')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D695E90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6958F0>\nbody = '{\"id\": \"aTenant\", \"name\": \"a tenant\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_create_returns_none(engine_url):\n        create_tenant = pycamunda.tenant.Create(url=engine_url, id_='aTenant', name='a tenant')\n>       result = create_tenant()\n\ntests\\tenant\\test_create.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:318: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/tenant/create', id_='aTenant', name='a tenant')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D695E90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6958F0>\nbody = '{\"id\": \"aTenant\", \"name\": \"a tenant\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_delete.py::test_delete_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_delete_params",
        "test_delete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_delete.py::test_delete_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_delete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2637 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_delete.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 385,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/tenant/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D697150>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6963E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2637 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200244010400'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_delete_calls_requests(mock, engine_url):\n        delete_tenant = pycamunda.tenant.Delete(url=engine_url, id_='anId')\n>       delete_tenant()\n\ntests\\tenant\\test_delete.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:385: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/tenant/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D697150>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6963E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2637 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_delete.py::test_delete_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_delete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_delete.py::test_delete_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_delete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_delete.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 385,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/tenant/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E470>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D64C5E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D64C360>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200244353216'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_delete_raises_for_status(mock, engine_url):\n        delete_tenant = pycamunda.tenant.Delete(url=engine_url, id_='anId')\n>       delete_tenant()\n\ntests\\tenant\\test_delete.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:385: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/tenant/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E470>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D64C5E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D64C360>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_delete.py::test_delete_returns_none",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_delete_returns_none",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2685 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_delete.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 385,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/tenant/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C2B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D64C9F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D64C810>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2685 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_delete_returns_none(engine_url):\n        delete_tenant = pycamunda.tenant.Delete(url=engine_url, id_='anId')\n>       result = delete_tenant()\n\ntests\\tenant\\test_delete.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:385: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/tenant/anId', id_='anId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C2B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D64C9F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D64C810>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2685 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_get.py::test_get_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_get.py::test_get_calls_requests",
      "lineno": 19,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_get.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 295,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/tenant/aTenant', id_='aTenant')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DFF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D64DD50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D64DF30>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200244022256'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n        get_tenant = pycamunda.tenant.Get(url=engine_url, id_='aTenant')\n>       get_tenant()\n\ntests\\tenant\\test_get.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:295: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/tenant/aTenant', id_='aTenant')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DFF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D64DD50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D64DF30>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_get.py::test_get_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2392 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_get.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 295,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/tenant/aTenant', id_='aTenant')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D64F060>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D64E070>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2392 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200244022832'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.tenant.Tenant', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_tenant = pycamunda.tenant.Get(url=engine_url, id_='aTenant')\n>       get_tenant()\n\ntests\\tenant\\test_get.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:295: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/tenant/aTenant', id_='aTenant')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C4F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D64F060>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D64E070>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2392 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_get.py::test_get_returns_tenant",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_tenant",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_get.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 295,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/tenant/aTenant', id_='aTenant')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE171B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D64F2E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D64F380>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_get_returns_tenant(engine_url):\n        get_tenant = pycamunda.tenant.Get(url=engine_url, id_='aTenant')\n>       tenant = get_tenant()\n\ntests\\tenant\\test_get.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:295: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/tenant/aTenant', id_='aTenant')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE171B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D64F2E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D64F380>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2225 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_getlist.py::test_getlist_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_getlist.py::test_getlist_calls_requests",
      "lineno": 19,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_getlist.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 227,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/tenant')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DB70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6E88B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6E8900>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200235417920'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_tenants = pycamunda.tenant.GetList(url=engine_url)\n>       get_tenants()\n\ntests\\tenant\\test_getlist.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:227: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/tenant')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DB70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6E88B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6E8900>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 35,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_getlist.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 227,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/tenant')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6E9CB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6E9E90>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200243909504'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.tenant.Tenant', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_tenants = pycamunda.tenant.GetList(url=engine_url)\n>       get_tenants()\n\ntests\\tenant\\test_getlist.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:227: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/tenant')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6E9CB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6E9E90>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2239 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_getlist.py::test_getlist_returns_tenants",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_tenants",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_getlist.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 227,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/tenant', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6EA890>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6EAE30>\nquery_string = 'id=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getlist_returns_tenants(engine_url):\n        get_tenants = pycamunda.tenant.GetList(url=engine_url, id_='anId')\n>       tenants = get_tenants()\n\ntests\\tenant\\test_getlist.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:227: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/tenant', id_='anId')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6EA890>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D6EAE30>\nquery_string = 'id=anId'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmembercreate.py::test_groupmembercreate_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_groupmembercreate_params",
        "test_groupmembercreate.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmembercreate.py::test_groupmembercreate_calls_requests",
      "lineno": 21,
      "outcome": "failed",
      "keywords": [
        "test_groupmembercreate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_groupmembercreate.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_groupmembercreate.py",
            "lineno": 27,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 118,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GroupMemberCreate(url='http://localhost/engine-rest/tenant/anId/group-members/anotherId', id_='anId', group_id='anotherId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6EBCE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D65CEF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200243797552'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_groupmembercreate_calls_requests(mock, engine_url):\n        add_member = pycamunda.tenant.GroupMemberCreate(\n            url=engine_url, id_='anId', group_id='anotherId'\n        )\n>       add_member()\n\ntests\\tenant\\test_groupmembercreate.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:118: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GroupMemberCreate(url='http://localhost/engine-rest/tenant/anId/group-members/anotherId', id_='anId', group_id='anotherId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E6B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D6EBCE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D65CEF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmembercreate.py::test_groupmembercreate_raises_pycamunda_exception",
      "lineno": 32,
      "outcome": "passed",
      "keywords": [
        "test_groupmembercreate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_groupmembercreate.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmembercreate.py::test_groupmembercreate_raises_for_status",
      "lineno": 42,
      "outcome": "failed",
      "keywords": [
        "test_groupmembercreate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_groupmembercreate.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_groupmembercreate.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 118,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GroupMemberCreate(url='http://localhost/engine-rest/tenant/anId/group-members/anotherId', id_='anId', group_id='anotherId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DDB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D65D3F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D65C450>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200243805616'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_groupmembercreate_raises_for_status(mock, engine_url):\n        add_member = pycamunda.tenant.GroupMemberCreate(\n            url=engine_url, id_='anId', group_id='anotherId'\n        )\n>       add_member()\n\ntests\\tenant\\test_groupmembercreate.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:118: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GroupMemberCreate(url='http://localhost/engine-rest/tenant/anId/group-members/anotherId', id_='anId', group_id='anotherId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DDB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D65D3F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D65C450>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmembercreate.py::test_groupmembercreate_returns_none",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_groupmembercreate_returns_none",
        "__wrapped__",
        "patchings",
        "test_groupmembercreate.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_groupmembercreate.py",
            "lineno": 59,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 118,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GroupMemberCreate(url='http://localhost/engine-rest/tenant/anId/group-members/anotherId', id_='anId', group_id='anotherId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73A570>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D73B3D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_groupmembercreate_returns_none(engine_url):\n        add_member = pycamunda.tenant.GroupMemberCreate(\n            url=engine_url, id_='anId', group_id='anotherId'\n        )\n>       result = add_member()\n\ntests\\tenant\\test_groupmembercreate.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:118: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GroupMemberCreate(url='http://localhost/engine-rest/tenant/anId/group-members/anotherId', id_='anId', group_id='anotherId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D73A570>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D73B3D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2231 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmemberdelete.py::test_groupmemberdelete_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_groupmemberdelete_params",
        "test_groupmemberdelete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmemberdelete.py::test_groupmemberdelete_calls_requests",
      "lineno": 21,
      "outcome": "failed",
      "keywords": [
        "test_groupmemberdelete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_groupmemberdelete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_groupmemberdelete.py",
            "lineno": 27,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 139,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GroupMemberDelete(url='http://localhost/engine-rest/tenant/anId/group-members/anotherId', id_='anId', group_id='anotherId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D732340>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D732110>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200243700880'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_groupmemberdelete_calls_requests(mock, engine_url):\n        delete_member = pycamunda.tenant.GroupMemberDelete(\n            url=engine_url, id_='anId', group_id='anotherId'\n        )\n>       delete_member()\n\ntests\\tenant\\test_groupmemberdelete.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:139: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GroupMemberDelete(url='http://localhost/engine-rest/tenant/anId/group-members/anotherId', id_='anId', group_id='anotherId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D732340>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D732110>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2230 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmemberdelete.py::test_groupmemberdelete_raises_pycamunda_exception",
      "lineno": 32,
      "outcome": "passed",
      "keywords": [
        "test_groupmemberdelete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_groupmemberdelete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmemberdelete.py::test_groupmemberdelete_raises_for_status",
      "lineno": 42,
      "outcome": "failed",
      "keywords": [
        "test_groupmemberdelete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_groupmemberdelete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_groupmemberdelete.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 139,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GroupMemberDelete(url='http://localhost/engine-rest/tenant/anId/group-members/anotherId', id_='anId', group_id='anotherId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D65E6B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D65CEF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200239419664'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_groupmemberdelete_raises_for_status(mock, engine_url):\n        delete_member = pycamunda.tenant.GroupMemberDelete(\n            url=engine_url, id_='anId', group_id='anotherId'\n        )\n>       delete_member()\n\ntests\\tenant\\test_groupmemberdelete.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:139: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GroupMemberDelete(url='http://localhost/engine-rest/tenant/anId/group-members/anotherId', id_='anId', group_id='anotherId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D65E6B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D65CEF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmemberdelete.py::test_groupmemberdelete_returns_none",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_groupmemberdelete_returns_none",
        "__wrapped__",
        "patchings",
        "test_groupmemberdelete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_groupmemberdelete.py",
            "lineno": 59,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 139,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GroupMemberDelete(url='http://localhost/engine-rest/tenant/anId/group-members/anotherId', id_='anId', group_id='anotherId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18EF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D65F010>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D65EA20>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_groupmemberdelete_returns_none(engine_url):\n        delete_member = pycamunda.tenant.GroupMemberDelete(\n            url=engine_url, id_='anId', group_id='anotherId'\n        )\n>       result = delete_member()\n\ntests\\tenant\\test_groupmemberdelete.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:139: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GroupMemberDelete(url='http://localhost/engine-rest/tenant/anId/group-members/anotherId', id_='anId', group_id='anotherId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18EF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D65F010>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D65EA20>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmemberoptions.py::test_groupmemberoptions_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_groupmemberoptions_params",
        "test_groupmemberoptions.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmemberoptions.py::test_groupmemberoptions_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_groupmemberoptions_calls_requests",
        "__wrapped__",
        "patchings",
        "test_groupmemberoptions.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_groupmemberoptions.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 158,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GroupMemberOptions(url='http://localhost/engine-rest/tenant/anId/group-members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D930>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7745E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7746D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200243797888'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_groupmemberoptions_calls_requests(mock, engine_url):\n        get_options = pycamunda.tenant.GroupMemberOptions(url=engine_url, id_='anId')\n>       get_options()\n\ntests\\tenant\\test_groupmemberoptions.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:158: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GroupMemberOptions(url='http://localhost/engine-rest/tenant/anId/group-members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D930>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7745E0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7746D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2223 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmemberoptions.py::test_groupmemberoptions_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_groupmemberoptions_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_groupmemberoptions.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmemberoptions.py::test_groupmemberoptions_raises_for_status",
      "lineno": 37,
      "outcome": "failed",
      "keywords": [
        "test_groupmemberoptions_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_groupmemberoptions.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_groupmemberoptions.py",
            "lineno": 43,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 158,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GroupMemberOptions(url='http://localhost/engine-rest/tenant/anId/group-members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D775300>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7750D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200239431280'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.resource.ResourceOptions', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_groupmemberoptions_raises_for_status(mock, engine_url):\n        get_options = pycamunda.tenant.GroupMemberOptions(url=engine_url, id_='anId')\n>       get_options()\n\ntests\\tenant\\test_groupmemberoptions.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:158: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GroupMemberOptions(url='http://localhost/engine-rest/tenant/anId/group-members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D775300>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7750D0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_groupmemberoptions.py::test_groupmemberoptions_returns_resource_options",
      "lineno": 47,
      "outcome": "failed",
      "keywords": [
        "test_groupmemberoptions_returns_resource_options",
        "__wrapped__",
        "patchings",
        "test_groupmemberoptions.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2246 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_groupmemberoptions.py",
            "lineno": 51,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 158,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GroupMemberOptions(url='http://localhost/engine-rest/tenant/anId/group-members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7753A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D775710>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2246 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\nupdate_input = {'id_': 'anId', 'new_id': 'anotherId', 'new_name': 'aName'}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_groupmemberoptions_returns_resource_options(engine_url, update_input):\n        get_options = pycamunda.tenant.GroupMemberOptions(url=engine_url, id_='anId')\n>       resource_options = get_options()\n\ntests\\tenant\\test_groupmemberoptions.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:158: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GroupMemberOptions(url='http://localhost/engine-rest/tenant/anId/group-members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7753A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D775710>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2246 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_options.py::test_options_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_options_params",
        "test_options.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_options.py::test_options_calls_requests",
      "lineno": 24,
      "outcome": "failed",
      "keywords": [
        "test_options_calls_requests",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_options.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 365,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/tenant/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D030>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7775B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D777650>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200243697328'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_options_calls_requests(mock, engine_url):\n        get_options = pycamunda.tenant.Options(url=engine_url, id_='anId')\n>       get_options()\n\ntests\\tenant\\test_options.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:365: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/tenant/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D030>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7775B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D777650>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2221 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_options.py::test_options_raises_pycamunda_exception",
      "lineno": 33,
      "outcome": "passed",
      "keywords": [
        "test_options_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_options.py::test_options_raises_for_status",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_options_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_options.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 365,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/tenant/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7BC1D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7BC9A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200243912528'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.resource.ResourceOptions', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_options_raises_for_status(mock, engine_url):\n        get_options = pycamunda.tenant.Options(url=engine_url, id_='anId')\n>       get_options()\n\ntests\\tenant\\test_options.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:365: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/tenant/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B530>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7BC1D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7BC9A0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_options.py::test_options_returns_resource_options",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_options_returns_resource_options",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_options.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 365,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/tenant/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7BCD60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7BC9F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_options_returns_resource_options(engine_url):\n        get_options = pycamunda.tenant.Options(url=engine_url, id_='anId')\n>       resource_options = get_options()\n\ntests\\tenant\\test_options.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:365: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/tenant/anId', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7BCD60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7BC9F0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2224 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_tenant.py::test_tenant_load",
      "lineno": 9,
      "outcome": "passed",
      "keywords": [
        "test_tenant_load",
        "test_tenant.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_tenant.py::test_tenant_load_raises_key_error",
      "lineno": 17,
      "outcome": "passed",
      "keywords": [
        "test_tenant_load_raises_key_error",
        "test_tenant.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_update.py::test_update_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_update_params",
        "test_update.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_update.py::test_update_calls_requests",
      "lineno": 19,
      "outcome": "failed",
      "keywords": [
        "test_update_calls_requests",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2555 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_update.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 342,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/tenant/anId', id_='anId', new_id='anotherId', new_name='aName')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E230>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7BE980>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7BE9D0>\nbody = '{\"id\": \"anotherId\", \"name\": \"aName\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2555 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200243797216'>\nengine_url = 'http://localhost/engine-rest'\nupdate_input = {'id_': 'anId', 'new_id': 'anotherId', 'new_name': 'aName'}\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_update_calls_requests(mock, engine_url, update_input):\n        update = pycamunda.tenant.Update(url=engine_url, **update_input)\n>       update()\n\ntests\\tenant\\test_update.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:342: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/tenant/anId', id_='anId', new_id='anotherId', new_name='aName')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E230>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7BE980>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7BE9D0>\nbody = '{\"id\": \"anotherId\", \"name\": \"aName\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2555 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_update.py::test_update_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_update_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_update.py::test_update_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_update_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2437 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_update.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 342,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/tenant/anId', id_='anId', new_id='anotherId', new_name='aName')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7BFE20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7BFD30>\nbody = '{\"id\": \"anotherId\", \"name\": \"aName\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2437 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200244357584'>\nengine_url = 'http://localhost/engine-rest'\nupdate_input = {'id_': 'anId', 'new_id': 'anotherId', 'new_name': 'aName'}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_update_raises_for_status(mock, engine_url, update_input):\n        update = pycamunda.tenant.Update(url=engine_url, **update_input)\n>       update()\n\ntests\\tenant\\test_update.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:342: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/tenant/anId', id_='anId', new_id='anotherId', new_name='aName')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7BFE20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7BFD30>\nbody = '{\"id\": \"anotherId\", \"name\": \"aName\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2437 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_update.py::test_update_returns_none",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_update_returns_none",
        "__wrapped__",
        "patchings",
        "test_update.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2491 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_update.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 342,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Update(url='http://localhost/engine-rest/tenant/anId', id_='anId', new_id='anotherId', new_name='aName')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DB70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D744810>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D744270>\nbody = '{\"id\": \"anotherId\", \"name\": \"aName\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2491 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\nupdate_input = {'id_': 'anId', 'new_id': 'anotherId', 'new_name': 'aName'}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_update_returns_none(engine_url, update_input):\n        update = pycamunda.tenant.Update(url=engine_url, **update_input)\n>       result = update()\n\ntests\\tenant\\test_update.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:342: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Update(url='http://localhost/engine-rest/tenant/anId', id_='anId', new_id='anotherId', new_name='aName')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DB70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D744810>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D744270>\nbody = '{\"id\": \"anotherId\", \"name\": \"aName\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2491 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermembercreate.py::test_usermembercreate_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_usermembercreate_params",
        "test_usermembercreate.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermembercreate.py::test_usermembercreate_calls_requests",
      "lineno": 19,
      "outcome": "failed",
      "keywords": [
        "test_usermembercreate_calls_requests",
        "__wrapped__",
        "patchings",
        "test_usermembercreate.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2471 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_usermembercreate.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 55,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UserMemberCreate(url='http://localhost/engine-rest/tenant/anId/user-members/anotherId', id_='anId', user_id='anotherId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D4B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D745F80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D745BC0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2471 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200244021392'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_usermembercreate_calls_requests(mock, engine_url):\n        add_member = pycamunda.tenant.UserMemberCreate(url=engine_url, id_='anId', user_id='anotherId')\n>       add_member()\n\ntests\\tenant\\test_usermembercreate.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:55: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UserMemberCreate(url='http://localhost/engine-rest/tenant/anId/user-members/anotherId', id_='anId', user_id='anotherId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D4B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D745F80>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D745BC0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2471 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermembercreate.py::test_usermembercreate_raises_pycamunda_exception",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_usermembercreate_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_usermembercreate.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermembercreate.py::test_usermembercreate_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_usermembercreate_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_usermembercreate.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2477 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_usermembercreate.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 55,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UserMemberCreate(url='http://localhost/engine-rest/tenant/anId/user-members/anotherId', id_='anId', user_id='anotherId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D746B60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7468E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2477 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200244362288'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_usermembercreate_raises_for_status(mock, engine_url):\n        add_member = pycamunda.tenant.UserMemberCreate(url=engine_url, id_='anId', user_id='anotherId')\n>       add_member()\n\ntests\\tenant\\test_usermembercreate.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:55: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UserMemberCreate(url='http://localhost/engine-rest/tenant/anId/user-members/anotherId', id_='anId', user_id='anotherId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D746B60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7468E0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2477 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermembercreate.py::test_usermembercreate_returns_none",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_usermembercreate_returns_none",
        "__wrapped__",
        "patchings",
        "test_usermembercreate.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2470 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_usermembercreate.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 55,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UserMemberCreate(url='http://localhost/engine-rest/tenant/anId/user-members/anotherId', id_='anId', user_id='anotherId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17870>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D747A60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D747560>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2470 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_usermembercreate_returns_none(engine_url):\n        add_member = pycamunda.tenant.UserMemberCreate(url=engine_url, id_='anId', user_id='anotherId')\n>       result = add_member()\n\ntests\\tenant\\test_usermembercreate.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:55: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UserMemberCreate(url='http://localhost/engine-rest/tenant/anId/user-members/anotherId', id_='anId', user_id='anotherId')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17870>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D747A60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D747560>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2470 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermemberdelete.py::test_usermemberdelete_params",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_usermemberdelete_params",
        "test_usermemberdelete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermemberdelete.py::test_usermemberdelete_calls_requests",
      "lineno": 21,
      "outcome": "failed",
      "keywords": [
        "test_usermemberdelete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_usermemberdelete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2436 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_usermemberdelete.py",
            "lineno": 27,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 76,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UserMemberDelete(url='http://localhost/engine-rest/tenant/anId/user-members/anotherId', id_='anId', user_id='anotherId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D828C20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D828C70>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2436 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200243915552'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_usermemberdelete_calls_requests(mock, engine_url):\n        delete_member = pycamunda.tenant.UserMemberDelete(\n            url=engine_url, id_='anId', user_id='anotherId'\n        )\n>       delete_member()\n\ntests\\tenant\\test_usermemberdelete.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:76: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UserMemberDelete(url='http://localhost/engine-rest/tenant/anId/user-members/anotherId', id_='anId', user_id='anotherId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D828C20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D828C70>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2436 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermemberdelete.py::test_usermemberdelete_raises_pycamunda_exception",
      "lineno": 32,
      "outcome": "passed",
      "keywords": [
        "test_usermemberdelete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_usermemberdelete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermemberdelete.py::test_usermemberdelete_raises_for_status",
      "lineno": 42,
      "outcome": "failed",
      "keywords": [
        "test_usermemberdelete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_usermemberdelete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2504 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_usermemberdelete.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 76,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UserMemberDelete(url='http://localhost/engine-rest/tenant/anId/user-members/anotherId', id_='anId', user_id='anotherId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18EF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D82A070>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D829080>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2504 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200241481632'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_usermemberdelete_raises_for_status(mock, engine_url):\n        delete_member = pycamunda.tenant.UserMemberDelete(\n            url=engine_url, id_='anId', user_id='anotherId'\n        )\n>       delete_member()\n\ntests\\tenant\\test_usermemberdelete.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:76: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UserMemberDelete(url='http://localhost/engine-rest/tenant/anId/user-members/anotherId', id_='anId', user_id='anotherId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18EF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D82A070>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D829080>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2504 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermemberdelete.py::test_usermemberdelete_returns_none",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_usermemberdelete_returns_none",
        "__wrapped__",
        "patchings",
        "test_usermemberdelete.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2416 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_usermemberdelete.py",
            "lineno": 59,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 76,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UserMemberDelete(url='http://localhost/engine-rest/tenant/anId/user-members/anotherId', id_='anId', user_id='anotherId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17F30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D82AF20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D82AA20>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2416 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_usermemberdelete_returns_none(engine_url):\n        delete_member = pycamunda.tenant.UserMemberDelete(\n            url=engine_url, id_='anId', user_id='anotherId'\n        )\n>       result = delete_member()\n\ntests\\tenant\\test_usermemberdelete.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:76: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UserMemberDelete(url='http://localhost/engine-rest/tenant/anId/user-members/anotherId', id_='anId', user_id='anotherId')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17F30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D82AF20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D82AA20>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2416 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermemberoptions.py::test_usermemberoptions_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_usermemberoptions_params",
        "test_usermemberoptions.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermemberoptions.py::test_usermemberoptions_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_usermemberoptions_calls_requests",
        "__wrapped__",
        "patchings",
        "test_usermemberoptions.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2378 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_usermemberoptions.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 95,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UserMemberOptions(url='http://localhost/engine-rest/tenant/anId/user-members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D82A200>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D82B920>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2378 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200239420096'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_usermemberoptions_calls_requests(mock, engine_url):\n        get_options = pycamunda.tenant.UserMemberOptions(url=engine_url, id_='anId')\n>       get_options()\n\ntests\\tenant\\test_usermemberoptions.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:95: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UserMemberOptions(url='http://localhost/engine-rest/tenant/anId/user-members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D82A200>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D82B920>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2378 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermemberoptions.py::test_usermemberoptions_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_usermemberoptions_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_usermemberoptions.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermemberoptions.py::test_usermemberoptions_raises_for_status",
      "lineno": 37,
      "outcome": "failed",
      "keywords": [
        "test_usermemberoptions_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_usermemberoptions.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2474 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_usermemberoptions.py",
            "lineno": 43,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 95,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UserMemberOptions(url='http://localhost/engine-rest/tenant/anId/user-members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D794EA0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D794C70>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2474 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200244441328'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.resource.ResourceOptions', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_usermemberoptions_raises_for_status(mock, engine_url):\n        get_options = pycamunda.tenant.UserMemberOptions(url=engine_url, id_='anId')\n>       get_options()\n\ntests\\tenant\\test_usermemberoptions.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:95: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UserMemberOptions(url='http://localhost/engine-rest/tenant/anId/user-members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE173F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D794EA0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D794C70>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2474 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/tenant/test_usermemberoptions.py::test_usermemberoptions_returns_resource_options",
      "lineno": 47,
      "outcome": "failed",
      "keywords": [
        "test_usermemberoptions_returns_resource_options",
        "__wrapped__",
        "patchings",
        "test_usermemberoptions.py",
        "tenant",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2372 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\tenant\\test_usermemberoptions.py",
            "lineno": 51,
            "message": ""
          },
          {
            "path": "pycamunda\\tenant.py",
            "lineno": 95,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UserMemberOptions(url='http://localhost/engine-rest/tenant/anId/user-members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D795850>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D795FD0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2372 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\nupdate_input = {'id_': 'anId', 'new_id': 'anotherId', 'new_name': 'aName'}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_usermemberoptions_returns_resource_options(engine_url, update_input):\n        get_options = pycamunda.tenant.UserMemberOptions(url=engine_url, id_='anId')\n>       resource_options = get_options()\n\ntests\\tenant\\test_usermemberoptions.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\tenant.py:95: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UserMemberOptions(url='http://localhost/engine-rest/tenant/anId/user-members', id_='anId')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AC30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D795850>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D795FD0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2372 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_count.py::test_count_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_count_params",
        "test_count.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_count.py::test_count_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_count_calls_requests",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2501 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_count.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 121,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/user/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A0F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D794FE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D796E30>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2501 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200245696992'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_count_calls_requests(mock, engine_url):\n        count_users = pycamunda.user.Count(url=engine_url)\n>       count_users()\n\ntests\\user\\test_count.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:121: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/user/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A0F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D794FE0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D796E30>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2501 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_count.py::test_count_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_count_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_count.py::test_count_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_count_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_count.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 121,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/user/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7D1B20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7D2E80>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200244443488'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_count_raises_for_status(mock, engine_url):\n        count_users = pycamunda.user.Count(url=engine_url)\n>       count_users()\n\ntests\\user\\test_count.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:121: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/user/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7D1B20>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7D2E80>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_count.py::test_count_returns_int",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_count_returns_int",
        "__wrapped__",
        "patchings",
        "test_count.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2421 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_count.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 121,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Count(url='http://localhost/engine-rest/user/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7D2A70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7D2AC0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2421 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', count_response_mock)\n    def test_count_returns_int(engine_url):\n        count_users = pycamunda.user.Count(url=engine_url)\n>       count = count_users()\n\ntests\\user\\test_count.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:121: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Count(url='http://localhost/engine-rest/user/count')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7D2A70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7D2AC0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2421 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_create.py::test_create_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_create_params",
        "test_create.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_create.py::test_create_calls_requests",
      "lineno": 30,
      "outcome": "failed",
      "keywords": [
        "test_create_calls_requests",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2226 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_create.py",
            "lineno": 34,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 293,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/user/create', id_='janedoe', first_name='Jane', last_name='Doe', email='jane.doe@email.com', password='password')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7D3D30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7D3060>\nbody = '{\"profile\": {\"id\": \"janedoe\", \"firstName\": \"Jane\", \"lastName\": \"Doe\", \"email\": \"jane.doe@email.com\"}, \"credentials\": {\"password\": \"password\"}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2226 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200245704048'>\nengine_url = 'http://localhost/engine-rest'\njane_doe_dict = {'email': 'jane.doe@email.com', 'first_name': 'Jane', 'id_': 'janedoe', 'last_name': 'Doe'}\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_create_calls_requests(mock, engine_url, jane_doe_dict):\n        create_user = pycamunda.user.Create(url=engine_url, **jane_doe_dict, password='password')\n>       create_user()\n\ntests\\user\\test_create.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:293: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/user/create', id_='janedoe', first_name='Jane', last_name='Doe', email='jane.doe@email.com', password='password')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE185F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7D3D30>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7D3060>\nbody = '{\"profile\": {\"id\": \"janedoe\", \"firstName\": \"Jane\", \"lastName\": \"Doe\", \"email\": \"jane.doe@email.com\"}, \"credentials\": {\"password\": \"password\"}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2226 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_create.py::test_create_raises_pycamunda_exception",
      "lineno": 39,
      "outcome": "passed",
      "keywords": [
        "test_create_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_create.py::test_create_raises_for_status",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_create_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2421 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_create.py",
            "lineno": 51,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 293,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/user/create', id_='janedoe', first_name='Jane', last_name='Doe', email='jane.doe@email.com', password='password')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18830>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7A24D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7A0F90>\nbody = '{\"profile\": {\"id\": \"janedoe\", \"firstName\": \"Jane\", \"lastName\": \"Doe\", \"email\": \"jane.doe@email.com\"}, \"credentials\": {\"password\": \"password\"}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2421 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200244355904'>\nengine_url = 'http://localhost/engine-rest'\njane_doe_dict = {'email': 'jane.doe@email.com', 'first_name': 'Jane', 'id_': 'janedoe', 'last_name': 'Doe'}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_create_raises_for_status(mock, engine_url, jane_doe_dict):\n        create_user = pycamunda.user.Create(url=engine_url, **jane_doe_dict, password='password')\n>       create_user()\n\ntests\\user\\test_create.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:293: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/user/create', id_='janedoe', first_name='Jane', last_name='Doe', email='jane.doe@email.com', password='password')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18830>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7A24D0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7A0F90>\nbody = '{\"profile\": {\"id\": \"janedoe\", \"firstName\": \"Jane\", \"lastName\": \"Doe\", \"email\": \"jane.doe@email.com\"}, \"credentials\": {\"password\": \"password\"}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2421 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_create.py::test_create_returns_none",
      "lineno": 55,
      "outcome": "failed",
      "keywords": [
        "test_create_returns_none",
        "__wrapped__",
        "patchings",
        "test_create.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_create.py",
            "lineno": 59,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 293,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Create(url='http://localhost/engine-rest/user/create', id_='janedoe', first_name='Jane', last_name='Doe', email='jane.doe@email.com', password='password')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7A1350>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7A3560>\nbody = '{\"profile\": {\"id\": \"janedoe\", \"firstName\": \"Jane\", \"lastName\": \"Doe\", \"email\": \"jane.doe@email.com\"}, \"credentials\": {\"password\": \"password\"}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\njane_doe_dict = {'email': 'jane.doe@email.com', 'first_name': 'Jane', 'id_': 'janedoe', 'last_name': 'Doe'}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_create_returns_none(engine_url, jane_doe_dict):\n        create_user = pycamunda.user.Create(url=engine_url, **jane_doe_dict, password='password')\n>       result = create_user()\n\ntests\\user\\test_create.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:293: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Create(url='http://localhost/engine-rest/user/create', id_='janedoe', first_name='Jane', last_name='Doe', email='jane.doe@email.com', password='password')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE18CB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7A1350>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7A3560>\nbody = '{\"profile\": {\"id\": \"janedoe\", \"firstName\": \"Jane\", \"lastName\": \"Doe\", \"email\": \"jane.doe@email.com\"}, \"credentials\": {\"password\": \"password\"}}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2238 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_delete.py::test_delete_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_delete_params",
        "test_delete.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_delete.py::test_delete_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_delete_calls_requests",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2508 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_delete.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 67,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/user/myuserid', id_='myuserid')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE16F70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7A26B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7A3420>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2508 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200244591712'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_delete_calls_requests(mock, engine_url):\n        delete_user = pycamunda.user.Delete(url=engine_url, id_='myuserid')\n>       delete_user()\n\ntests\\user\\test_delete.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:67: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/user/myuserid', id_='myuserid')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE16F70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7A26B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7A3420>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2508 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_delete.py::test_delete_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_delete_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_delete.py::test_delete_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_delete_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2472 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_delete.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 67,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/user/myuserid', id_='myuserid')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7A3E70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7A2CA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2472 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200245010832'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_delete_raises_for_status(mock, engine_url):\n        delete_user = pycamunda.user.Delete(url=engine_url, id_='myuserid')\n>       delete_user()\n\ntests\\user\\test_delete.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:67: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/user/myuserid', id_='myuserid')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7A3E70>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D7A2CA0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2472 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_delete.py::test_delete_returns_none",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_delete_returns_none",
        "__wrapped__",
        "patchings",
        "test_delete.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2350 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_delete.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 67,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Delete(url='http://localhost/engine-rest/user/myuserid', id_='myuserid')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E230>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8044F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D804040>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2350 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_delete_returns_none(engine_url):\n        delete_user = pycamunda.user.Delete(url=engine_url, id_='myuserid')\n>       result = delete_user()\n\ntests\\user\\test_delete.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:67: in __call__\n    super().__call__(pycamunda.base.RequestMethod.DELETE, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Delete(url='http://localhost/engine-rest/user/myuserid', id_='myuserid')\nmethod = <RequestMethod.DELETE: 'DELETE'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E230>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8044F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D804040>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2350 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_getlist.py::test_getlist_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_getlist.py::test_getlist_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2359 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_getlist.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 206,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/user')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C2B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D805D00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D805D50>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2359 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200245087696'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_users = pycamunda.user.GetList(url=engine_url)\n>       get_users()\n\ntests\\user\\test_getlist.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:206: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/user')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C2B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D805D00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D805D50>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2359 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2421 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_getlist.py",
            "lineno": 42,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 206,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/user')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AE70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D806D90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D807D30>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2421 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200245012752'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.user.User', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_users = pycamunda.user.GetList(url=engine_url)\n>       get_users()\n\ntests\\user\\test_getlist.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:206: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/user')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AE70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D806D90>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D807D30>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2421 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_getlist.py::test_getlist_returns_users",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_users",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_getlist.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 206,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/user', id_='myuserid')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D807830>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8078D0>\nquery_string = 'id=myuserid'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getlist_returns_users(engine_url):\n        get_users = pycamunda.user.GetList(url=engine_url, id_='myuserid')\n>       users = get_users()\n\ntests\\user\\test_getlist.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:206: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/user', id_='myuserid')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A330>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D807830>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8078D0>\nquery_string = 'id=myuserid'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2250 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_getprofile.py::test_getprofile_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_getprofile_params",
        "test_getprofile.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_getprofile.py::test_getprofile_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_getprofile_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getprofile.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2627 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_getprofile.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 226,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetProfile(url='http://localhost/engine-rest/user/myuserid/profile', id_='myuserid')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8788B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D878900>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2627 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200245703760'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getprofile_calls_requests(mock, engine_url):\n        get_profile = pycamunda.user.GetProfile(url=engine_url, id_='myuserid')\n>       get_profile()\n\ntests\\user\\test_getprofile.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:226: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetProfile(url='http://localhost/engine-rest/user/myuserid/profile', id_='myuserid')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A7B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8788B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D878900>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2627 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_getprofile.py::test_getprofile_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_getprofile_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getprofile.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_getprofile.py::test_getprofile_raises_for_status",
      "lineno": 36,
      "outcome": "failed",
      "keywords": [
        "test_getprofile_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getprofile.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_getprofile.py",
            "lineno": 42,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 226,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetProfile(url='http://localhost/engine-rest/user/myuserid/profile', id_='myuserid')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D879C60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D878D60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200245081312'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.user.User', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getprofile_raises_for_status(mock, engine_url):\n        get_profile = pycamunda.user.GetProfile(url=engine_url, id_='myuserid')\n>       get_profile()\n\ntests\\user\\test_getprofile.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:226: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetProfile(url='http://localhost/engine-rest/user/myuserid/profile', id_='myuserid')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B2F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D879C60>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D878D60>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2254 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_getprofile.py::test_getprofile_returns_user",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_getprofile_returns_user",
        "__wrapped__",
        "patchings",
        "test_getprofile.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2498 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_getprofile.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 226,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetProfile(url='http://localhost/engine-rest/user/myuserid/profile', id_='myuserid')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17630>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D87AC50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D87AC00>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2498 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getprofile_returns_user(engine_url):\n        get_profile = pycamunda.user.GetProfile(url=engine_url, id_='myuserid')\n>       user_profile = get_profile()\n\ntests\\user\\test_getprofile.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:226: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetProfile(url='http://localhost/engine-rest/user/myuserid/profile', id_='myuserid')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17630>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D87AC50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D87AC00>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2498 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_options.py::test_options_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_options_params",
        "test_options.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_options.py::test_options_calls_requests",
      "lineno": 24,
      "outcome": "failed",
      "keywords": [
        "test_options_calls_requests",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_options.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 250,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/user/myuserid', id_='myuserid')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7A3DD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D807E70>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200209372800'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_options_calls_requests(mock, engine_url):\n        get_options = pycamunda.user.Options(url=engine_url, id_='myuserid')\n>       get_options()\n\ntests\\user\\test_options.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:250: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/user/myuserid', id_='myuserid')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1C970>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D7A3DD0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D807E70>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2243 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_options.py::test_options_raises_pycamunda_exception",
      "lineno": 33,
      "outcome": "passed",
      "keywords": [
        "test_options_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_options.py::test_options_raises_for_status",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_options_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2412 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_options.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 250,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/user/myuserid', id_='myuserid')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17870>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8FA0C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8F8B80>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2412 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200246511760'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.resource.ResourceOptions', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_options_raises_for_status(mock, engine_url):\n        get_options = pycamunda.user.Options(url=engine_url, id_='myuserid')\n>       get_options()\n\ntests\\user\\test_options.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:250: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/user/myuserid', id_='myuserid')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE17870>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8FA0C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8F8B80>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2412 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_options.py::test_options_returns_resource_options",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_options_returns_resource_options",
        "__wrapped__",
        "patchings",
        "test_options.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_options.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 250,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Options(url='http://localhost/engine-rest/user/myuserid', id_='myuserid')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8F8DB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8F9080>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_options_returns_resource_options(engine_url):\n        get_options = pycamunda.user.Options(url=engine_url, id_='myuserid')\n>       resource_options = get_options()\n\ntests\\user\\test_options.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:250: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.OPTIONS, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Options(url='http://localhost/engine-rest/user/myuserid', id_='myuserid')\nmethod = <RequestMethod.OPTIONS: 'OPTIONS'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8F8DB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8F9080>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2247 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_unlock.py::test_unlock_user_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_unlock_user_params",
        "test_unlock.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_unlock.py::test_unlock_calls_requests",
      "lineno": 20,
      "outcome": "failed",
      "keywords": [
        "test_unlock_calls_requests",
        "__wrapped__",
        "patchings",
        "test_unlock.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2345 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_unlock.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 378,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Unlock(url='http://localhost/engine-rest/user/myuserid/unlock', id_='myuserid')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8F9670>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8FACF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2345 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200246512432'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_unlock_calls_requests(mock, engine_url):\n        unlock_user = pycamunda.user.Unlock(url=engine_url, id_='myuserid')\n>       unlock_user()\n\ntests\\user\\test_unlock.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:378: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Unlock(url='http://localhost/engine-rest/user/myuserid/unlock', id_='myuserid')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19370>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8F9670>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8FACF0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2345 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_unlock.py::test_unlock_raises_pycamunda_exception",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_unlock_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_unlock.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_unlock.py::test_unlock_raises_for_status",
      "lineno": 37,
      "outcome": "failed",
      "keywords": [
        "test_unlock_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_unlock.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2278 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_unlock.py",
            "lineno": 42,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 378,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Unlock(url='http://localhost/engine-rest/user/myuserid/unlock', id_='myuserid')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E230>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8FB920>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8FB740>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2278 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200246501248'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_unlock_raises_for_status(mock, engine_url):\n        unlock_user = pycamunda.user.Unlock(url=engine_url, id_='myuserid')\n>       unlock_user()\n\ntests\\user\\test_unlock.py:42: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:378: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Unlock(url='http://localhost/engine-rest/user/myuserid/unlock', id_='myuserid')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E230>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8FB920>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8FB740>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2278 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_unlock.py::test_unlock_returns_none",
      "lineno": 46,
      "outcome": "failed",
      "keywords": [
        "test_unlock_returns_none",
        "__wrapped__",
        "patchings",
        "test_unlock.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2246 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_unlock.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 378,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Unlock(url='http://localhost/engine-rest/user/myuserid/unlock', id_='myuserid')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8FB0B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8FBA10>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2246 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_unlock_returns_none(engine_url):\n        unlock_user = pycamunda.user.Unlock(url=engine_url, id_='myuserid')\n>       result = unlock_user()\n\ntests\\user\\test_unlock.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:378: in __call__\n    super().__call__(pycamunda.base.RequestMethod.POST, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Unlock(url='http://localhost/engine-rest/user/myuserid/unlock', id_='myuserid')\nmethod = <RequestMethod.POST: 'POST'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8FB0B0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8FBA10>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2246 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_update_credentials.py::test_update_credentials_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_update_credentials_params",
        "test_update_credentials.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_update_credentials.py::test_update_credentials_calls_requests",
      "lineno": 25,
      "outcome": "failed",
      "keywords": [
        "test_update_credentials_calls_requests",
        "__wrapped__",
        "patchings",
        "test_update_credentials.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2382 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_update_credentials.py",
            "lineno": 31,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 318,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UpdateCredentials(url='http://localhost/engine-rest/user/janedoe/credentials', id_='janedoe', password='password', authenticated_user_password='password')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AE70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D868720>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D869670>\nbody = '{\"password\": \"password\", \"authenticatedUserPassword\": \"password\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2382 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200245083616'>\nengine_url = 'http://localhost/engine-rest'\nupdate_credentials_input = {'authenticated_user_password': 'password', 'id_': 'janedoe', 'password': 'password'}\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_update_credentials_calls_requests(mock, engine_url, update_credentials_input):\n        update_credentials = pycamunda.user.UpdateCredentials(\n            url=engine_url, **update_credentials_input\n        )\n>       update_credentials()\n\ntests\\user\\test_update_credentials.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:318: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UpdateCredentials(url='http://localhost/engine-rest/user/janedoe/credentials', id_='janedoe', password='password', authenticated_user_password='password')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1AE70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D868720>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D869670>\nbody = '{\"password\": \"password\", \"authenticatedUserPassword\": \"password\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2382 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_update_credentials.py::test_update_credentials_raises_pycamunda_exception",
      "lineno": 36,
      "outcome": "passed",
      "keywords": [
        "test_update_credentials_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_update_credentials.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_update_credentials.py::test_update_credentials_raises_for_status",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_update_credentials_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_update_credentials.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_update_credentials.py",
            "lineno": 52,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 318,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UpdateCredentials(url='http://localhost/engine-rest/user/janedoe/credentials', id_='janedoe', password='password', authenticated_user_password='password')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E8F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D869710>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D869F80>\nbody = '{\"password\": \"password\", \"authenticatedUserPassword\": \"password\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200246147664'>\nengine_url = 'http://localhost/engine-rest'\nupdate_credentials_input = {'authenticated_user_password': 'password', 'id_': 'janedoe', 'password': 'password'}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_update_credentials_raises_for_status(mock, engine_url, update_credentials_input):\n        update_credentials = pycamunda.user.UpdateCredentials(\n            url=engine_url, **update_credentials_input\n        )\n>       update_credentials()\n\ntests\\user\\test_update_credentials.py:52: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:318: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UpdateCredentials(url='http://localhost/engine-rest/user/janedoe/credentials', id_='janedoe', password='password', authenticated_user_password='password')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1E8F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D869710>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D869F80>\nbody = '{\"password\": \"password\", \"authenticatedUserPassword\": \"password\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2245 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_update_credentials.py::test_update_credentials_returns_none",
      "lineno": 56,
      "outcome": "failed",
      "keywords": [
        "test_update_credentials_returns_none",
        "__wrapped__",
        "patchings",
        "test_update_credentials.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_update_credentials.py",
            "lineno": 62,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 318,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UpdateCredentials(url='http://localhost/engine-rest/user/janedoe/credentials', id_='janedoe', password='password', authenticated_user_password='password')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D86B1F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D86B010>\nbody = '{\"password\": \"password\", \"authenticatedUserPassword\": \"password\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\nupdate_credentials_input = {'authenticated_user_password': 'password', 'id_': 'janedoe', 'password': 'password'}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_update_credentials_returns_none(engine_url, update_credentials_input):\n        update_credentials = pycamunda.user.UpdateCredentials(\n            url=engine_url, **update_credentials_input\n        )\n>       result = update_credentials()\n\ntests\\user\\test_update_credentials.py:62: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:318: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UpdateCredentials(url='http://localhost/engine-rest/user/janedoe/credentials', id_='janedoe', password='password', authenticated_user_password='password')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1BE30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D86B1F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D86B010>\nbody = '{\"password\": \"password\", \"authenticatedUserPassword\": \"password\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2228 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_update_profile.py::test_update_profile_params",
      "lineno": 12,
      "outcome": "passed",
      "keywords": [
        "test_update_profile_params",
        "test_update_profile.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_update_profile.py::test_update_profile_calls_requests",
      "lineno": 24,
      "outcome": "failed",
      "keywords": [
        "test_update_profile_calls_requests",
        "__wrapped__",
        "patchings",
        "test_update_profile.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_update_profile.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 356,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UpdateProfile(url='http://localhost/engine-rest/user/janedoe/profile', id_='janedoe', first_name='Jane', last_name='Doe', email='jane.doe@email.com')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D91C680>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D91C6D0>\nbody = '{\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"email\": \"jane.doe@email.com\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200242425856'>\nengine_url = 'http://localhost/engine-rest'\njane_doe_dict = {'email': 'jane.doe@email.com', 'first_name': 'Jane', 'id_': 'janedoe', 'last_name': 'Doe'}\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_update_profile_calls_requests(mock, engine_url, jane_doe_dict):\n        update_profile = pycamunda.user.UpdateProfile(url=engine_url, **jane_doe_dict)\n>       update_profile()\n\ntests\\user\\test_update_profile.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:356: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UpdateProfile(url='http://localhost/engine-rest/user/janedoe/profile', id_='janedoe', first_name='Jane', last_name='Doe', email='jane.doe@email.com')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE183B0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D91C680>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D91C6D0>\nbody = '{\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"email\": \"jane.doe@email.com\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2235 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_update_profile.py::test_update_profile_raises_pycamunda_exception",
      "lineno": 33,
      "outcome": "passed",
      "keywords": [
        "test_update_profile_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_update_profile.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_update_profile.py::test_update_profile_raises_for_status",
      "lineno": 41,
      "outcome": "failed",
      "keywords": [
        "test_update_profile_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_update_profile.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_update_profile.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 356,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UpdateProfile(url='http://localhost/engine-rest/user/janedoe/profile', id_='janedoe', first_name='Jane', last_name='Doe', email='jane.doe@email.com')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CBB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D91C770>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D91CDB0>\nbody = '{\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"email\": \"jane.doe@email.com\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200245937456'>\nengine_url = 'http://localhost/engine-rest'\njane_doe_dict = {'email': 'jane.doe@email.com', 'first_name': 'Jane', 'id_': 'janedoe', 'last_name': 'Doe'}\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_update_profile_raises_for_status(mock, engine_url, jane_doe_dict):\n        update_profile = pycamunda.user.UpdateProfile(url=engine_url, **jane_doe_dict)\n>       update_profile()\n\ntests\\user\\test_update_profile.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:356: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UpdateProfile(url='http://localhost/engine-rest/user/janedoe/profile', id_='janedoe', first_name='Jane', last_name='Doe', email='jane.doe@email.com')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1CBB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D91C770>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D91CDB0>\nbody = '{\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"email\": \"jane.doe@email.com\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_update_profile.py::test_update_profile_returns_none",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_update_profile_returns_none",
        "__wrapped__",
        "patchings",
        "test_update_profile.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\user\\test_update_profile.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "pycamunda\\user.py",
            "lineno": 356,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = UpdateProfile(url='http://localhost/engine-rest/user/janedoe/profile', id_='janedoe', first_name='Jane', last_name='Doe', email='jane.doe@email.com')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DFF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D91EC50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D91EC00>\nbody = '{\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"email\": \"jane.doe@email.com\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\njane_doe_dict = {'email': 'jane.doe@email.com', 'first_name': 'Jane', 'id_': 'janedoe', 'last_name': 'Doe'}\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_update_profile_returns_none(engine_url, jane_doe_dict):\n        update_profile = pycamunda.user.UpdateProfile(url=engine_url, **jane_doe_dict)\n>       result = update_profile()\n\ntests\\user\\test_update_profile.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\user.py:356: in __call__\n    super().__call__(pycamunda.base.RequestMethod.PUT, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = UpdateProfile(url='http://localhost/engine-rest/user/janedoe/profile', id_='janedoe', first_name='Jane', last_name='Doe', email='jane.doe@email.com')\nmethod = <RequestMethod.PUT: 'PUT'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1DFF0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D91EC50>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D91EC00>\nbody = '{\"firstName\": \"Jane\", \"lastName\": \"Doe\", \"email\": \"jane.doe@email.com\"}'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2244 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_user.py::test_user_load",
      "lineno": 9,
      "outcome": "passed",
      "keywords": [
        "test_user_load",
        "test_user.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/user/test_user.py::test_user_load_raises_key_error",
      "lineno": 19,
      "outcome": "passed",
      "keywords": [
        "test_user_load_raises_key_error",
        "test_user.py",
        "user",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_get.py::test_get_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2397 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\variable\\test_get.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\variable.py",
            "lineno": 264,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/variable-instance/anId', id_='anId', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D9202C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D920310>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2397 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200245937408'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n        get_variables = pycamunda.variable.Get(url=engine_url, id_='anId')\n>       get_variables()\n\ntests\\variable\\test_get.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\variable.py:264: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/variable-instance/anId', id_='anId', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE197F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D9202C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D920310>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2397 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_get.py::test_get_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2584 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\variable\\test_get.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "pycamunda\\variable.py",
            "lineno": 264,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/variable-instance/anId', id_='anId', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D921DA0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D921D00>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2584 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200245933808'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.variable.VariableInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_variables = pycamunda.variable.Get(url=engine_url, id_='anId')\n>       get_variables()\n\ntests\\variable\\test_get.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\variable.py:264: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/variable-instance/anId', id_='anId', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1A570>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D921DA0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D921D00>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2584 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_get.py::test_get_returns_variableinstance",
      "lineno": 44,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_variableinstance",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\variable\\test_get.py",
            "lineno": 48,
            "message": ""
          },
          {
            "path": "pycamunda\\variable.py",
            "lineno": 264,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/variable-instance/anId', id_='anId', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D922750>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D922110>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_get_returns_variableinstance(engine_url):\n        get_variable = pycamunda.variable.Get(url=engine_url, id_='anId')\n>       variable = get_variable()\n\ntests\\variable\\test_get.py:48: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\variable.py:264: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/variable-instance/anId', id_='anId', deserialize_value=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19130>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D922750>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D922110>\nquery_string = 'deserializeValue=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2234 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_getlist.py::test_getlist_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params",
        "test_getlist.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_getlist.py::test_getlist_params_add_equal_value_filter",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params_add_equal_value_filter",
        "test_getlist.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_getlist.py::test_getlist_params_add_not_equal_value_filter",
      "lineno": 25,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params_add_not_equal_value_filter",
        "test_getlist.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_getlist.py::test_getlist_params_add_greater_than_value_filter",
      "lineno": 32,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params_add_greater_than_value_filter",
        "test_getlist.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_getlist.py::test_getlist_params_add_less_than_value_filter",
      "lineno": 39,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params_add_less_than_value_filter",
        "test_getlist.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_getlist.py::test_getlist_params_add_like_value_filter",
      "lineno": 46,
      "outcome": "passed",
      "keywords": [
        "test_getlist_params_add_like_value_filter",
        "test_getlist.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_getlist.py::test_getlist_calls_requests",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_getlist_calls_requests",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\variable\\test_getlist.py",
            "lineno": 57,
            "message": ""
          },
          {
            "path": "pycamunda\\variable.py",
            "lineno": 240,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/variable-instance', variable_values=[], deserialize_values=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8D8DB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8D8E00>\nquery_string = 'deserializeValues=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200246665328'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_getlist_calls_requests(mock, engine_url):\n        get_variables = pycamunda.variable.GetList(url=engine_url)\n>       get_variables()\n\ntests\\variable\\test_getlist.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\variable.py:240: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/variable-instance', variable_values=[], deserialize_values=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D6F0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8D8DB0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8D8E00>\nquery_string = 'deserializeValues=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2252 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_getlist.py::test_getlist_raises_pycamunda_exception",
      "lineno": 62,
      "outcome": "passed",
      "keywords": [
        "test_getlist_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_getlist.py::test_getlist_raises_for_status",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_getlist_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\variable\\test_getlist.py",
            "lineno": 75,
            "message": ""
          },
          {
            "path": "pycamunda\\variable.py",
            "lineno": 240,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/variable-instance', variable_values=[], deserialize_values=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19EB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8D91C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8DA110>\nquery_string = 'deserializeValues=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200246673584'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.variable.VariableInstance', unittest.mock.MagicMock())\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_getlist_raises_for_status(mock, engine_url):\n        get_variables = pycamunda.variable.GetList(url=engine_url)\n>       get_variables()\n\ntests\\variable\\test_getlist.py:75: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\variable.py:240: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/variable-instance', variable_values=[], deserialize_values=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19EB0>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8D91C0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8DA110>\nquery_string = 'deserializeValues=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2242 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_getlist.py::test_getlist_returns_variableinstances",
      "lineno": 79,
      "outcome": "failed",
      "keywords": [
        "test_getlist_returns_variableinstances",
        "__wrapped__",
        "patchings",
        "test_getlist.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\variable\\test_getlist.py",
            "lineno": 83,
            "message": ""
          },
          {
            "path": "pycamunda\\variable.py",
            "lineno": 240,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = GetList(url='http://localhost/engine-rest/variable-instance', variable_values=[], deserialize_values=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8DA7A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8DA700>\nquery_string = 'deserializeValues=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', unittest.mock.MagicMock())\n    def test_getlist_returns_variableinstances(engine_url):\n        get_variables = pycamunda.variable.GetList(url=engine_url)\n>       variables = get_variables()\n\ntests\\variable\\test_getlist.py:83: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\variable.py:240: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = GetList(url='http://localhost/engine-rest/variable-instance', variable_values=[], deserialize_values=False)\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1B770>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8DA7A0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8DA700>\nquery_string = 'deserializeValues=false'\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2222 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_variable.py::test_variable_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_variable_load",
        "test_variable.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_variable.py::test_variable_load_raises_keyerror",
      "lineno": 18,
      "outcome": "passed",
      "keywords": [
        "test_variable_load_raises_keyerror",
        "test_variable.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_variableinstance.py::test_variableinstance_load",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_variableinstance_load",
        "test_variableinstance.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/variable/test_variableinstance.py::test_variableinstance_load_raises_keyerror",
      "lineno": 25,
      "outcome": "passed",
      "keywords": [
        "test_variableinstance_load_raises_keyerror",
        "test_variableinstance.py",
        "variable",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/version/test_get.py::test_get_params",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_get_params",
        "test_get.py",
        "version",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/version/test_get.py::test_get_calls_requests",
      "lineno": 18,
      "outcome": "failed",
      "keywords": [
        "test_get_calls_requests",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "version",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2780 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\version\\test_get.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "pycamunda\\version.py",
            "lineno": 26,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/version')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8609F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D860A40>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2780 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='request' id='3200245936640'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request')\n    def test_get_calls_requests(mock, engine_url):\n        get_version = pycamunda.version.Get(url=engine_url)\n>       get_version()\n\ntests\\version\\test_get.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\version.py:26: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/version')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19A30>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D8609F0>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D860A40>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2780 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/version/test_get.py::test_get_raises_pycamunda_exception",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_get_raises_pycamunda_exception",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "version",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/version/test_get.py::test_get_raises_for_status",
      "lineno": 34,
      "outcome": "failed",
      "keywords": [
        "test_get_raises_for_status",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "version",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\version\\test_get.py",
            "lineno": 39,
            "message": ""
          },
          {
            "path": "pycamunda\\version.py",
            "lineno": 26,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/version')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D270>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D860E00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8611C0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nmock = <MagicMock name='_raise_for_status' id='3200246615168'>\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', not_ok_response_mock)\n    @unittest.mock.patch('pycamunda.base._raise_for_status')\n    def test_get_raises_for_status(mock, engine_url):\n        get_version = pycamunda.version.Get(url=engine_url)\n>       get_version()\n\ntests\\version\\test_get.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\version.py:26: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/version')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE1D270>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D860E00>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D8611C0>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2237 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/version/test_get.py::test_get_returns_string",
      "lineno": 43,
      "outcome": "failed",
      "keywords": [
        "test_get_returns_string",
        "__wrapped__",
        "patchings",
        "test_get.py",
        "version",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\pklauke@pycamunda__fdab7274__requests__pycurl\\pycamunda\\base.py",
          "lineno": 96,
          "message": "pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')"
        },
        "traceback": [
          {
            "path": "tests\\version\\test_get.py",
            "lineno": 47,
            "message": ""
          },
          {
            "path": "pycamunda\\version.py",
            "lineno": 26,
            "message": "in __call__"
          },
          {
            "path": "pycamunda\\base.py",
            "lineno": 96,
            "message": "PyCamundaException"
          }
        ],
        "longrepr": "self = Get(url='http://localhost/engine-rest/version')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D862930>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D862E80>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n>           curl.perform()\nE           pycurl.error: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:90: error\n\nDuring handling of the above exception, another exception occurred:\n\nengine_url = 'http://localhost/engine-rest'\n\n    @unittest.mock.patch('requests.Session.request', version_response_mock)\n    def test_get_returns_string(engine_url):\n        get_version = pycamunda.version.Get(url=engine_url)\n>       version = get_version()\n\ntests\\version\\test_get.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npycamunda\\version.py:26: in __call__\n    response = super().__call__(pycamunda.base.RequestMethod.GET, *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Get(url='http://localhost/engine-rest/version')\nmethod = <RequestMethod.GET: 'GET'>, args = (), kwargs = {}\ncurl = <pycurl.Curl object at 0x000002E91BE19C70>\nresponse_buffer = <_io.BytesIO object at 0x000002E91D862930>\nheaders_buffer = <_io.BytesIO object at 0x000002E91D862E80>\n\n    def __call__(self, method: RequestMethod, *args, **kwargs) -> typing.Tuple[int, str]:\n        curl = pycurl.Curl()\n        response_buffer = BytesIO()\n        headers_buffer = BytesIO()\n    \n        try:\n            # Set the URL\n            curl.setopt(pycurl.URL, self.url)\n    \n            # Set the HTTP method\n            if method == RequestMethod.POST:\n                curl.setopt(pycurl.POST, 1)\n            elif method == RequestMethod.PUT:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PUT')\n            elif method == RequestMethod.PATCH:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'PATCH')\n            elif method == RequestMethod.DELETE:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'DELETE')\n            elif method == RequestMethod.OPTIONS:\n                curl.setopt(pycurl.CUSTOMREQUEST, 'OPTIONS')\n            elif method == RequestMethod.HEAD:\n                curl.setopt(pycurl.NOBODY, 1)\n            else:  # Default to GET\n                curl.setopt(pycurl.HTTPGET, 1)\n    \n            # Set query parameters\n            if self.query_parameters():\n                query_string = '&'.join(\n                    f'{key}={value}' for key, value in self.query_parameters().items()\n                )\n                curl.setopt(pycurl.URL, f'{self.url}?{query_string}')\n    \n            # Set body parameters\n            if self.body_parameters():\n                body = json.dumps(self.body_parameters())\n                curl.setopt(pycurl.POSTFIELDS, body)\n                curl.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json'])\n    \n            # Set authentication\n            if self.auth:\n                curl.setopt(pycurl.USERPWD, f'{self.auth[0]}:{self.auth[1]}')\n    \n            # Capture response and headers\n            curl.setopt(pycurl.WRITEFUNCTION, response_buffer.write)\n            curl.setopt(pycurl.HEADERFUNCTION, headers_buffer.write)\n    \n            # Perform the request\n            curl.perform()\n    \n            # Get the HTTP status code\n            status_code = curl.getinfo(pycurl.RESPONSE_CODE)\n    \n        except pycurl.error as exc:\n>           raise pycamunda.PyCamundaException(exc)\nE           pycamunda.PyCamundaException: (7, 'Failed to connect to localhost port 80 after 2232 ms: Could not connect to server')\n\npycamunda\\base.py:96: PyCamundaException"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/version/test_module.py::test_all_contains_only_valid_names",
      "lineno": 3,
      "outcome": "passed",
      "keywords": [
        "test_all_contains_only_valid_names",
        "test_module.py",
        "version",
        "tests",
        "pklauke@pycamunda__fdab7274__requests__pycurl",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    }
  ]
}