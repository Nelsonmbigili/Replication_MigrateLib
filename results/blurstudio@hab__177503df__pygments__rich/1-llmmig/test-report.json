{
  "exitcode": 1,
  "summary": {
    "passed": 115,
    "error": 95,
    "failed": 143,
    "skipped": 9,
    "total": 362,
    "collected": 362
  },
  "collectors": [
    {
      "nodeid": "",
      "outcome": "passed",
      "result": [
        {
          "nodeid": ".",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "bin",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "hab/parsers",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "hab/templates",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "hab",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "hab/parsers",
          "type": "Package"
        },
        {
          "nodeid": "hab/templates",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "hab.egg-info",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/configs/app",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/configs/default",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/configs/not_set",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/configs/optional",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/configs/place-holder",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/configs/project_a",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/configs/verbosity",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/configs",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/configs/app",
          "type": "Dir"
        },
        {
          "nodeid": "tests/configs/default",
          "type": "Dir"
        },
        {
          "nodeid": "tests/configs/not_set",
          "type": "Dir"
        },
        {
          "nodeid": "tests/configs/optional",
          "type": "Dir"
        },
        {
          "nodeid": "tests/configs/place-holder",
          "type": "Dir"
        },
        {
          "nodeid": "tests/configs/project_a",
          "type": "Dir"
        },
        {
          "nodeid": "tests/configs/verbosity",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/aliased/2.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/aliased",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/aliased/2.0",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/aliased_mod/1.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/aliased_mod",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/aliased_mod/1.0",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/aliased_verbosity/1.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/aliased_verbosity",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/aliased_verbosity/1.0",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/all_settings/0.1.0.dev1",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/all_settings",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/all_settings/0.1.0.dev1",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/houdini18.5/18.5.351",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/houdini18.5",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/houdini18.5/18.5.351",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/houdini19.5/19.5.493",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/houdini19.5",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/houdini19.5/19.5.493",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/maya2020/2020.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/maya2020/2020.1",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/maya2020",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/maya2020/2020.0",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/maya2020/2020.1",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/maya2024/2024.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/maya2024",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/maya2024/2024.0",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/pre-release/1.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/pre-release/1.0.dev1",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/pre-release/1.1.dev2",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/pre-release",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/pre-release/1.0",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/pre-release/1.0.dev1",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/pre-release/1.1.dev2",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/pre-release2/1.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/pre-release2/1.1.dev2",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/pre-release2",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/pre-release2/1.0",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/pre-release2/1.1.dev2",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/the_dcc/1.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc/1.1",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc/1.2",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc/pre",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/the_dcc/1.0",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc/1.1",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc/1.2",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc/pre",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_a/0.9",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_a/1.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_a/1.1",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_a",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/the_dcc_plugin_a/0.9",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_a/1.0",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_a/1.1",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_b/0.9",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_b/1.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_b/1.1",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_b",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/the_dcc_plugin_b/0.9",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_b/1.0",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_b/1.1",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_c/0.9",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_c/1.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_c/1.1",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_c",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/the_dcc_plugin_c/0.9",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_c/1.0",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_c/1.1",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_d/0.9",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_d/1.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_d/1.1",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_d",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/the_dcc_plugin_d/0.9",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_d/1.0",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_d/1.1",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_e/0.9",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_e/1.0",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_e/1.1",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros/the_dcc_plugin_e",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/the_dcc_plugin_e/0.9",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_e/1.0",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_e/1.1",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros/aliased",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/aliased_mod",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/aliased_verbosity",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/all_settings",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/houdini18.5",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/houdini19.5",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/maya2020",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/maya2024",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/pre-release",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/pre-release2",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_a",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_b",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_c",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_d",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros/the_dcc_plugin_e",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/distros_version/not_scm",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros_version/release",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros_version/txt_file",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/distros_version",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/distros_version/not_scm",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros_version/release",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros_version/txt_file",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/duplicates/configs_child_1",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/duplicates/configs_child_2",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/duplicates/configs_parent_1",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/duplicates/configs_parent_2",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/duplicates/distros_1/the_dcc/1.2",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/duplicates/distros_1/the_dcc",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/duplicates/distros_1/the_dcc/1.2",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/duplicates/distros_1",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/duplicates/distros_1/the_dcc",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/duplicates/distros_2/the_dcc/1.2",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/duplicates/distros_2/the_dcc",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/duplicates/distros_2/the_dcc/1.2",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/duplicates/distros_2/the_dcc_1/1.2",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/duplicates/distros_2/the_dcc_1",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/duplicates/distros_2/the_dcc_1/1.2",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/duplicates/distros_2",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/duplicates/distros_2/the_dcc",
          "type": "Dir"
        },
        {
          "nodeid": "tests/duplicates/distros_2/the_dcc_1",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/duplicates",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/duplicates/configs_child_1",
          "type": "Dir"
        },
        {
          "nodeid": "tests/duplicates/configs_child_2",
          "type": "Dir"
        },
        {
          "nodeid": "tests/duplicates/configs_parent_1",
          "type": "Dir"
        },
        {
          "nodeid": "tests/duplicates/configs_parent_2",
          "type": "Dir"
        },
        {
          "nodeid": "tests/duplicates/distros_1",
          "type": "Dir"
        },
        {
          "nodeid": "tests/duplicates/distros_2",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[uncached-os_agnostic.json-None]",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[uncached-os_agnostic_platforms.json-platforms1]",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[uncached-os_specific.json-None]",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[uncached-os_specific_false.json-None]",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[uncached-os_specific_platforms.json-platforms4]",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[cached-os_agnostic.json-None]",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[cached-os_agnostic_platforms.json-platforms1]",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[cached-os_specific.json-None]",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[cached-os_specific_false.json-None]",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[cached-os_specific_platforms.json-platforms4]",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_path_split",
          "type": "Function",
          "lineno": 47
        },
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_merge[merge_agnostic.json]",
          "type": "Function",
          "lineno": 75
        },
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py::test_merge[merge_specific.json]",
          "type": "Function",
          "lineno": 75
        }
      ]
    },
    {
      "nodeid": "tests/merge_dict",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/merge_dict/test_merge_dict.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/reference_scripts/bat_activate/aliases",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/bat_activate",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/reference_scripts/bat_activate/aliases",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/reference_scripts/bat_activate_launch/aliases",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/bat_activate_launch",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/reference_scripts/bat_activate_launch/aliases",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/reference_scripts/bat_env/aliases",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/bat_env",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/reference_scripts/bat_env/aliases",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/reference_scripts/bat_env_launch/aliases",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/bat_env_launch",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/reference_scripts/bat_env_launch/aliases",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/reference_scripts/bat_launch/aliases",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/bat_launch",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/reference_scripts/bat_launch/aliases",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/reference_scripts/bat_launch_args/aliases",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/bat_launch_args",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/reference_scripts/bat_launch_args/aliases",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/reference_scripts/ps1_activate",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/ps1_activate_launch",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/ps1_env",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/ps1_env_launch",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/ps1_launch",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/ps1_launch_args",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/sh_linux_activate",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/sh_linux_activate_launch",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/sh_linux_env",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/sh_linux_env_launch",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/sh_linux_launch",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/sh_linux_launch_args",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/sh_win_activate",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/sh_win_activate_launch",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/sh_win_env",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/sh_win_env_launch",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/sh_win_launch",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts/sh_win_launch_args",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/reference_scripts",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/reference_scripts/bat_activate",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/bat_activate_launch",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/bat_env",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/bat_env_launch",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/bat_launch",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/bat_launch_args",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/ps1_activate",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/ps1_activate_launch",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/ps1_env",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/ps1_env_launch",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/ps1_launch",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/ps1_launch_args",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/sh_linux_activate",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/sh_linux_activate_launch",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/sh_linux_env",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/sh_linux_env_launch",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/sh_linux_launch",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/sh_linux_launch_args",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/sh_win_activate",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/sh_win_activate_launch",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/sh_win_env",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/sh_win_env_launch",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/sh_win_launch",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts/sh_win_launch_args",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/site/eps",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/site",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/site/eps",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "tests/site_omit/configs",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/site_omit/test_omittable.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/site_omit/test_omittable.py::test_defined",
          "type": "Function",
          "lineno": 13
        },
        {
          "nodeid": "tests/site_omit/test_omittable.py::test_inherited",
          "type": "Function",
          "lineno": 48
        },
        {
          "nodeid": "tests/site_omit/test_omittable.py::test_forced",
          "type": "Function",
          "lineno": 82
        },
        {
          "nodeid": "tests/site_omit/test_omittable.py::test_pure_default",
          "type": "Function",
          "lineno": 123
        },
        {
          "nodeid": "tests/site_omit/test_omittable.py::test_missing_required",
          "type": "Function",
          "lineno": 160
        }
      ]
    },
    {
      "nodeid": "tests/site_omit",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/site_omit/configs",
          "type": "Dir"
        },
        {
          "nodeid": "tests/site_omit/test_omittable.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/test_cache.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_cache.py::test_cached_keys",
          "type": "Function",
          "lineno": 8
        },
        {
          "nodeid": "tests/test_cache.py::test_site_cache_path",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/test_cache.py::test_save_cache",
          "type": "Function",
          "lineno": 44
        },
        {
          "nodeid": "tests/test_cache.py::test_load_cache",
          "type": "Function",
          "lineno": 52
        },
        {
          "nodeid": "tests/test_cache.py::test_unsupported_version_warning",
          "type": "Function",
          "lineno": 67
        },
        {
          "nodeid": "tests/test_cache.py::test_cached_method",
          "type": "Function",
          "lineno": 99
        },
        {
          "nodeid": "tests/test_cache.py::test_resolver_cache[uncached]",
          "type": "Function",
          "lineno": 127
        },
        {
          "nodeid": "tests/test_cache.py::test_resolver_cache[cached]",
          "type": "Function",
          "lineno": 127
        }
      ]
    },
    {
      "nodeid": "tests/test_format_parser.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app--False-app-app]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app--True-\\x1b[32mapp\\x1b[39m-\\x1b[32mapp\\x1b[39m]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app/aliased-  -False-  app/aliased-  app/aliased: \"{filename}\"]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app/aliased-  -True-  app/aliased-  app/aliased: \\x1b[33m\"{filename}\"\\x1b[39m]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app/aliased/mod-  -False-  app/aliased/mod-  app/aliased/mod: \"{filename}\"]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app/aliased/mod-  -True-  app/aliased/mod-  app/aliased/mod: \\x1b[33m\"{filename}\"\\x1b[39m]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/test_format_parser.py::test_format_parser_uri[project_a--False-project_a-project_a: \"{filename}\"]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/test_format_parser.py::test_format_parser_uri[project_a--True-\\x1b[32mproject_a\\x1b[39m-\\x1b[32mproject_a\\x1b[39m: \\x1b[33m\"{filename}\"\\x1b[39m]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app/houdini-  -False-  app/houdini-  app/houdini]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app/houdini-  -True-  app/houdini-  app/houdini]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/test_format_parser.py::test_dump_forest_callable",
          "type": "Function",
          "lineno": 76
        }
      ]
    },
    {
      "nodeid": "tests/test_formatter.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_formatter.py::test_env_format[sh-_V_a-var_:_$INVALID_-_V_$VALID_:_$INVALID_]",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/test_formatter.py::test_env_format[shwin-_V_a-var_:_$INVALID_-_V_$VALID_:_$INVALID_]",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/test_formatter.py::test_env_format[ps-_V_a-var_;_$env:INVALID_-_V_$env:VALID_;_$env:INVALID_]",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/test_formatter.py::test_env_format[batch-_V_a-var_;_%INVALID%_-_V_%VALID%_;_%INVALID%_]",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/test_formatter.py::test_env_format[None-_V_a-var_{;}_{INVALID!e}_-_V_{VALID!e}_{;}_{INVALID!e}_]",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/test_formatter.py::test_language_from_ext",
          "type": "Function",
          "lineno": 43
        },
        {
          "nodeid": "tests/test_formatter.py::test_format_environment_value",
          "type": "Function",
          "lineno": 64
        }
      ]
    },
    {
      "nodeid": "tests/test_freeze.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_freeze.py::test_json_dumps",
          "type": "Function",
          "lineno": 31
        },
        {
          "nodeid": "tests/test_freeze.py::test_freeze[win32-;]",
          "type": "Function",
          "lineno": 45
        },
        {
          "nodeid": "tests/test_freeze.py::test_freeze[linux-:]",
          "type": "Function",
          "lineno": 45
        },
        {
          "nodeid": "tests/test_freeze.py::test_unfreeze[uncached]",
          "type": "Function",
          "lineno": 111
        },
        {
          "nodeid": "tests/test_freeze.py::test_unfreeze[cached]",
          "type": "Function",
          "lineno": 111
        },
        {
          "nodeid": "tests/test_freeze.py::test_decode_freeze",
          "type": "Function",
          "lineno": 164
        },
        {
          "nodeid": "tests/test_freeze.py::test_encode_freeze[uncached]",
          "type": "Function",
          "lineno": 198
        },
        {
          "nodeid": "tests/test_freeze.py::test_encode_freeze[cached]",
          "type": "Function",
          "lineno": 198
        },
        {
          "nodeid": "tests/test_freeze.py::test_resolver_freeze_configs",
          "type": "Function",
          "lineno": 234
        }
      ]
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bat[5]",
          "type": "Function",
          "lineno": 220
        },
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bat[4]",
          "type": "Function",
          "lineno": 220
        },
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bat[0]",
          "type": "Function",
          "lineno": 220
        },
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes::test_ps1[5]",
          "type": "Function",
          "lineno": 239
        },
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes::test_ps1[4]",
          "type": "Function",
          "lineno": 239
        },
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes::test_ps1[0]",
          "type": "Function",
          "lineno": 239
        },
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bash_win[5]",
          "type": "Function",
          "lineno": 265
        },
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bash_win[4]",
          "type": "Function",
          "lineno": 265
        },
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bash_win[0]",
          "type": "Function",
          "lineno": 265
        },
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bash_linux[5]",
          "type": "Function",
          "lineno": 297
        },
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bash_linux[4]",
          "type": "Function",
          "lineno": 297
        },
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bash_linux[0]",
          "type": "Function",
          "lineno": 297
        }
      ]
    },
    {
      "nodeid": "tests/test_launch.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_launch.py::test_launch[uncached]",
          "type": "Function",
          "lineno": 51
        },
        {
          "nodeid": "tests/test_launch.py::test_launch[cached]",
          "type": "Function",
          "lineno": 51
        },
        {
          "nodeid": "tests/test_launch.py::test_launch_str[uncached]",
          "type": "Function",
          "lineno": 74
        },
        {
          "nodeid": "tests/test_launch.py::test_launch_str[cached]",
          "type": "Function",
          "lineno": 74
        },
        {
          "nodeid": "tests/test_launch.py::test_pythonw[uncached]",
          "type": "Function",
          "lineno": 99
        },
        {
          "nodeid": "tests/test_launch.py::test_pythonw[cached]",
          "type": "Function",
          "lineno": 99
        },
        {
          "nodeid": "tests/test_launch.py::test_invalid_alias[uncached]",
          "type": "Function",
          "lineno": 115
        },
        {
          "nodeid": "tests/test_launch.py::test_invalid_alias[cached]",
          "type": "Function",
          "lineno": 115
        },
        {
          "nodeid": "tests/test_launch.py::test_cls_no_entry_point[uncached]",
          "type": "Function",
          "lineno": 131
        },
        {
          "nodeid": "tests/test_launch.py::test_cls_no_entry_point[cached]",
          "type": "Function",
          "lineno": 131
        },
        {
          "nodeid": "tests/test_launch.py::test_cls_entry_point",
          "type": "Function",
          "lineno": 150
        },
        {
          "nodeid": "tests/test_launch.py::test_alias_entry_point",
          "type": "Function",
          "lineno": 175
        },
        {
          "nodeid": "tests/test_launch.py::TestCliExitCodes",
          "type": "Class"
        }
      ]
    },
    {
      "nodeid": "tests/test_parsing.py::TestLoadJsonFile",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_parsing.py::TestLoadJsonFile::test_missing",
          "type": "Function",
          "lineno": 27
        },
        {
          "nodeid": "tests/test_parsing.py::TestLoadJsonFile::test_binary",
          "type": "Function",
          "lineno": 36
        },
        {
          "nodeid": "tests/test_parsing.py::TestLoadJsonFile::test_config_load",
          "type": "Function",
          "lineno": 68
        }
      ]
    },
    {
      "nodeid": "tests/test_parsing.py::TestDump",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_parsing.py::TestDump::test_dump[uncached]",
          "type": "Function",
          "lineno": 320
        },
        {
          "nodeid": "tests/test_parsing.py::TestDump::test_dump[cached]",
          "type": "Function",
          "lineno": 320
        },
        {
          "nodeid": "tests/test_parsing.py::TestDump::test_flat[uncached]",
          "type": "Function",
          "lineno": 396
        },
        {
          "nodeid": "tests/test_parsing.py::TestDump::test_flat[cached]",
          "type": "Function",
          "lineno": 396
        },
        {
          "nodeid": "tests/test_parsing.py::TestDump::test_no_values[uncached-not_set/no_distros]",
          "type": "Function",
          "lineno": 424
        },
        {
          "nodeid": "tests/test_parsing.py::TestDump::test_no_values[uncached-not_set/empty_lists]",
          "type": "Function",
          "lineno": 424
        },
        {
          "nodeid": "tests/test_parsing.py::TestDump::test_no_values[cached-not_set/no_distros]",
          "type": "Function",
          "lineno": 424
        },
        {
          "nodeid": "tests/test_parsing.py::TestDump::test_no_values[cached-not_set/empty_lists]",
          "type": "Function",
          "lineno": 424
        }
      ]
    },
    {
      "nodeid": "tests/test_parsing.py::TestAliasMods",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_parsing.py::TestAliasMods::test_global[uncached]",
          "type": "Function",
          "lineno": 810
        },
        {
          "nodeid": "tests/test_parsing.py::TestAliasMods::test_global[cached]",
          "type": "Function",
          "lineno": 810
        },
        {
          "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_list[uncached]",
          "type": "Function",
          "lineno": 857
        },
        {
          "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_list[cached]",
          "type": "Function",
          "lineno": 857
        },
        {
          "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_dict[uncached]",
          "type": "Function",
          "lineno": 869
        },
        {
          "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_dict[cached]",
          "type": "Function",
          "lineno": 869
        },
        {
          "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_dict_config[uncached]",
          "type": "Function",
          "lineno": 891
        },
        {
          "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_dict_config[cached]",
          "type": "Function",
          "lineno": 891
        },
        {
          "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_dict_mod_config[uncached]",
          "type": "Function",
          "lineno": 905
        },
        {
          "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_dict_mod_config[cached]",
          "type": "Function",
          "lineno": 905
        }
      ]
    },
    {
      "nodeid": "tests/test_parsing.py::TestCustomVariables",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_parsing.py::TestCustomVariables::test_distro",
          "type": "Function",
          "lineno": 1086
        },
        {
          "nodeid": "tests/test_parsing.py::TestCustomVariables::test_config[Config]",
          "type": "Function",
          "lineno": 1116
        },
        {
          "nodeid": "tests/test_parsing.py::TestCustomVariables::test_config[FlatConfig]",
          "type": "Function",
          "lineno": 1116
        },
        {
          "nodeid": "tests/test_parsing.py::TestCustomVariables::test_reserved[variables0-relative_root]",
          "type": "Function",
          "lineno": 1150
        },
        {
          "nodeid": "tests/test_parsing.py::TestCustomVariables::test_reserved[variables1-;, relative_root]",
          "type": "Function",
          "lineno": 1150
        },
        {
          "nodeid": "tests/test_parsing.py::TestCustomVariables::test_reserved[variables2-;]",
          "type": "Function",
          "lineno": 1150
        }
      ]
    },
    {
      "nodeid": "tests/test_parsing.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_parsing.py::TestLoadJsonFile",
          "type": "Class"
        },
        {
          "nodeid": "tests/test_parsing.py::test_distro_parse[uncached]",
          "type": "Function",
          "lineno": 80
        },
        {
          "nodeid": "tests/test_parsing.py::test_distro_parse[cached]",
          "type": "Function",
          "lineno": 80
        },
        {
          "nodeid": "tests/test_parsing.py::test_distro_exceptions",
          "type": "Function",
          "lineno": 112
        },
        {
          "nodeid": "tests/test_parsing.py::test_distro_version_resolve[uncached]",
          "type": "Function",
          "lineno": 124
        },
        {
          "nodeid": "tests/test_parsing.py::test_distro_version_resolve[cached]",
          "type": "Function",
          "lineno": 124
        },
        {
          "nodeid": "tests/test_parsing.py::test_distro_version[uncached]",
          "type": "Function",
          "lineno": 184
        },
        {
          "nodeid": "tests/test_parsing.py::test_distro_version[cached]",
          "type": "Function",
          "lineno": 184
        },
        {
          "nodeid": "tests/test_parsing.py::test_config_parse[uncached]",
          "type": "Function",
          "lineno": 192
        },
        {
          "nodeid": "tests/test_parsing.py::test_config_parse[cached]",
          "type": "Function",
          "lineno": 192
        },
        {
          "nodeid": "tests/test_parsing.py::test_config_parenting[uncached]",
          "type": "Function",
          "lineno": 216
        },
        {
          "nodeid": "tests/test_parsing.py::test_config_parenting[cached]",
          "type": "Function",
          "lineno": 216
        },
        {
          "nodeid": "tests/test_parsing.py::test_metaclass",
          "type": "Function",
          "lineno": 284
        },
        {
          "nodeid": "tests/test_parsing.py::TestDump",
          "type": "Class"
        },
        {
          "nodeid": "tests/test_parsing.py::test_environment[uncached]",
          "type": "Function",
          "lineno": 445
        },
        {
          "nodeid": "tests/test_parsing.py::test_environment[cached]",
          "type": "Function",
          "lineno": 445
        },
        {
          "nodeid": "tests/test_parsing.py::test_flat_config[uncached]",
          "type": "Function",
          "lineno": 501
        },
        {
          "nodeid": "tests/test_parsing.py::test_flat_config[cached]",
          "type": "Function",
          "lineno": 501
        },
        {
          "nodeid": "tests/test_parsing.py::test_flat_config_env_resolve[uncached]",
          "type": "Function",
          "lineno": 535
        },
        {
          "nodeid": "tests/test_parsing.py::test_flat_config_env_resolve[cached]",
          "type": "Function",
          "lineno": 535
        },
        {
          "nodeid": "tests/test_parsing.py::test_placeholder_handling[uncached]",
          "type": "Function",
          "lineno": 614
        },
        {
          "nodeid": "tests/test_parsing.py::test_placeholder_handling[cached]",
          "type": "Function",
          "lineno": 614
        },
        {
          "nodeid": "tests/test_parsing.py::test_invalid_config[uncached]",
          "type": "Function",
          "lineno": 673
        },
        {
          "nodeid": "tests/test_parsing.py::test_invalid_config[cached]",
          "type": "Function",
          "lineno": 673
        },
        {
          "nodeid": "tests/test_parsing.py::test_misc_coverage[uncached]",
          "type": "Function",
          "lineno": 697
        },
        {
          "nodeid": "tests/test_parsing.py::test_misc_coverage[cached]",
          "type": "Function",
          "lineno": 697
        },
        {
          "nodeid": "tests/test_parsing.py::test_duplicated_configs[uncached-configs_parent-not_set]",
          "type": "Function",
          "lineno": 714
        },
        {
          "nodeid": "tests/test_parsing.py::test_duplicated_configs[uncached-configs_child-not_set/child]",
          "type": "Function",
          "lineno": 714
        },
        {
          "nodeid": "tests/test_parsing.py::test_duplicated_configs[cached-configs_parent-not_set]",
          "type": "Function",
          "lineno": 714
        },
        {
          "nodeid": "tests/test_parsing.py::test_duplicated_configs[cached-configs_child-not_set/child]",
          "type": "Function",
          "lineno": 714
        },
        {
          "nodeid": "tests/test_parsing.py::test_duplicated_distros[uncached]",
          "type": "Function",
          "lineno": 751
        },
        {
          "nodeid": "tests/test_parsing.py::test_duplicated_distros[cached]",
          "type": "Function",
          "lineno": 751
        },
        {
          "nodeid": "tests/test_parsing.py::test_os_specific_linux[uncached]",
          "type": "Function",
          "lineno": 783
        },
        {
          "nodeid": "tests/test_parsing.py::test_os_specific_linux[cached]",
          "type": "Function",
          "lineno": 783
        },
        {
          "nodeid": "tests/test_parsing.py::test_os_specific_win[uncached]",
          "type": "Function",
          "lineno": 796
        },
        {
          "nodeid": "tests/test_parsing.py::test_os_specific_win[cached]",
          "type": "Function",
          "lineno": 796
        },
        {
          "nodeid": "tests/test_parsing.py::TestAliasMods",
          "type": "Class"
        },
        {
          "nodeid": "tests/test_parsing.py::test_duplicates[uncached]",
          "type": "Function",
          "lineno": 927
        },
        {
          "nodeid": "tests/test_parsing.py::test_duplicates[cached]",
          "type": "Function",
          "lineno": 927
        },
        {
          "nodeid": "tests/test_parsing.py::test_get_min_verbosity[uncached]",
          "type": "Function",
          "lineno": 943
        },
        {
          "nodeid": "tests/test_parsing.py::test_get_min_verbosity[cached]",
          "type": "Function",
          "lineno": 943
        },
        {
          "nodeid": "tests/test_parsing.py::test_alias_min_verbosity_default[uncached]",
          "type": "Function",
          "lineno": 958
        },
        {
          "nodeid": "tests/test_parsing.py::test_alias_min_verbosity_default[cached]",
          "type": "Function",
          "lineno": 958
        },
        {
          "nodeid": "tests/test_parsing.py::test_alias_min_verbosity_hab_gui[uncached]",
          "type": "Function",
          "lineno": 979
        },
        {
          "nodeid": "tests/test_parsing.py::test_alias_min_verbosity_hab_gui[cached]",
          "type": "Function",
          "lineno": 979
        },
        {
          "nodeid": "tests/test_parsing.py::test_update_environ[uncached]",
          "type": "Function",
          "lineno": 1000
        },
        {
          "nodeid": "tests/test_parsing.py::test_update_environ[cached]",
          "type": "Function",
          "lineno": 1000
        },
        {
          "nodeid": "tests/test_parsing.py::TestCustomVariables",
          "type": "Class"
        }
      ]
    },
    {
      "nodeid": "tests/test_resolver.py::TestDumpForest",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_resolver.py::TestDumpForest::test_uris_target_default[uncached]",
          "type": "Function",
          "lineno": 163
        },
        {
          "nodeid": "tests/test_resolver.py::TestDumpForest::test_uris_target_default[cached]",
          "type": "Function",
          "lineno": 163
        },
        {
          "nodeid": "tests/test_resolver.py::TestDumpForest::test_uris_objs[uncached]",
          "type": "Function",
          "lineno": 195
        },
        {
          "nodeid": "tests/test_resolver.py::TestDumpForest::test_uris_objs[cached]",
          "type": "Function",
          "lineno": 195
        },
        {
          "nodeid": "tests/test_resolver.py::TestDumpForest::test_uris_target_hab_gui[uncached]",
          "type": "Function",
          "lineno": 205
        },
        {
          "nodeid": "tests/test_resolver.py::TestDumpForest::test_uris_target_hab_gui[cached]",
          "type": "Function",
          "lineno": 205
        },
        {
          "nodeid": "tests/test_resolver.py::TestDumpForest::test_distros[uncached]",
          "type": "Function",
          "lineno": 238
        },
        {
          "nodeid": "tests/test_resolver.py::TestDumpForest::test_distros[cached]",
          "type": "Function",
          "lineno": 238
        },
        {
          "nodeid": "tests/test_resolver.py::TestDumpForest::test_distros_truncate[uncached]",
          "type": "Function",
          "lineno": 293
        },
        {
          "nodeid": "tests/test_resolver.py::TestDumpForest::test_distros_truncate[cached]",
          "type": "Function",
          "lineno": 293
        }
      ]
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_simple[uncached]",
          "type": "Function",
          "lineno": 394
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_simple[cached]",
          "type": "Function",
          "lineno": 394
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_recalculate[uncached]",
          "type": "Function",
          "lineno": 433
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_recalculate[cached]",
          "type": "Function",
          "lineno": 433
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_markers[uncached-windows-Windows]",
          "type": "Function",
          "lineno": 486
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_markers[uncached-linux-Linux]",
          "type": "Function",
          "lineno": 486
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_markers[uncached-osx-Darwin]",
          "type": "Function",
          "lineno": 486
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_markers[cached-windows-Windows]",
          "type": "Function",
          "lineno": 486
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_markers[cached-linux-Linux]",
          "type": "Function",
          "lineno": 486
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_markers[cached-osx-Darwin]",
          "type": "Function",
          "lineno": 486
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_forced_requirements[uncached-None-check0-check_versions0]",
          "type": "Function",
          "lineno": 524
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_forced_requirements[uncached-forced1-check1-check_versions1]",
          "type": "Function",
          "lineno": 524
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_forced_requirements[cached-None-check0-check_versions0]",
          "type": "Function",
          "lineno": 524
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_forced_requirements[cached-forced1-check1-check_versions1]",
          "type": "Function",
          "lineno": 524
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements0-False-check0]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements1-True-check1]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements2-True-check2]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements3-False-check3]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements4-True-check4]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements5-False-check5]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements6-True-check6]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements7-False-check7]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements8-True-False]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements9-False-False]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements10-True-check10]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements11-False-check11]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements12-True-check12]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements13-False-check13]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements14-False-check14]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements15-True-check15]",
          "type": "Function",
          "lineno": 591
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_forced_requirements_uri[uncached]",
          "type": "Function",
          "lineno": 646
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_forced_requirements_uri[cached]",
          "type": "Function",
          "lineno": 646
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_override_forced",
          "type": "Function",
          "lineno": 665
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_override_forced_empty",
          "type": "Function",
          "lineno": 693
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_override_forced_unset",
          "type": "Function",
          "lineno": 720
        }
      ]
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_collapse_paths",
          "type": "Function",
          "lineno": 769
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_pathsep",
          "type": "Function",
          "lineno": 820
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[WinPlatform-Path]",
          "type": "Function",
          "lineno": 829
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[WinPlatform-PurePath]",
          "type": "Function",
          "lineno": 829
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[WinPlatform-PurePosixPath]",
          "type": "Function",
          "lineno": 829
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[WinPlatform-PureWindowsPath]",
          "type": "Function",
          "lineno": 829
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[LinuxPlatform-Path]",
          "type": "Function",
          "lineno": 829
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[LinuxPlatform-PurePath]",
          "type": "Function",
          "lineno": 829
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[LinuxPlatform-PurePosixPath]",
          "type": "Function",
          "lineno": 829
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[LinuxPlatform-PureWindowsPath]",
          "type": "Function",
          "lineno": 829
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[OsxPlatform-Path]",
          "type": "Function",
          "lineno": 829
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[OsxPlatform-PurePath]",
          "type": "Function",
          "lineno": 829
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[OsxPlatform-PurePosixPath]",
          "type": "Function",
          "lineno": 829
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[OsxPlatform-PureWindowsPath]",
          "type": "Function",
          "lineno": 829
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[c:\\\\temp-C:/temp]",
          "type": "Function",
          "lineno": 847
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[C:\\\\temp-C:/temp]",
          "type": "Function",
          "lineno": 847
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[C:\\\\teMP-C:/teMP]",
          "type": "Function",
          "lineno": 847
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[z:\\\\subfolder-Z:/subfolder]",
          "type": "Function",
          "lineno": 847
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[relative\\\\path-relative/path]",
          "type": "Function",
          "lineno": 847
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[\\\\\\\\unc\\\\share\\\\folder-//unc/share/folder]",
          "type": "Function",
          "lineno": 847
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[\\\\\\\\UnC\\\\shaRe\\\\folDer-//UnC/shaRe/folDer]",
          "type": "Function",
          "lineno": 847
        }
      ]
    },
    {
      "nodeid": "tests/test_resolver.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_resolver.py::test_environment_variables",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_resolver.py::test_config[uncached]",
          "type": "Function",
          "lineno": 60
        },
        {
          "nodeid": "tests/test_resolver.py::test_config[cached]",
          "type": "Function",
          "lineno": 60
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_a-project_a-Complete root path not found]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_a/Sc001-project_a/Sc001-Complete secondary path not found]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_a/Sc001/Animation-project_a/Sc001/Animation-Complete tertiary path not found]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_a/Sc001/Modeling-project_a/Sc001-Invalid tertiary path not fallen back]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_a/Sc999/Modeling-project_a-Invalid secondary path not fallen back]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_a/very/many/paths/resolved-project_a-Invalid n-length path not fallen back]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_z-default-Default root not returned for invalid root.]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_z/Sc001-default-Default root not returned if no matching secondary.]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_z/Sc101-default/Sc1-Default secondary not returned]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_z/Sc110-default/Sc11-More specific default secondary not returned]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-/app-app-Leading slash not ignored]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-app/-app-Trailing slash not sanitized correctly]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[uncached-app/case/-app-Trailing slash not sanitized correctly]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_a-project_a-Complete root path not found]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_a/Sc001-project_a/Sc001-Complete secondary path not found]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_a/Sc001/Animation-project_a/Sc001/Animation-Complete tertiary path not found]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_a/Sc001/Modeling-project_a/Sc001-Invalid tertiary path not fallen back]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_a/Sc999/Modeling-project_a-Invalid secondary path not fallen back]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_a/very/many/paths/resolved-project_a-Invalid n-length path not fallen back]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_z-default-Default root not returned for invalid root.]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_z/Sc001-default-Default root not returned if no matching secondary.]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_z/Sc101-default/Sc1-Default secondary not returned]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_z/Sc110-default/Sc11-More specific default secondary not returned]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-/app-app-Leading slash not ignored]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-app/-app-Trailing slash not sanitized correctly]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::test_closest_config[cached-app/case/-app-Trailing slash not sanitized correctly]",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_resolver.py::TestDumpForest",
          "type": "Class"
        },
        {
          "nodeid": "tests/test_resolver.py::test_reduced[uncached]",
          "type": "Function",
          "lineno": 349
        },
        {
          "nodeid": "tests/test_resolver.py::test_reduced[cached]",
          "type": "Function",
          "lineno": 349
        },
        {
          "nodeid": "tests/test_resolver.py::TestResolveRequirements",
          "type": "Class"
        },
        {
          "nodeid": "tests/test_resolver.py::test_path_expansion[uncached-test_string-check0]",
          "type": "Function",
          "lineno": 748
        },
        {
          "nodeid": "tests/test_resolver.py::test_path_expansion[uncached-one;two-check1]",
          "type": "Function",
          "lineno": 748
        },
        {
          "nodeid": "tests/test_resolver.py::test_path_expansion[cached-test_string-check0]",
          "type": "Function",
          "lineno": 748
        },
        {
          "nodeid": "tests/test_resolver.py::test_path_expansion[cached-one;two-check1]",
          "type": "Function",
          "lineno": 748
        },
        {
          "nodeid": "tests/test_resolver.py::TestPlatform",
          "type": "Class"
        },
        {
          "nodeid": "tests/test_resolver.py::test_cygpath",
          "type": "Function",
          "lineno": 866
        },
        {
          "nodeid": "tests/test_resolver.py::test_natrual_sort",
          "type": "Function",
          "lineno": 910
        },
        {
          "nodeid": "tests/test_resolver.py::test_star_import",
          "type": "Function",
          "lineno": 931
        },
        {
          "nodeid": "tests/test_resolver.py::test_clear_caches[uncached]",
          "type": "Function",
          "lineno": 956
        },
        {
          "nodeid": "tests/test_resolver.py::test_clear_caches[cached]",
          "type": "Function",
          "lineno": 956
        },
        {
          "nodeid": "tests/test_resolver.py::test_clear_caches_cached",
          "type": "Function",
          "lineno": 975
        },
        {
          "nodeid": "tests/test_resolver.py::test_uri_validate",
          "type": "Function",
          "lineno": 987
        },
        {
          "nodeid": "tests/test_resolver.py::test_instance",
          "type": "Function",
          "lineno": 1023
        }
      ]
    },
    {
      "nodeid": "tests/test_scripts.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_scripts.py::test_scripts[bat_activate]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[bat_activate_launch]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[bat_env]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[bat_env_launch]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[bat_launch]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[bat_launch_args]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[ps1_activate]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[ps1_activate_launch]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[ps1_env]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[ps1_env_launch]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[ps1_launch]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[ps1_launch_args]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[sh_linux_activate]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[sh_linux_activate_launch]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[sh_linux_env]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[sh_linux_env_launch]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[sh_linux_launch]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[sh_linux_launch_args]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[sh_win_activate]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[sh_win_activate_launch]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[sh_win_env]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[sh_win_env_launch]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[sh_win_launch]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_scripts[sh_win_launch_args]",
          "type": "Function",
          "lineno": 15
        },
        {
          "nodeid": "tests/test_scripts.py::test_complex_alias_bat",
          "type": "Function",
          "lineno": 173
        },
        {
          "nodeid": "tests/test_scripts.py::test_complex_alias_ps1",
          "type": "Function",
          "lineno": 210
        },
        {
          "nodeid": "tests/test_scripts.py::test_complex_alias_sh",
          "type": "Function",
          "lineno": 247
        },
        {
          "nodeid": "tests/test_scripts.py::test_invalid_alias[.bat]",
          "type": "Function",
          "lineno": 284
        },
        {
          "nodeid": "tests/test_scripts.py::test_invalid_alias[.ps1]",
          "type": "Function",
          "lineno": 284
        },
        {
          "nodeid": "tests/test_scripts.py::test_invalid_alias[.sh]",
          "type": "Function",
          "lineno": 284
        }
      ]
    },
    {
      "nodeid": "tests/test_site.py::TestMultipleSites",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_site.py::TestMultipleSites::test_left",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_site.py::TestMultipleSites::test_middle",
          "type": "Function",
          "lineno": 81
        },
        {
          "nodeid": "tests/test_site.py::TestMultipleSites::test_right",
          "type": "Function",
          "lineno": 93
        },
        {
          "nodeid": "tests/test_site.py::TestMultipleSites::test_left_right",
          "type": "Function",
          "lineno": 105
        },
        {
          "nodeid": "tests/test_site.py::TestMultipleSites::test_right_left",
          "type": "Function",
          "lineno": 129
        },
        {
          "nodeid": "tests/test_site.py::TestMultipleSites::test_left_middle_right",
          "type": "Function",
          "lineno": 154
        }
      ]
    },
    {
      "nodeid": "tests/test_site.py::TestResolvePaths",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_site.py::TestResolvePaths::test_path",
          "type": "Function",
          "lineno": 184
        },
        {
          "nodeid": "tests/test_site.py::TestResolvePaths::test_paths",
          "type": "Function",
          "lineno": 192
        },
        {
          "nodeid": "tests/test_site.py::TestResolvePaths::test_paths_reversed",
          "type": "Function",
          "lineno": 215
        }
      ]
    },
    {
      "nodeid": "tests/test_site.py::TestOsSpecific",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_site.py::TestOsSpecific::test_linux",
          "type": "Function",
          "lineno": 332
        },
        {
          "nodeid": "tests/test_site.py::TestOsSpecific::test_osx",
          "type": "Function",
          "lineno": 345
        },
        {
          "nodeid": "tests/test_site.py::TestOsSpecific::test_win",
          "type": "Function",
          "lineno": 358
        }
      ]
    },
    {
      "nodeid": "tests/test_site.py::TestPlatformPathMap",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_site.py::TestPlatformPathMap::test_linux",
          "type": "Function",
          "lineno": 373
        },
        {
          "nodeid": "tests/test_site.py::TestPlatformPathMap::test_win",
          "type": "Function",
          "lineno": 406
        },
        {
          "nodeid": "tests/test_site.py::TestPlatformPathMap::test_unset_variables",
          "type": "Function",
          "lineno": 450
        }
      ]
    },
    {
      "nodeid": "tests/test_site.py::TestPlatformPathMapDict",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_site.py::TestPlatformPathMapDict::test_main",
          "type": "Function",
          "lineno": 486
        },
        {
          "nodeid": "tests/test_site.py::TestPlatformPathMapDict::test_override",
          "type": "Function",
          "lineno": 503
        },
        {
          "nodeid": "tests/test_site.py::TestPlatformPathMapDict::test_merged",
          "type": "Function",
          "lineno": 513
        },
        {
          "nodeid": "tests/test_site.py::TestPlatformPathMapDict::test_reversed",
          "type": "Function",
          "lineno": 533
        }
      ]
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_empty_site",
          "type": "Function",
          "lineno": 555
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_default",
          "type": "Function",
          "lineno": 561
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_site_cli[site_files0-hab_test_entry_points-gui-True]",
          "type": "Function",
          "lineno": 575
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_site_cli[site_files1-hab_test_entry_points-gui_alt-True]",
          "type": "Function",
          "lineno": 575
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_site_cli[site_files2-hab_test_entry_points-gui-True]",
          "type": "Function",
          "lineno": 575
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_site_cli[site_files3-hab_test_entry_points-gui-True]",
          "type": "Function",
          "lineno": 575
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_site_cli[site_files4-None-None-True]",
          "type": "Function",
          "lineno": 575
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_site_cli[site_files5-None-None-False]",
          "type": "Function",
          "lineno": 575
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_called_by_resolve[cfg_reduce_env.json-hab_test_entry_points.cfg_reduce_env called successfully]",
          "type": "Function",
          "lineno": 649
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_called_by_resolve[cfg_reduce_finalize.json-hab_test_entry_points.cfg_reduce_finalize called successfully]",
          "type": "Function",
          "lineno": 649
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_called_by_resolve[cfg_uri_validate.json-hab_test_entry_points.uri_validate_error called successfully]",
          "type": "Function",
          "lineno": 649
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_site_add_paths_non_recursive",
          "type": "Function",
          "lineno": 685
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_site_add_paths_multiple",
          "type": "Function",
          "lineno": 706
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_site_finalize",
          "type": "Function",
          "lineno": 730
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints::test_habcache_cls",
          "type": "Function",
          "lineno": 747
        }
      ]
    },
    {
      "nodeid": "tests/test_site.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_site.py::test_environment_variables",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_site.py::TestMultipleSites",
          "type": "Class"
        },
        {
          "nodeid": "tests/test_site.py::TestResolvePaths",
          "type": "Class"
        },
        {
          "nodeid": "tests/test_site.py::test_path_in_raise",
          "type": "Function",
          "lineno": 238
        },
        {
          "nodeid": "tests/test_site.py::test_dump",
          "type": "Function",
          "lineno": 246
        },
        {
          "nodeid": "tests/test_site.py::test_dump_cached",
          "type": "Function",
          "lineno": 272
        },
        {
          "nodeid": "tests/test_site.py::TestOsSpecific",
          "type": "Class"
        },
        {
          "nodeid": "tests/test_site.py::TestPlatformPathMap",
          "type": "Class"
        },
        {
          "nodeid": "tests/test_site.py::TestPlatformPathMapDict",
          "type": "Class"
        },
        {
          "nodeid": "tests/test_site.py::TestEntryPoints",
          "type": "Class"
        }
      ]
    },
    {
      "nodeid": "tests/test_solver.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_solver.py::test_simplify_requirements[value0-check0]",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_solver.py::test_simplify_requirements[value1-check1]",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_solver.py::test_simplify_requirements[value2-check2]",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_solver.py::test_simplify_requirements[value3-check3]",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_solver.py::test_simplify_requirements[value4-check4]",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_solver.py::test_simplify_requirements[value5-check5]",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_solver.py::test_simplify_requirements[value6-check6]",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_solver.py::test_simplify_requirements[value7-check7]",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_solver.py::test_simplify_requirements[value8-check8]",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_solver.py::test_simplify_requirements[value9-check9]",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_solver.py::test_simplify_requirements[value10-check10]",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_solver.py::test_simplify_requirements[value11-check11]",
          "type": "Function",
          "lineno": 10
        },
        {
          "nodeid": "tests/test_solver.py::test_invalid_requirement_errors[requirements0-Unable to find a distro for requirement: no_existant_distro]",
          "type": "Function",
          "lineno": 39
        },
        {
          "nodeid": "tests/test_solver.py::test_invalid_requirement_errors[requirements1-Unable to find a distro for requirement: no_exist; platform_system != \"Invalid\"]",
          "type": "Function",
          "lineno": 39
        },
        {
          "nodeid": "tests/test_solver.py::test_invalid_requirement_errors[requirements2-Unable to find a valid version for \"the_dcc==0.0.0\" in versions \\\\[.+\\\\]]",
          "type": "Function",
          "lineno": 39
        },
        {
          "nodeid": "tests/test_solver.py::test_invalid_requirement_errors[requirements3-Unable to find a valid version for \"the_dcc<1.2,>1.1\" in versions \\\\[.+\\\\]]",
          "type": "Function",
          "lineno": 39
        },
        {
          "nodeid": "tests/test_solver.py::test_solver_errors",
          "type": "Function",
          "lineno": 72
        },
        {
          "nodeid": "tests/test_solver.py::test_omittable",
          "type": "Function",
          "lineno": 92
        }
      ]
    },
    {
      "nodeid": "tests/test_user_prefs.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_user_prefs.py::test_user_prefs_filename",
          "type": "Function",
          "lineno": 9
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_configure_logging",
          "type": "Function",
          "lineno": 20
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_filename",
          "type": "Function",
          "lineno": 56
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_enabled_no_default",
          "type": "Function",
          "lineno": 69
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_enabled[setting0-False-None-False]",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_enabled[setting1-False-True-False]",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_enabled[setting2-False-False-False]",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_enabled[setting3-True-None-True]",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_enabled[setting4-True-True-True]",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_enabled[setting5-True-False-False]",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_enabled[setting6-True-True-True]",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_enabled[setting7-False-None-False]",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_enabled[setting8-False-True-True]",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_enabled[setting9-False-False-False]",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_enabled[setting10-False-False-False]",
          "type": "Function",
          "lineno": 76
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_timeout",
          "type": "Function",
          "lineno": 104
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_uri",
          "type": "Function",
          "lineno": 135
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_corruption[None]",
          "type": "Function",
          "lineno": 210
        },
        {
          "nodeid": "tests/test_user_prefs.py::test_corruption[{\\n    \"uri\": \"app]",
          "type": "Function",
          "lineno": 210
        }
      ]
    },
    {
      "nodeid": "tests",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/configs",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros",
          "type": "Dir"
        },
        {
          "nodeid": "tests/distros_version",
          "type": "Dir"
        },
        {
          "nodeid": "tests/duplicates",
          "type": "Dir"
        },
        {
          "nodeid": "tests/merge_dict",
          "type": "Dir"
        },
        {
          "nodeid": "tests/reference_scripts",
          "type": "Dir"
        },
        {
          "nodeid": "tests/site",
          "type": "Dir"
        },
        {
          "nodeid": "tests/site_omit",
          "type": "Dir"
        },
        {
          "nodeid": "tests/test_cache.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_format_parser.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_formatter.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_freeze.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_launch.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_parsing.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_resolver.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_scripts.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_site.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_solver.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_user_prefs.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": ".",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "bin",
          "type": "Dir"
        },
        {
          "nodeid": "hab",
          "type": "Package"
        },
        {
          "nodeid": "hab.egg-info",
          "type": "Dir"
        },
        {
          "nodeid": "tests",
          "type": "Dir"
        }
      ]
    }
  ],
  "tests": [
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[uncached-os_agnostic.json-None]",
      "lineno": 8,
      "outcome": "passed",
      "keywords": [
        "test_apply_platform_wildcards[uncached-os_agnostic.json-None]",
        "parametrize",
        "pytestmark",
        "uncached-os_agnostic.json-None",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[uncached-os_agnostic_platforms.json-platforms1]",
      "lineno": 8,
      "outcome": "passed",
      "keywords": [
        "test_apply_platform_wildcards[uncached-os_agnostic_platforms.json-platforms1]",
        "parametrize",
        "pytestmark",
        "uncached-os_agnostic_platforms.json-platforms1",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[uncached-os_specific.json-None]",
      "lineno": 8,
      "outcome": "passed",
      "keywords": [
        "test_apply_platform_wildcards[uncached-os_specific.json-None]",
        "parametrize",
        "pytestmark",
        "uncached-os_specific.json-None",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[uncached-os_specific_false.json-None]",
      "lineno": 8,
      "outcome": "passed",
      "keywords": [
        "test_apply_platform_wildcards[uncached-os_specific_false.json-None]",
        "parametrize",
        "pytestmark",
        "uncached-os_specific_false.json-None",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[uncached-os_specific_platforms.json-platforms4]",
      "lineno": 8,
      "outcome": "passed",
      "keywords": [
        "test_apply_platform_wildcards[uncached-os_specific_platforms.json-platforms4]",
        "parametrize",
        "pytestmark",
        "uncached-os_specific_platforms.json-platforms4",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[cached-os_agnostic.json-None]",
      "lineno": 8,
      "outcome": "error",
      "keywords": [
        "test_apply_platform_wildcards[cached-os_agnostic.json-None]",
        "parametrize",
        "pytestmark",
        "cached-os_agnostic.json-None",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_apply_platform_wildcards[cached-os_agnostic.json-None]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[cached-os_agnostic_platforms.json-platforms1]",
      "lineno": 8,
      "outcome": "error",
      "keywords": [
        "test_apply_platform_wildcards[cached-os_agnostic_platforms.json-platforms1]",
        "parametrize",
        "pytestmark",
        "cached-os_agnostic_platforms.json-platforms1",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_apply_platform_wildcards[cached-os_agnostic_platforms.json-platforms1]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[cached-os_specific.json-None]",
      "lineno": 8,
      "outcome": "error",
      "keywords": [
        "test_apply_platform_wildcards[cached-os_specific.json-None]",
        "parametrize",
        "pytestmark",
        "cached-os_specific.json-None",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_apply_platform_wildcards[cached-os_specific.json-None]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[cached-os_specific_false.json-None]",
      "lineno": 8,
      "outcome": "error",
      "keywords": [
        "test_apply_platform_wildcards[cached-os_specific_false.json-None]",
        "parametrize",
        "pytestmark",
        "cached-os_specific_false.json-None",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_apply_platform_wildcards[cached-os_specific_false.json-None]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_apply_platform_wildcards[cached-os_specific_platforms.json-platforms4]",
      "lineno": 8,
      "outcome": "error",
      "keywords": [
        "test_apply_platform_wildcards[cached-os_specific_platforms.json-platforms4]",
        "parametrize",
        "pytestmark",
        "cached-os_specific_platforms.json-platforms4",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_apply_platform_wildcards[cached-os_specific_platforms.json-platforms4]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_path_split",
      "lineno": 47,
      "outcome": "passed",
      "keywords": [
        "test_path_split",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_merge[merge_agnostic.json]",
      "lineno": 75,
      "outcome": "passed",
      "keywords": [
        "test_merge[merge_agnostic.json]",
        "parametrize",
        "pytestmark",
        "merge_agnostic.json",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/merge_dict/test_merge_dict.py::test_merge[merge_specific.json]",
      "lineno": 75,
      "outcome": "passed",
      "keywords": [
        "test_merge[merge_specific.json]",
        "parametrize",
        "pytestmark",
        "merge_specific.json",
        "test_merge_dict.py",
        "merge_dict",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/site_omit/test_omittable.py::test_defined",
      "lineno": 13,
      "outcome": "failed",
      "keywords": [
        "test_defined",
        "test_omittable.py",
        "site_omit",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\site_omit\\test_omittable.py",
            "lineno": 19,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "omit_resolver = <hab.resolver.Resolver object at 0x00000166546A13D0>\n\n    def test_defined(omit_resolver):\n        \"\"\"The `omittable/defined` config defines both distros and omittable_distros.\n        Ensure the versions are resolved correctly and doesn't raise a\n        `InvalidRequirementError` exception.\n        \"\"\"\n>       cfg = omit_resolver.resolve(\"omittable/defined\")\n\ntests\\site_omit\\test_omittable.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546A11F0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546A13D0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\site_omit\\\\configs\\\\default.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/site_omit/configs')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/site_omit/test_omittable.py::test_inherited",
      "lineno": 48,
      "outcome": "failed",
      "keywords": [
        "test_inherited",
        "test_omittable.py",
        "site_omit",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\site_omit\\test_omittable.py",
            "lineno": 55,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "omit_resolver = <hab.resolver.Resolver object at 0x00000166546633E0>\n\n    def test_inherited(omit_resolver):\n        \"\"\"The `omittable/inherited` config only defines distros but not\n        omittable_distros which are inherited from `default`. Ensure the versions\n        are resolved correctly and doesn't raise a `InvalidRequirementError` exception.\n        \"\"\"\n        # This config defines both distros and omittable_distros inside the file\n>       cfg = omit_resolver.resolve(\"omittable/inherited\")\n\ntests\\site_omit\\test_omittable.py:55: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654661A90>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546633E0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\site_omit\\\\configs\\\\default.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/site_omit/configs')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/site_omit/test_omittable.py::test_forced",
      "lineno": 82,
      "outcome": "failed",
      "keywords": [
        "test_forced",
        "test_omittable.py",
        "site_omit",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\site_omit\\test_omittable.py",
            "lineno": 92,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "omit_resolver = <hab.resolver.Resolver object at 0x00000166546A0DA0>\n\n    def test_forced(omit_resolver):\n        \"\"\"Checks how omittable_distros handle forced_requirements.\"\"\"\n    \n        # Passing a missing non-omittable_distro as a forced_requirement should\n        # still raise an error\n        with pytest.raises(\n            errors.InvalidRequirementError,\n            match=r\"Unable to find a distro for requirement: missing_dcc\",\n        ):\n>           omit_resolver.resolve(\"omittable/invalid\", forced_requirements=[\"missing_dcc\"])\n\ntests\\site_omit\\test_omittable.py:92: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546A2360>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546A0DA0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\site_omit\\\\configs\\\\default.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/site_omit/configs')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/site_omit/test_omittable.py::test_pure_default",
      "lineno": 123,
      "outcome": "failed",
      "keywords": [
        "test_pure_default",
        "test_omittable.py",
        "site_omit",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\site_omit\\test_omittable.py",
            "lineno": 131,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "omit_resolver = <hab.resolver.Resolver object at 0x00000166546A33E0>\n\n    def test_pure_default(omit_resolver):\n        \"\"\"The `omittable/undefined` config is not explicitly defined so all values\n        are inherited from `default`. Ensure the versions are resolved correctly\n        and doesn't raise a `InvalidRequirementError` exception.\n        \"\"\"\n        # This config and its parent are not defined, both distros and omittable_distros\n        # are only defined in the default configuration.\n>       cfg = omit_resolver.resolve(\"omittable/undefined\")\n\ntests\\site_omit\\test_omittable.py:131: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546A35C0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546A33E0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\site_omit\\\\configs\\\\default.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/site_omit/configs')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/site_omit/test_omittable.py::test_missing_required",
      "lineno": 160,
      "outcome": "failed",
      "keywords": [
        "test_missing_required",
        "test_omittable.py",
        "site_omit",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\site_omit\\test_omittable.py",
            "lineno": 169,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "omit_resolver = <hab.resolver.Resolver object at 0x00000166546B58B0>\n\n    def test_missing_required(omit_resolver):\n        \"\"\"The `omittable/invalid` config requires the `missing_dcc` distro but does\n        not add it to `omittable_distros`, and will raise `InvalidRequirementError`.\n        \"\"\"\n        with pytest.raises(\n            errors.InvalidRequirementError,\n            match=r\"Unable to find a distro for requirement: missing_dcc\",\n        ):\n>           omit_resolver.resolve(\"omittable/invalid\")\n\ntests\\site_omit\\test_omittable.py:169: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546B42C0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546B58B0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\site_omit\\\\configs\\\\default.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/site_omit/configs')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_cache.py::test_cached_keys",
      "lineno": 8,
      "outcome": "passed",
      "keywords": [
        "test_cached_keys",
        "test_cache.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_cache.py::test_site_cache_path",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_site_cache_path",
        "test_cache.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_cache.py::test_save_cache",
      "lineno": 44,
      "outcome": "error",
      "keywords": [
        "test_save_cache",
        "test_cache.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_cache.py::test_load_cache",
      "lineno": 52,
      "outcome": "error",
      "keywords": [
        "test_load_cache",
        "test_cache.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_cache.py::test_unsupported_version_warning",
      "lineno": 67,
      "outcome": "passed",
      "keywords": [
        "test_unsupported_version_warning",
        "test_cache.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_cache.py::test_cached_method",
      "lineno": 99,
      "outcome": "error",
      "keywords": [
        "test_cached_method",
        "test_cache.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_cache.py::test_resolver_cache[uncached]",
      "lineno": 127,
      "outcome": "failed",
      "keywords": [
        "test_resolver_cache[uncached]",
        "uncached",
        "test_cache.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_cache.py",
            "lineno": 149,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <FixtureRequest for <Function test_resolver_cache[uncached]>>\nresolver = <hab.resolver.Resolver object at 0x00000166546B6570>\n\n    def test_resolver_cache(request, resolver):\n        \"\"\"Tests that cached and uncached resolvers actually use/don't use the cache.\n    \n        `uncached_resolver` should not have a habcache file and shouldn't use a cache.\n        `habcached_resolver` should have a habcache and uses it.\n        \"\"\"\n        # Figure out if this is the cached or uncached resolver test\n        is_cached = \"habcached_resolver\" in request.fixturenames\n    \n        # Get the site file path\n        assert len(resolver.site.paths) == 1\n        site_file = resolver.site.paths[0]\n        cache_file = resolver.site.cache.site_cache_path(site_file)\n    \n        # The .habcache file should only exist when testing cached\n        if is_cached:\n            assert cache_file.exists()\n        else:\n            assert not cache_file.exists()\n    \n        # force the resolver to load config/distro information\n>       resolver.resolve(\"not_set\")\n\ntests\\test_cache.py:149: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546B6060>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546B6570>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_cache.py::test_resolver_cache[cached]",
      "lineno": 127,
      "outcome": "error",
      "keywords": [
        "test_resolver_cache[cached]",
        "cached",
        "test_cache.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_resolver_cache[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app--False-app-app]",
      "lineno": 11,
      "outcome": "failed",
      "keywords": [
        "test_format_parser_uri[app--False-app-app]",
        "parametrize",
        "pytestmark",
        "app--False-app-app",
        "test_format_parser.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_format_parser.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nuncached_resolver = <hab.resolver.Resolver object at 0x00000166546B7F20>\nuri = 'app', pre = '', color = False, zero = 'app', one = 'app'\n\n    @pytest.mark.parametrize(\n        \"uri,pre,color,zero,one\",\n        (\n            # Top level URI placeholder is not indented\n            (\"app\", \"\", False, \"app\", \"app\"),\n            (\"app\", \"\", True, f\"{cg}app{cr}\", f\"{cg}app{cr}\"),\n            # Child URI is defined, The URI is not turned green and is indented\n            (\"app/aliased\", \"  \", False, \"  app/aliased\", '  app/aliased: \"{filename}\"'),\n            (\n                \"app/aliased\",\n                \"  \",\n                True,\n                \"  app/aliased\",\n                f'  app/aliased: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Grand-child URI is defined, The URI is not turned green and is indented\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                False,\n                \"  app/aliased/mod\",\n                '  app/aliased/mod: \"{filename}\"',\n            ),\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                True,\n                \"  app/aliased/mod\",\n                f'  app/aliased/mod: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Top level URI is defined so not a placeholder (not indented)\n            (\"project_a\", \"\", False, \"project_a\", 'project_a: \"{filename}\"'),\n            (\n                \"project_a\",\n                \"\",\n                True,\n                f\"{cg}project_a{cr}\",\n                f'{cg}project_a{cr}: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Parent and child URI is not defined, The URI is not turned green and no filename\n            (\"app/houdini\", \"  \", False, \"  app/houdini\", \"  app/houdini\"),\n            (\n                \"app/houdini\",\n                \"  \",\n                True,\n                \"  app/houdini\",\n                \"  app/houdini\",\n            ),\n        ),\n    )\n    def test_format_parser_uri(config_root, uncached_resolver, uri, pre, color, zero, one):\n        \"\"\"Test various uses of `hab.parsers.format_parser.FormatParser`.\"\"\"\n>       cfg = uncached_resolver.closest_config(uri)\n\ntests\\test_format_parser.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546BC3E0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546B7F20>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app--True-\\x1b[32mapp\\x1b[39m-\\x1b[32mapp\\x1b[39m]",
      "lineno": 11,
      "outcome": "failed",
      "keywords": [
        "test_format_parser_uri[app--True-\\x1b[32mapp\\x1b[39m-\\x1b[32mapp\\x1b[39m]",
        "parametrize",
        "pytestmark",
        "app--True-\\x1b[32mapp\\x1b[39m-\\x1b[32mapp\\x1b[39m",
        "test_format_parser.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_format_parser.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nuncached_resolver = <hab.resolver.Resolver object at 0x00000166546BF5C0>\nuri = 'app', pre = '', color = True, zero = '\\x1b[32mapp\\x1b[39m'\none = '\\x1b[32mapp\\x1b[39m'\n\n    @pytest.mark.parametrize(\n        \"uri,pre,color,zero,one\",\n        (\n            # Top level URI placeholder is not indented\n            (\"app\", \"\", False, \"app\", \"app\"),\n            (\"app\", \"\", True, f\"{cg}app{cr}\", f\"{cg}app{cr}\"),\n            # Child URI is defined, The URI is not turned green and is indented\n            (\"app/aliased\", \"  \", False, \"  app/aliased\", '  app/aliased: \"{filename}\"'),\n            (\n                \"app/aliased\",\n                \"  \",\n                True,\n                \"  app/aliased\",\n                f'  app/aliased: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Grand-child URI is defined, The URI is not turned green and is indented\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                False,\n                \"  app/aliased/mod\",\n                '  app/aliased/mod: \"{filename}\"',\n            ),\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                True,\n                \"  app/aliased/mod\",\n                f'  app/aliased/mod: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Top level URI is defined so not a placeholder (not indented)\n            (\"project_a\", \"\", False, \"project_a\", 'project_a: \"{filename}\"'),\n            (\n                \"project_a\",\n                \"\",\n                True,\n                f\"{cg}project_a{cr}\",\n                f'{cg}project_a{cr}: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Parent and child URI is not defined, The URI is not turned green and no filename\n            (\"app/houdini\", \"  \", False, \"  app/houdini\", \"  app/houdini\"),\n            (\n                \"app/houdini\",\n                \"  \",\n                True,\n                \"  app/houdini\",\n                \"  app/houdini\",\n            ),\n        ),\n    )\n    def test_format_parser_uri(config_root, uncached_resolver, uri, pre, color, zero, one):\n        \"\"\"Test various uses of `hab.parsers.format_parser.FormatParser`.\"\"\"\n>       cfg = uncached_resolver.closest_config(uri)\n\ntests\\test_format_parser.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546BD1C0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546BF5C0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app/aliased-  -False-  app/aliased-  app/aliased: \"{filename}\"]",
      "lineno": 11,
      "outcome": "failed",
      "keywords": [
        "test_format_parser_uri[app/aliased-  -False-  app/aliased-  app/aliased: \"{filename}\"]",
        "parametrize",
        "pytestmark",
        "app/aliased-  -False-  app/aliased-  app/aliased: \"{filename}\"",
        "test_format_parser.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_format_parser.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nuncached_resolver = <hab.resolver.Resolver object at 0x00000166546BD970>\nuri = 'app/aliased', pre = '  ', color = False, zero = '  app/aliased'\none = '  app/aliased: \"{filename}\"'\n\n    @pytest.mark.parametrize(\n        \"uri,pre,color,zero,one\",\n        (\n            # Top level URI placeholder is not indented\n            (\"app\", \"\", False, \"app\", \"app\"),\n            (\"app\", \"\", True, f\"{cg}app{cr}\", f\"{cg}app{cr}\"),\n            # Child URI is defined, The URI is not turned green and is indented\n            (\"app/aliased\", \"  \", False, \"  app/aliased\", '  app/aliased: \"{filename}\"'),\n            (\n                \"app/aliased\",\n                \"  \",\n                True,\n                \"  app/aliased\",\n                f'  app/aliased: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Grand-child URI is defined, The URI is not turned green and is indented\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                False,\n                \"  app/aliased/mod\",\n                '  app/aliased/mod: \"{filename}\"',\n            ),\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                True,\n                \"  app/aliased/mod\",\n                f'  app/aliased/mod: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Top level URI is defined so not a placeholder (not indented)\n            (\"project_a\", \"\", False, \"project_a\", 'project_a: \"{filename}\"'),\n            (\n                \"project_a\",\n                \"\",\n                True,\n                f\"{cg}project_a{cr}\",\n                f'{cg}project_a{cr}: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Parent and child URI is not defined, The URI is not turned green and no filename\n            (\"app/houdini\", \"  \", False, \"  app/houdini\", \"  app/houdini\"),\n            (\n                \"app/houdini\",\n                \"  \",\n                True,\n                \"  app/houdini\",\n                \"  app/houdini\",\n            ),\n        ),\n    )\n    def test_format_parser_uri(config_root, uncached_resolver, uri, pre, color, zero, one):\n        \"\"\"Test various uses of `hab.parsers.format_parser.FormatParser`.\"\"\"\n>       cfg = uncached_resolver.closest_config(uri)\n\ntests\\test_format_parser.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546BE3C0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546BD970>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app/aliased-  -True-  app/aliased-  app/aliased: \\x1b[33m\"{filename}\"\\x1b[39m]",
      "lineno": 11,
      "outcome": "failed",
      "keywords": [
        "test_format_parser_uri[app/aliased-  -True-  app/aliased-  app/aliased: \\x1b[33m\"{filename}\"\\x1b[39m]",
        "parametrize",
        "pytestmark",
        "app/aliased-  -True-  app/aliased-  app/aliased: \\x1b[33m\"{filename}\"\\x1b[39m",
        "test_format_parser.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_format_parser.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nuncached_resolver = <hab.resolver.Resolver object at 0x00000166546BDA00>\nuri = 'app/aliased', pre = '  ', color = True, zero = '  app/aliased'\none = '  app/aliased: \\x1b[33m\"{filename}\"\\x1b[39m'\n\n    @pytest.mark.parametrize(\n        \"uri,pre,color,zero,one\",\n        (\n            # Top level URI placeholder is not indented\n            (\"app\", \"\", False, \"app\", \"app\"),\n            (\"app\", \"\", True, f\"{cg}app{cr}\", f\"{cg}app{cr}\"),\n            # Child URI is defined, The URI is not turned green and is indented\n            (\"app/aliased\", \"  \", False, \"  app/aliased\", '  app/aliased: \"{filename}\"'),\n            (\n                \"app/aliased\",\n                \"  \",\n                True,\n                \"  app/aliased\",\n                f'  app/aliased: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Grand-child URI is defined, The URI is not turned green and is indented\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                False,\n                \"  app/aliased/mod\",\n                '  app/aliased/mod: \"{filename}\"',\n            ),\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                True,\n                \"  app/aliased/mod\",\n                f'  app/aliased/mod: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Top level URI is defined so not a placeholder (not indented)\n            (\"project_a\", \"\", False, \"project_a\", 'project_a: \"{filename}\"'),\n            (\n                \"project_a\",\n                \"\",\n                True,\n                f\"{cg}project_a{cr}\",\n                f'{cg}project_a{cr}: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Parent and child URI is not defined, The URI is not turned green and no filename\n            (\"app/houdini\", \"  \", False, \"  app/houdini\", \"  app/houdini\"),\n            (\n                \"app/houdini\",\n                \"  \",\n                True,\n                \"  app/houdini\",\n                \"  app/houdini\",\n            ),\n        ),\n    )\n    def test_format_parser_uri(config_root, uncached_resolver, uri, pre, color, zero, one):\n        \"\"\"Test various uses of `hab.parsers.format_parser.FormatParser`.\"\"\"\n>       cfg = uncached_resolver.closest_config(uri)\n\ntests\\test_format_parser.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546BD490>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546BDA00>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app/aliased/mod-  -False-  app/aliased/mod-  app/aliased/mod: \"{filename}\"]",
      "lineno": 11,
      "outcome": "failed",
      "keywords": [
        "test_format_parser_uri[app/aliased/mod-  -False-  app/aliased/mod-  app/aliased/mod: \"{filename}\"]",
        "parametrize",
        "pytestmark",
        "app/aliased/mod-  -False-  app/aliased/mod-  app/aliased/mod: \"{filename}\"",
        "test_format_parser.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_format_parser.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nuncached_resolver = <hab.resolver.Resolver object at 0x00000166546BC410>\nuri = 'app/aliased/mod', pre = '  ', color = False, zero = '  app/aliased/mod'\none = '  app/aliased/mod: \"{filename}\"'\n\n    @pytest.mark.parametrize(\n        \"uri,pre,color,zero,one\",\n        (\n            # Top level URI placeholder is not indented\n            (\"app\", \"\", False, \"app\", \"app\"),\n            (\"app\", \"\", True, f\"{cg}app{cr}\", f\"{cg}app{cr}\"),\n            # Child URI is defined, The URI is not turned green and is indented\n            (\"app/aliased\", \"  \", False, \"  app/aliased\", '  app/aliased: \"{filename}\"'),\n            (\n                \"app/aliased\",\n                \"  \",\n                True,\n                \"  app/aliased\",\n                f'  app/aliased: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Grand-child URI is defined, The URI is not turned green and is indented\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                False,\n                \"  app/aliased/mod\",\n                '  app/aliased/mod: \"{filename}\"',\n            ),\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                True,\n                \"  app/aliased/mod\",\n                f'  app/aliased/mod: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Top level URI is defined so not a placeholder (not indented)\n            (\"project_a\", \"\", False, \"project_a\", 'project_a: \"{filename}\"'),\n            (\n                \"project_a\",\n                \"\",\n                True,\n                f\"{cg}project_a{cr}\",\n                f'{cg}project_a{cr}: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Parent and child URI is not defined, The URI is not turned green and no filename\n            (\"app/houdini\", \"  \", False, \"  app/houdini\", \"  app/houdini\"),\n            (\n                \"app/houdini\",\n                \"  \",\n                True,\n                \"  app/houdini\",\n                \"  app/houdini\",\n            ),\n        ),\n    )\n    def test_format_parser_uri(config_root, uncached_resolver, uri, pre, color, zero, one):\n        \"\"\"Test various uses of `hab.parsers.format_parser.FormatParser`.\"\"\"\n>       cfg = uncached_resolver.closest_config(uri)\n\ntests\\test_format_parser.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546BECF0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546BC410>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app/aliased/mod-  -True-  app/aliased/mod-  app/aliased/mod: \\x1b[33m\"{filename}\"\\x1b[39m]",
      "lineno": 11,
      "outcome": "failed",
      "keywords": [
        "test_format_parser_uri[app/aliased/mod-  -True-  app/aliased/mod-  app/aliased/mod: \\x1b[33m\"{filename}\"\\x1b[39m]",
        "parametrize",
        "pytestmark",
        "app/aliased/mod-  -True-  app/aliased/mod-  app/aliased/mod: \\x1b[33m\"{filename}\"\\x1b[39m",
        "test_format_parser.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_format_parser.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nuncached_resolver = <hab.resolver.Resolver object at 0x000001665477C590>\nuri = 'app/aliased/mod', pre = '  ', color = True, zero = '  app/aliased/mod'\none = '  app/aliased/mod: \\x1b[33m\"{filename}\"\\x1b[39m'\n\n    @pytest.mark.parametrize(\n        \"uri,pre,color,zero,one\",\n        (\n            # Top level URI placeholder is not indented\n            (\"app\", \"\", False, \"app\", \"app\"),\n            (\"app\", \"\", True, f\"{cg}app{cr}\", f\"{cg}app{cr}\"),\n            # Child URI is defined, The URI is not turned green and is indented\n            (\"app/aliased\", \"  \", False, \"  app/aliased\", '  app/aliased: \"{filename}\"'),\n            (\n                \"app/aliased\",\n                \"  \",\n                True,\n                \"  app/aliased\",\n                f'  app/aliased: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Grand-child URI is defined, The URI is not turned green and is indented\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                False,\n                \"  app/aliased/mod\",\n                '  app/aliased/mod: \"{filename}\"',\n            ),\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                True,\n                \"  app/aliased/mod\",\n                f'  app/aliased/mod: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Top level URI is defined so not a placeholder (not indented)\n            (\"project_a\", \"\", False, \"project_a\", 'project_a: \"{filename}\"'),\n            (\n                \"project_a\",\n                \"\",\n                True,\n                f\"{cg}project_a{cr}\",\n                f'{cg}project_a{cr}: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Parent and child URI is not defined, The URI is not turned green and no filename\n            (\"app/houdini\", \"  \", False, \"  app/houdini\", \"  app/houdini\"),\n            (\n                \"app/houdini\",\n                \"  \",\n                True,\n                \"  app/houdini\",\n                \"  app/houdini\",\n            ),\n        ),\n    )\n    def test_format_parser_uri(config_root, uncached_resolver, uri, pre, color, zero, one):\n        \"\"\"Test various uses of `hab.parsers.format_parser.FormatParser`.\"\"\"\n>       cfg = uncached_resolver.closest_config(uri)\n\ntests\\test_format_parser.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665477D8E0>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665477C590>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_format_parser.py::test_format_parser_uri[project_a--False-project_a-project_a: \"{filename}\"]",
      "lineno": 11,
      "outcome": "failed",
      "keywords": [
        "test_format_parser_uri[project_a--False-project_a-project_a: \"{filename}\"]",
        "parametrize",
        "pytestmark",
        "project_a--False-project_a-project_a: \"{filename}\"",
        "test_format_parser.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_format_parser.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nuncached_resolver = <hab.resolver.Resolver object at 0x000001665477DA90>\nuri = 'project_a', pre = '', color = False, zero = 'project_a'\none = 'project_a: \"{filename}\"'\n\n    @pytest.mark.parametrize(\n        \"uri,pre,color,zero,one\",\n        (\n            # Top level URI placeholder is not indented\n            (\"app\", \"\", False, \"app\", \"app\"),\n            (\"app\", \"\", True, f\"{cg}app{cr}\", f\"{cg}app{cr}\"),\n            # Child URI is defined, The URI is not turned green and is indented\n            (\"app/aliased\", \"  \", False, \"  app/aliased\", '  app/aliased: \"{filename}\"'),\n            (\n                \"app/aliased\",\n                \"  \",\n                True,\n                \"  app/aliased\",\n                f'  app/aliased: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Grand-child URI is defined, The URI is not turned green and is indented\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                False,\n                \"  app/aliased/mod\",\n                '  app/aliased/mod: \"{filename}\"',\n            ),\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                True,\n                \"  app/aliased/mod\",\n                f'  app/aliased/mod: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Top level URI is defined so not a placeholder (not indented)\n            (\"project_a\", \"\", False, \"project_a\", 'project_a: \"{filename}\"'),\n            (\n                \"project_a\",\n                \"\",\n                True,\n                f\"{cg}project_a{cr}\",\n                f'{cg}project_a{cr}: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Parent and child URI is not defined, The URI is not turned green and no filename\n            (\"app/houdini\", \"  \", False, \"  app/houdini\", \"  app/houdini\"),\n            (\n                \"app/houdini\",\n                \"  \",\n                True,\n                \"  app/houdini\",\n                \"  app/houdini\",\n            ),\n        ),\n    )\n    def test_format_parser_uri(config_root, uncached_resolver, uri, pre, color, zero, one):\n        \"\"\"Test various uses of `hab.parsers.format_parser.FormatParser`.\"\"\"\n>       cfg = uncached_resolver.closest_config(uri)\n\ntests\\test_format_parser.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665477FA70>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665477DA90>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_format_parser.py::test_format_parser_uri[project_a--True-\\x1b[32mproject_a\\x1b[39m-\\x1b[32mproject_a\\x1b[39m: \\x1b[33m\"{filename}\"\\x1b[39m]",
      "lineno": 11,
      "outcome": "failed",
      "keywords": [
        "test_format_parser_uri[project_a--True-\\x1b[32mproject_a\\x1b[39m-\\x1b[32mproject_a\\x1b[39m: \\x1b[33m\"{filename}\"\\x1b[39m]",
        "parametrize",
        "pytestmark",
        "project_a--True-\\x1b[32mproject_a\\x1b[39m-\\x1b[32mproject_a\\x1b[39m: \\x1b[33m\"{filename}\"\\x1b[39m",
        "test_format_parser.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_format_parser.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nuncached_resolver = <hab.resolver.Resolver object at 0x00000166546BEE70>\nuri = 'project_a', pre = '', color = True, zero = '\\x1b[32mproject_a\\x1b[39m'\none = '\\x1b[32mproject_a\\x1b[39m: \\x1b[33m\"{filename}\"\\x1b[39m'\n\n    @pytest.mark.parametrize(\n        \"uri,pre,color,zero,one\",\n        (\n            # Top level URI placeholder is not indented\n            (\"app\", \"\", False, \"app\", \"app\"),\n            (\"app\", \"\", True, f\"{cg}app{cr}\", f\"{cg}app{cr}\"),\n            # Child URI is defined, The URI is not turned green and is indented\n            (\"app/aliased\", \"  \", False, \"  app/aliased\", '  app/aliased: \"{filename}\"'),\n            (\n                \"app/aliased\",\n                \"  \",\n                True,\n                \"  app/aliased\",\n                f'  app/aliased: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Grand-child URI is defined, The URI is not turned green and is indented\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                False,\n                \"  app/aliased/mod\",\n                '  app/aliased/mod: \"{filename}\"',\n            ),\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                True,\n                \"  app/aliased/mod\",\n                f'  app/aliased/mod: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Top level URI is defined so not a placeholder (not indented)\n            (\"project_a\", \"\", False, \"project_a\", 'project_a: \"{filename}\"'),\n            (\n                \"project_a\",\n                \"\",\n                True,\n                f\"{cg}project_a{cr}\",\n                f'{cg}project_a{cr}: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Parent and child URI is not defined, The URI is not turned green and no filename\n            (\"app/houdini\", \"  \", False, \"  app/houdini\", \"  app/houdini\"),\n            (\n                \"app/houdini\",\n                \"  \",\n                True,\n                \"  app/houdini\",\n                \"  app/houdini\",\n            ),\n        ),\n    )\n    def test_format_parser_uri(config_root, uncached_resolver, uri, pre, color, zero, one):\n        \"\"\"Test various uses of `hab.parsers.format_parser.FormatParser`.\"\"\"\n>       cfg = uncached_resolver.closest_config(uri)\n\ntests\\test_format_parser.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546BF680>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546BEE70>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app/houdini-  -False-  app/houdini-  app/houdini]",
      "lineno": 11,
      "outcome": "failed",
      "keywords": [
        "test_format_parser_uri[app/houdini-  -False-  app/houdini-  app/houdini]",
        "parametrize",
        "pytestmark",
        "app/houdini-  -False-  app/houdini-  app/houdini",
        "test_format_parser.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_format_parser.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nuncached_resolver = <hab.resolver.Resolver object at 0x000001665477E900>\nuri = 'app/houdini', pre = '  ', color = False, zero = '  app/houdini'\none = '  app/houdini'\n\n    @pytest.mark.parametrize(\n        \"uri,pre,color,zero,one\",\n        (\n            # Top level URI placeholder is not indented\n            (\"app\", \"\", False, \"app\", \"app\"),\n            (\"app\", \"\", True, f\"{cg}app{cr}\", f\"{cg}app{cr}\"),\n            # Child URI is defined, The URI is not turned green and is indented\n            (\"app/aliased\", \"  \", False, \"  app/aliased\", '  app/aliased: \"{filename}\"'),\n            (\n                \"app/aliased\",\n                \"  \",\n                True,\n                \"  app/aliased\",\n                f'  app/aliased: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Grand-child URI is defined, The URI is not turned green and is indented\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                False,\n                \"  app/aliased/mod\",\n                '  app/aliased/mod: \"{filename}\"',\n            ),\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                True,\n                \"  app/aliased/mod\",\n                f'  app/aliased/mod: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Top level URI is defined so not a placeholder (not indented)\n            (\"project_a\", \"\", False, \"project_a\", 'project_a: \"{filename}\"'),\n            (\n                \"project_a\",\n                \"\",\n                True,\n                f\"{cg}project_a{cr}\",\n                f'{cg}project_a{cr}: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Parent and child URI is not defined, The URI is not turned green and no filename\n            (\"app/houdini\", \"  \", False, \"  app/houdini\", \"  app/houdini\"),\n            (\n                \"app/houdini\",\n                \"  \",\n                True,\n                \"  app/houdini\",\n                \"  app/houdini\",\n            ),\n        ),\n    )\n    def test_format_parser_uri(config_root, uncached_resolver, uri, pre, color, zero, one):\n        \"\"\"Test various uses of `hab.parsers.format_parser.FormatParser`.\"\"\"\n>       cfg = uncached_resolver.closest_config(uri)\n\ntests\\test_format_parser.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665477E630>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665477E900>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_format_parser.py::test_format_parser_uri[app/houdini-  -True-  app/houdini-  app/houdini]",
      "lineno": 11,
      "outcome": "failed",
      "keywords": [
        "test_format_parser_uri[app/houdini-  -True-  app/houdini-  app/houdini]",
        "parametrize",
        "pytestmark",
        "app/houdini-  -True-  app/houdini-  app/houdini",
        "test_format_parser.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_format_parser.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nuncached_resolver = <hab.resolver.Resolver object at 0x000001665477C320>\nuri = 'app/houdini', pre = '  ', color = True, zero = '  app/houdini'\none = '  app/houdini'\n\n    @pytest.mark.parametrize(\n        \"uri,pre,color,zero,one\",\n        (\n            # Top level URI placeholder is not indented\n            (\"app\", \"\", False, \"app\", \"app\"),\n            (\"app\", \"\", True, f\"{cg}app{cr}\", f\"{cg}app{cr}\"),\n            # Child URI is defined, The URI is not turned green and is indented\n            (\"app/aliased\", \"  \", False, \"  app/aliased\", '  app/aliased: \"{filename}\"'),\n            (\n                \"app/aliased\",\n                \"  \",\n                True,\n                \"  app/aliased\",\n                f'  app/aliased: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Grand-child URI is defined, The URI is not turned green and is indented\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                False,\n                \"  app/aliased/mod\",\n                '  app/aliased/mod: \"{filename}\"',\n            ),\n            (\n                \"app/aliased/mod\",\n                \"  \",\n                True,\n                \"  app/aliased/mod\",\n                f'  app/aliased/mod: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Top level URI is defined so not a placeholder (not indented)\n            (\"project_a\", \"\", False, \"project_a\", 'project_a: \"{filename}\"'),\n            (\n                \"project_a\",\n                \"\",\n                True,\n                f\"{cg}project_a{cr}\",\n                f'{cg}project_a{cr}: {cy}\"{{filename}}\"{cr}',\n            ),\n            # Parent and child URI is not defined, The URI is not turned green and no filename\n            (\"app/houdini\", \"  \", False, \"  app/houdini\", \"  app/houdini\"),\n            (\n                \"app/houdini\",\n                \"  \",\n                True,\n                \"  app/houdini\",\n                \"  app/houdini\",\n            ),\n        ),\n    )\n    def test_format_parser_uri(config_root, uncached_resolver, uri, pre, color, zero, one):\n        \"\"\"Test various uses of `hab.parsers.format_parser.FormatParser`.\"\"\"\n>       cfg = uncached_resolver.closest_config(uri)\n\ntests\\test_format_parser.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665477DC70>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665477C320>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_format_parser.py::test_dump_forest_callable",
      "lineno": 76,
      "outcome": "failed",
      "keywords": [
        "test_dump_forest_callable",
        "test_format_parser.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_format_parser.py",
            "lineno": 82,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x000001665477FC50>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\n\n    def test_dump_forest_callable(uncached_resolver, config_root):\n        \"\"\"Check that Resolver.dump_forest handles passing a callable to fmt.\"\"\"\n        formatter = FormatParser(1, color=False)\n        result = []\n        for line in uncached_resolver.dump_forest(\n>           uncached_resolver.distros, attr=\"name\", fmt=formatter.format, truncate=3\n        ):\n\ntests\\test_format_parser.py:82: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x000001665477F4A0>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665477FC50>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_formatter.py::test_env_format[sh-_V_a-var_:_$INVALID_-_V_$VALID_:_$INVALID_]",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_env_format[sh-_V_a-var_:_$INVALID_-_V_$VALID_:_$INVALID_]",
        "parametrize",
        "pytestmark",
        "sh-_V_a-var_:_$INVALID_-_V_$VALID_:_$INVALID_",
        "test_formatter.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_formatter.py::test_env_format[shwin-_V_a-var_:_$INVALID_-_V_$VALID_:_$INVALID_]",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_env_format[shwin-_V_a-var_:_$INVALID_-_V_$VALID_:_$INVALID_]",
        "parametrize",
        "pytestmark",
        "shwin-_V_a-var_:_$INVALID_-_V_$VALID_:_$INVALID_",
        "test_formatter.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_formatter.py::test_env_format[ps-_V_a-var_;_$env:INVALID_-_V_$env:VALID_;_$env:INVALID_]",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_env_format[ps-_V_a-var_;_$env:INVALID_-_V_$env:VALID_;_$env:INVALID_]",
        "parametrize",
        "pytestmark",
        "ps-_V_a-var_;_$env:INVALID_-_V_$env:VALID_;_$env:INVALID_",
        "test_formatter.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_formatter.py::test_env_format[batch-_V_a-var_;_%INVALID%_-_V_%VALID%_;_%INVALID%_]",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_env_format[batch-_V_a-var_;_%INVALID%_-_V_%VALID%_;_%INVALID%_]",
        "parametrize",
        "pytestmark",
        "batch-_V_a-var_;_%INVALID%_-_V_%VALID%_;_%INVALID%_",
        "test_formatter.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_formatter.py::test_env_format[None-_V_a-var_{;}_{INVALID!e}_-_V_{VALID!e}_{;}_{INVALID!e}_]",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_env_format[None-_V_a-var_{;}_{INVALID!e}_-_V_{VALID!e}_{;}_{INVALID!e}_]",
        "parametrize",
        "pytestmark",
        "None-_V_a-var_{;}_{INVALID!e}_-_V_{VALID!e}_{;}_{INVALID!e}_",
        "test_formatter.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_formatter.py::test_language_from_ext",
      "lineno": 43,
      "outcome": "passed",
      "keywords": [
        "test_language_from_ext",
        "test_formatter.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_formatter.py::test_format_environment_value",
      "lineno": 64,
      "outcome": "failed",
      "keywords": [
        "test_format_environment_value",
        "test_formatter.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_formatter.py",
            "lineno": 67,
            "message": ""
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x000001665477E900>\n\n    def test_format_environment_value(uncached_resolver):\n        forest = {}\n>       config = Config(forest, uncached_resolver)\n\ntests\\test_formatter.py:67: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546BC830>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665477E900>), kwargs = {}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_freeze.py::test_json_dumps",
      "lineno": 31,
      "outcome": "passed",
      "keywords": [
        "test_json_dumps",
        "test_freeze.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_freeze.py::test_freeze[win32-;]",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_freeze[win32-;]",
        "parametrize",
        "pytestmark",
        "win32-;",
        "test_freeze.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_freeze.py",
            "lineno": 68,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x00000166547F9670>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nplatform = 'win32', pathsep = ';'\n\n    @pytest.mark.parametrize(\"platform,pathsep\", ((\"win32\", \";\"), (\"linux\", \":\")))\n    def test_freeze(monkeypatch, config_root, platform, pathsep):\n        monkeypatch.setattr(utils, \"Platform\", utils.WinPlatform)\n        monkeypatch.setattr(os, \"pathsep\", pathsep)\n        site = Site([config_root / \"site_main.json\"])\n        resolver = Resolver(site=site)\n        cfg_root = utils.path_forward_slash(config_root)\n    \n        # Add a platform_path_maps mapping to convert the current hab checkout path\n        # to a generic know path on the other platform for uniform testing.\n        mappings = site.frozen_data[site.platform][\"platform_path_maps\"]\n        mappings[\"local-hab\"] = {\n            \"linux\": PurePosixPath(\"/hab\"),\n            \"windows\": PureWindowsPath(\"c:/\"),\n        }\n        # Preserve the current platform's path so it matches the frozen output\n        if site.platform == \"windows\":\n            mappings[\"local-hab\"][\"windows\"] = PureWindowsPath(cfg_root)\n        else:\n            mappings[\"local-hab\"][site.platform] = PurePosixPath(cfg_root)\n    \n        # Resolve the URI for frozen testing\n>       cfg = resolver.resolve(\"not_set/distros\")\n\ntests\\test_freeze.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166547F8E30>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166547FA9C0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_freeze.py::test_freeze[linux-:]",
      "lineno": 45,
      "outcome": "failed",
      "keywords": [
        "test_freeze[linux-:]",
        "parametrize",
        "pytestmark",
        "linux-:",
        "test_freeze.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_freeze.py",
            "lineno": 68,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x00000166547FBE30>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nplatform = 'linux', pathsep = ':'\n\n    @pytest.mark.parametrize(\"platform,pathsep\", ((\"win32\", \";\"), (\"linux\", \":\")))\n    def test_freeze(monkeypatch, config_root, platform, pathsep):\n        monkeypatch.setattr(utils, \"Platform\", utils.WinPlatform)\n        monkeypatch.setattr(os, \"pathsep\", pathsep)\n        site = Site([config_root / \"site_main.json\"])\n        resolver = Resolver(site=site)\n        cfg_root = utils.path_forward_slash(config_root)\n    \n        # Add a platform_path_maps mapping to convert the current hab checkout path\n        # to a generic know path on the other platform for uniform testing.\n        mappings = site.frozen_data[site.platform][\"platform_path_maps\"]\n        mappings[\"local-hab\"] = {\n            \"linux\": PurePosixPath(\"/hab\"),\n            \"windows\": PureWindowsPath(\"c:/\"),\n        }\n        # Preserve the current platform's path so it matches the frozen output\n        if site.platform == \"windows\":\n            mappings[\"local-hab\"][\"windows\"] = PureWindowsPath(cfg_root)\n        else:\n            mappings[\"local-hab\"][site.platform] = PurePosixPath(cfg_root)\n    \n        # Resolve the URI for frozen testing\n>       cfg = resolver.resolve(\"not_set/distros\")\n\ntests\\test_freeze.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166547F8D40>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166547FB680>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_freeze.py::test_unfreeze[uncached]",
      "lineno": 111,
      "outcome": "failed",
      "keywords": [
        "test_unfreeze[uncached]",
        "uncached",
        "test_freeze.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_freeze.py",
            "lineno": 117,
            "message": ""
          },
          {
            "path": "hab\\parsers\\unfrozen_config.py",
            "lineno": 23,
            "message": "in __init__"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nresolver = <hab.resolver.Resolver object at 0x00000166547FA030>\n\n    def test_unfreeze(config_root, resolver):\n        check_file = config_root / \"frozen.json\"\n    \n        # Note: For this test, we don't need to worry about \"{config_root}\" templates.\n        frozen_config = utils.json.load(check_file.open())\n>       cfg = UnfrozenConfig(frozen_config, resolver)\n\ntests\\test_freeze.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\parsers\\unfrozen_config.py:23: in __init__\n    super().__init__(None, resolver)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.unfrozen_config.UnfrozenConfig object at 0x00000166547FA7B0>\nargs = (None, <hab.resolver.Resolver object at 0x00000166547FA030>), kwargs = {}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_freeze.py::test_unfreeze[cached]",
      "lineno": 111,
      "outcome": "error",
      "keywords": [
        "test_unfreeze[cached]",
        "cached",
        "test_freeze.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_unfreeze[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_freeze.py::test_decode_freeze",
      "lineno": 164,
      "outcome": "passed",
      "keywords": [
        "test_decode_freeze",
        "test_freeze.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_freeze.py::test_encode_freeze[uncached]",
      "lineno": 198,
      "outcome": "failed",
      "keywords": [
        "test_encode_freeze[uncached]",
        "uncached",
        "test_freeze.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_freeze.py",
            "lineno": 200,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nresolver = <hab.resolver.Resolver object at 0x00000166547FAE10>\n\n    def test_encode_freeze(config_root, resolver):\n>       cfg = resolver.resolve(\"not_set/no_distros\")\n\ntests\\test_freeze.py:200: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166547F9C10>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166547FAE10>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_freeze.py::test_encode_freeze[cached]",
      "lineno": 198,
      "outcome": "error",
      "keywords": [
        "test_encode_freeze[cached]",
        "cached",
        "test_freeze.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_encode_freeze[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_freeze.py::test_resolver_freeze_configs",
      "lineno": 234,
      "outcome": "failed",
      "keywords": [
        "test_resolver_freeze_configs",
        "test_freeze.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_freeze.py",
            "lineno": 244,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 281,
            "message": "in freeze_configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "tmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_resolver_freeze_configs0')\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nuncached_resolver = <hab.resolver.Resolver object at 0x000001665486D1F0>\nhelpers = <class 'conftest.Helpers'>\n\n    def test_resolver_freeze_configs(tmpdir, config_root, uncached_resolver, helpers):\n        \"\"\"Test `Resolver.freeze_configs`.\n    \n        This method generates the frozen config for all non-placeholder URI's hab\n        finds. This makes it fairly easy to diff bulk config changes as json.\n    \n        It checks the output against `tests/resolver_freeze_configs.json`. For testing\n        simplicity, this file has had its aliases and environment sections removed.\n        \"\"\"\n>       result = uncached_resolver.freeze_configs()\n\ntests\\test_freeze.py:244: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:281: in freeze_configs\n    for node in self.dump_forest(self.configs, attr=None):\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665486D370>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665486D1F0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::test_launch[uncached]",
      "lineno": 51,
      "outcome": "failed",
      "keywords": [
        "test_launch[uncached]",
        "uncached",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166547F8D10>\n\n    def test_launch(resolver):\n        \"\"\"Check the Config.launch method.\"\"\"\n>       cfg = resolver.resolve(\"app/aliased/mod\")\n\ntests\\test_launch.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166547F8DD0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166547F8D10>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::test_launch[cached]",
      "lineno": 51,
      "outcome": "error",
      "keywords": [
        "test_launch[cached]",
        "cached",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_launch[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::test_launch_str[uncached]",
      "lineno": 74,
      "outcome": "failed",
      "keywords": [
        "test_launch_str[uncached]",
        "__wrapped__",
        "uncached",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 77,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016654874080>\n\n    @missing_annotations_hack\n    def test_launch_str(resolver):\n>       cfg = resolver.resolve(\"app/aliased/mod\")\n\ntests\\test_launch.py:77: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654874380>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016654874080>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::test_launch_str[cached]",
      "lineno": 74,
      "outcome": "error",
      "keywords": [
        "test_launch_str[cached]",
        "__wrapped__",
        "cached",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_launch_str[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::test_pythonw[uncached]",
      "lineno": 99,
      "outcome": "failed",
      "keywords": [
        "test_pythonw[uncached]",
        "skipif",
        "pytestmark",
        "uncached",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 103,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001665486ECC0>\nresolver = <hab.resolver.Resolver object at 0x000001665486EFF0>\n\n    @pytest.mark.skipif(sys.platform != \"win32\", reason=\"only applies on windows\")\n    def test_pythonw(monkeypatch, resolver):\n        \"\"\"Check that sys.stdin is set if using pythonw.\"\"\"\n>       cfg = resolver.resolve(\"app/aliased/mod\")\n\ntests\\test_launch.py:103: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166547F92B0>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665486EFF0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::test_pythonw[cached]",
      "lineno": 99,
      "outcome": "error",
      "keywords": [
        "test_pythonw[cached]",
        "skipif",
        "pytestmark",
        "cached",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_pythonw[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::test_invalid_alias[uncached]",
      "lineno": 115,
      "outcome": "failed",
      "keywords": [
        "test_invalid_alias[uncached]",
        "uncached",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 117,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166547FAEA0>\n\n    def test_invalid_alias(resolver):\n>       cfg = resolver.resolve(\"app/aliased/mod\")\n\ntests\\test_launch.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166547F8770>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166547FAEA0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::test_invalid_alias[cached]",
      "lineno": 115,
      "outcome": "error",
      "keywords": [
        "test_invalid_alias[cached]",
        "cached",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_invalid_alias[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::test_cls_no_entry_point[uncached]",
      "lineno": 131,
      "outcome": "failed",
      "keywords": [
        "test_cls_no_entry_point[uncached]",
        "uncached",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 139,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166546B70E0>\n\n    def test_cls_no_entry_point(resolver):\n        \"\"\"Check that if no entry point is defined, `hab.launcher.Launcher` is\n        used to launch the alias.\n        \"\"\"\n        entry_points = resolver.site.entry_points_for_group(\"hab.launch_cls\")\n        assert len(entry_points) == 0\n    \n>       cfg = resolver.resolve(\"app/aliased/mod\")\n\ntests\\test_launch.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546B6300>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546B70E0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::test_cls_no_entry_point[cached]",
      "lineno": 131,
      "outcome": "error",
      "keywords": [
        "test_cls_no_entry_point[cached]",
        "cached",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_cls_no_entry_point[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::test_cls_entry_point",
      "lineno": 150,
      "outcome": "failed",
      "keywords": [
        "test_cls_entry_point",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 165,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\n\n    def test_cls_entry_point(config_root):\n        \"\"\"Check that if an entry point is defined, it is used unless overridden.\"\"\"\n        site = Site(\n            [config_root / \"site/site_entry_point_a.json\", config_root / \"site_main.json\"]\n        )\n        entry_points = site.entry_points_for_group(\"hab.launch_cls\")\n        assert len(entry_points) == 1\n        # Test that the `test-gui` `hab.cli` entry point is handled correctly\n        ep = entry_points[0]\n        assert ep.name == \"subprocess\"\n        assert ep.group == \"hab.launch_cls\"\n        assert ep.value == \"subprocess:Popen\"\n    \n        resolver = Resolver(site=site)\n>       cfg = resolver.resolve(\"app/aliased/mod\")\n\ntests\\test_launch.py:165: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546B57C0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546B5FA0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::test_alias_entry_point",
      "lineno": 175,
      "outcome": "failed",
      "keywords": [
        "test_alias_entry_point",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 183,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\n\n    def test_alias_entry_point(config_root):\n        \"\"\"Check that if an entry point is defined on a complex alias, it is used.\"\"\"\n        site = Site(\n            [config_root / \"site/site_entry_point_a.json\", config_root / \"site_main.json\"]\n        )\n    \n        resolver = Resolver(site=site)\n>       cfg = resolver.resolve(\"app/aliased/mod\")\n\ntests\\test_launch.py:183: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546A24E0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546A1700>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bat[5]",
      "lineno": 220,
      "outcome": "failed",
      "keywords": [
        "test_bat[5]",
        "skipif",
        "__wrapped__",
        "pytestmark",
        "5",
        "TestCliExitCodes",
        "parametrize",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\tests\\test_launch.py",
          "lineno": 237,
          "message": "assert \"Hab encounte...a'\\n\\n\\x1b[0m\" == \"Running...\\n...(built-in)>\\n\"\n  \n  - Running...\n  - <module 'sys' (built-in)>\n  + Hab encountered an error:\n  + ModuleNotFoundError: No module named 'importlib_metadata'\n  + \n  + \u001b[0m"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 237,
            "message": "AssertionError"
          }
        ],
        "longrepr": "self = <test_launch.TestCliExitCodes object at 0x00000166542304A0>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nexit_code = 5\n\n    @pytest.mark.skipif(sys.platform != \"win32\", reason=\"only applies on windows\")\n    @missing_annotations_hack\n    def test_bat(self, config_root, exit_code):\n        hab_bin = (config_root / \"..\" / \"bin\" / \"hab.bat\").resolve()\n        # fmt: off\n        cmd = [\n            str(hab_bin), \"--site\", str(config_root / \"site_main.json\"),\n            *self.sub_cmd,\n            self.py_cmd.format(code=exit_code),\n        ]\n        # fmt: on\n    \n        # Run the hab command in a subprocess\n        proc = subprocess.run(cmd, **self.run_kwargs)\n    \n        # Check that the print statement was actually run\n>       assert proc.stdout == self.output_text\nE       assert \"Hab encounte...a'\\n\\n\\x1b[0m\" == \"Running...\\n...(built-in)>\\n\"\nE         \nE         - Running...\nE         - <module 'sys' (built-in)>\nE         + Hab encountered an error:\nE         + ModuleNotFoundError: No module named 'importlib_metadata'\nE         + \nE         + \u001b[0m\n\ntests\\test_launch.py:237: AssertionError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bat[4]",
      "lineno": 220,
      "outcome": "failed",
      "keywords": [
        "test_bat[4]",
        "skipif",
        "__wrapped__",
        "pytestmark",
        "4",
        "TestCliExitCodes",
        "parametrize",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\tests\\test_launch.py",
          "lineno": 237,
          "message": "assert \"Hab encounte...a'\\n\\n\\x1b[0m\" == \"Running...\\n...(built-in)>\\n\"\n  \n  - Running...\n  - <module 'sys' (built-in)>\n  + Hab encountered an error:\n  + ModuleNotFoundError: No module named 'importlib_metadata'\n  + \n  + \u001b[0m"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 237,
            "message": "AssertionError"
          }
        ],
        "longrepr": "self = <test_launch.TestCliExitCodes object at 0x0000016654230680>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nexit_code = 4\n\n    @pytest.mark.skipif(sys.platform != \"win32\", reason=\"only applies on windows\")\n    @missing_annotations_hack\n    def test_bat(self, config_root, exit_code):\n        hab_bin = (config_root / \"..\" / \"bin\" / \"hab.bat\").resolve()\n        # fmt: off\n        cmd = [\n            str(hab_bin), \"--site\", str(config_root / \"site_main.json\"),\n            *self.sub_cmd,\n            self.py_cmd.format(code=exit_code),\n        ]\n        # fmt: on\n    \n        # Run the hab command in a subprocess\n        proc = subprocess.run(cmd, **self.run_kwargs)\n    \n        # Check that the print statement was actually run\n>       assert proc.stdout == self.output_text\nE       assert \"Hab encounte...a'\\n\\n\\x1b[0m\" == \"Running...\\n...(built-in)>\\n\"\nE         \nE         - Running...\nE         - <module 'sys' (built-in)>\nE         + Hab encountered an error:\nE         + ModuleNotFoundError: No module named 'importlib_metadata'\nE         + \nE         + \u001b[0m\n\ntests\\test_launch.py:237: AssertionError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bat[0]",
      "lineno": 220,
      "outcome": "failed",
      "keywords": [
        "test_bat[0]",
        "skipif",
        "__wrapped__",
        "pytestmark",
        "0",
        "TestCliExitCodes",
        "parametrize",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py",
          "lineno": 1630,
          "message": "subprocess.TimeoutExpired: Command '['D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\bin\\\\hab.bat', '--site', 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\site_main.json', 'launch', 'app/aliased', 'as_str', '-c', \"print('Running...');import sys;print(sys);sys.exit(0)\"]' timed out after 5 seconds"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 234,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py",
            "lineno": 550,
            "message": "in run"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py",
            "lineno": 1209,
            "message": "in communicate"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py",
            "lineno": 1630,
            "message": "TimeoutExpired"
          }
        ],
        "longrepr": "self = <test_launch.TestCliExitCodes object at 0x0000016654230740>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nexit_code = 0\n\n    @pytest.mark.skipif(sys.platform != \"win32\", reason=\"only applies on windows\")\n    @missing_annotations_hack\n    def test_bat(self, config_root, exit_code):\n        hab_bin = (config_root / \"..\" / \"bin\" / \"hab.bat\").resolve()\n        # fmt: off\n        cmd = [\n            str(hab_bin), \"--site\", str(config_root / \"site_main.json\"),\n            *self.sub_cmd,\n            self.py_cmd.format(code=exit_code),\n        ]\n        # fmt: on\n    \n        # Run the hab command in a subprocess\n>       proc = subprocess.run(cmd, **self.run_kwargs)\n\ntests\\test_launch.py:234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py:550: in run\n    stdout, stderr = process.communicate(input, timeout=timeout)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py:1209: in communicate\n    stdout, stderr = self._communicate(input, endtime, timeout)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Popen: returncode: 1 args: ['D:\\\\repos\\\\blurstudio@hab__177503df__pygments_...>\ninput = None, endtime = 232362.406, orig_timeout = 5\n\n    def _communicate(self, input, endtime, orig_timeout):\n        # Start reader threads feeding into a list hanging off of this\n        # object, unless they've already been started.\n        if self.stdout and not hasattr(self, \"_stdout_buff\"):\n            self._stdout_buff = []\n            self.stdout_thread = \\\n                    threading.Thread(target=self._readerthread,\n                                     args=(self.stdout, self._stdout_buff))\n            self.stdout_thread.daemon = True\n            self.stdout_thread.start()\n        if self.stderr and not hasattr(self, \"_stderr_buff\"):\n            self._stderr_buff = []\n            self.stderr_thread = \\\n                    threading.Thread(target=self._readerthread,\n                                     args=(self.stderr, self._stderr_buff))\n            self.stderr_thread.daemon = True\n            self.stderr_thread.start()\n    \n        if self.stdin:\n            self._stdin_write(input)\n    \n        # Wait for the reader threads, or time out.  If we time out, the\n        # threads remain reading and the fds left open in case the user\n        # calls communicate again.\n        if self.stdout is not None:\n            self.stdout_thread.join(self._remaining_time(endtime))\n            if self.stdout_thread.is_alive():\n>               raise TimeoutExpired(self.args, orig_timeout)\nE               subprocess.TimeoutExpired: Command '['D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\bin\\\\hab.bat', '--site', 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\site_main.json', 'launch', 'app/aliased', 'as_str', '-c', \"print('Running...');import sys;print(sys);sys.exit(0)\"]' timed out after 5 seconds\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py:1630: TimeoutExpired"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes::test_ps1[5]",
      "lineno": 239,
      "outcome": "failed",
      "keywords": [
        "test_ps1[5]",
        "skipif",
        "__wrapped__",
        "pytestmark",
        "5",
        "TestCliExitCodes",
        "parametrize",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py",
          "lineno": 1630,
          "message": "subprocess.TimeoutExpired: Command '['powershell.exe', '-ExecutionPolicy', 'Unrestricted', '-File', 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\bin\\\\hab.ps1', '--site', 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\site_main.json', 'launch', 'app/aliased', 'as_str', '-c', '\"print(\\'Running...\\');import sys;print(sys);sys.exit(5)\"']' timed out after 5 seconds"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 260,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py",
            "lineno": 550,
            "message": "in run"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py",
            "lineno": 1209,
            "message": "in communicate"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py",
            "lineno": 1630,
            "message": "TimeoutExpired"
          }
        ],
        "longrepr": "self = <test_launch.TestCliExitCodes object at 0x0000016654230920>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nexit_code = 5\n\n    @pytest.mark.skipif(sys.platform != \"win32\", reason=\"only applies on windows\")\n    @pytest.mark.skipif(\n        os.getenv(\"GITHUB_ACTIONS\") == \"true\",\n        reason=\"PowerShell tests timeout when run in a github action\",\n    )\n    @missing_annotations_hack\n    def test_ps1(self, config_root, exit_code):\n        # -File is needed to get the exit-code from powershell, and requires a full path\n        script = (config_root / \"..\" / \"bin\" / \"hab.ps1\").resolve()\n        # fmt: off\n        cmd = [\n            \"powershell.exe\", \"-ExecutionPolicy\", \"Unrestricted\",\n            \"-File\", str(script),\n            \"--site\", str(config_root / \"site_main.json\"),\n            *self.sub_cmd,\n            f\"\\\"{self.py_cmd.format(code=exit_code)}\\\"\",\n        ]\n        # fmt: on\n    \n        # Run the hab command in a subprocess\n>       proc = subprocess.run(cmd, **self.run_kwargs)\n\ntests\\test_launch.py:260: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py:550: in run\n    stdout, stderr = process.communicate(input, timeout=timeout)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py:1209: in communicate\n    stdout, stderr = self._communicate(input, endtime, timeout)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Popen: returncode: 1 args: ['powershell.exe', '-ExecutionPolicy', 'Unrestri...>\ninput = None, endtime = 232367.906, orig_timeout = 5\n\n    def _communicate(self, input, endtime, orig_timeout):\n        # Start reader threads feeding into a list hanging off of this\n        # object, unless they've already been started.\n        if self.stdout and not hasattr(self, \"_stdout_buff\"):\n            self._stdout_buff = []\n            self.stdout_thread = \\\n                    threading.Thread(target=self._readerthread,\n                                     args=(self.stdout, self._stdout_buff))\n            self.stdout_thread.daemon = True\n            self.stdout_thread.start()\n        if self.stderr and not hasattr(self, \"_stderr_buff\"):\n            self._stderr_buff = []\n            self.stderr_thread = \\\n                    threading.Thread(target=self._readerthread,\n                                     args=(self.stderr, self._stderr_buff))\n            self.stderr_thread.daemon = True\n            self.stderr_thread.start()\n    \n        if self.stdin:\n            self._stdin_write(input)\n    \n        # Wait for the reader threads, or time out.  If we time out, the\n        # threads remain reading and the fds left open in case the user\n        # calls communicate again.\n        if self.stdout is not None:\n            self.stdout_thread.join(self._remaining_time(endtime))\n            if self.stdout_thread.is_alive():\n>               raise TimeoutExpired(self.args, orig_timeout)\nE               subprocess.TimeoutExpired: Command '['powershell.exe', '-ExecutionPolicy', 'Unrestricted', '-File', 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\bin\\\\hab.ps1', '--site', 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\site_main.json', 'launch', 'app/aliased', 'as_str', '-c', '\"print(\\'Running...\\');import sys;print(sys);sys.exit(5)\"']' timed out after 5 seconds\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\subprocess.py:1630: TimeoutExpired"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes::test_ps1[4]",
      "lineno": 239,
      "outcome": "failed",
      "keywords": [
        "test_ps1[4]",
        "skipif",
        "__wrapped__",
        "pytestmark",
        "4",
        "TestCliExitCodes",
        "parametrize",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\tests\\test_launch.py",
          "lineno": 263,
          "message": "assert \"Hab encounte...a'\\n\\n\\x1b[0m\" == \"Running...\\n...(built-in)>\\n\"\n  \n  - Running...\n  - <module 'sys' (built-in)>\n  + Hab encountered an error:\n  + ModuleNotFoundError: No module named 'importlib_metadata'\n  + \n  + \u001b[0m"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 263,
            "message": "AssertionError"
          }
        ],
        "longrepr": "self = <test_launch.TestCliExitCodes object at 0x0000016654230B00>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nexit_code = 4\n\n    @pytest.mark.skipif(sys.platform != \"win32\", reason=\"only applies on windows\")\n    @pytest.mark.skipif(\n        os.getenv(\"GITHUB_ACTIONS\") == \"true\",\n        reason=\"PowerShell tests timeout when run in a github action\",\n    )\n    @missing_annotations_hack\n    def test_ps1(self, config_root, exit_code):\n        # -File is needed to get the exit-code from powershell, and requires a full path\n        script = (config_root / \"..\" / \"bin\" / \"hab.ps1\").resolve()\n        # fmt: off\n        cmd = [\n            \"powershell.exe\", \"-ExecutionPolicy\", \"Unrestricted\",\n            \"-File\", str(script),\n            \"--site\", str(config_root / \"site_main.json\"),\n            *self.sub_cmd,\n            f\"\\\"{self.py_cmd.format(code=exit_code)}\\\"\",\n        ]\n        # fmt: on\n    \n        # Run the hab command in a subprocess\n        proc = subprocess.run(cmd, **self.run_kwargs)\n    \n        # Check that the print statement was actually run\n>       assert proc.stdout == self.output_text\nE       assert \"Hab encounte...a'\\n\\n\\x1b[0m\" == \"Running...\\n...(built-in)>\\n\"\nE         \nE         - Running...\nE         - <module 'sys' (built-in)>\nE         + Hab encountered an error:\nE         + ModuleNotFoundError: No module named 'importlib_metadata'\nE         + \nE         + \u001b[0m\n\ntests\\test_launch.py:263: AssertionError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes::test_ps1[0]",
      "lineno": 239,
      "outcome": "failed",
      "keywords": [
        "test_ps1[0]",
        "skipif",
        "__wrapped__",
        "pytestmark",
        "0",
        "TestCliExitCodes",
        "parametrize",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\tests\\test_launch.py",
          "lineno": 263,
          "message": "assert \"Hab encounte...a'\\n\\n\\x1b[0m\" == \"Running...\\n...(built-in)>\\n\"\n  \n  - Running...\n  - <module 'sys' (built-in)>\n  + Hab encountered an error:\n  + ModuleNotFoundError: No module named 'importlib_metadata'\n  + \n  + \u001b[0m"
        },
        "traceback": [
          {
            "path": "tests\\test_launch.py",
            "lineno": 263,
            "message": "AssertionError"
          }
        ],
        "longrepr": "self = <test_launch.TestCliExitCodes object at 0x0000016654230BC0>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nexit_code = 0\n\n    @pytest.mark.skipif(sys.platform != \"win32\", reason=\"only applies on windows\")\n    @pytest.mark.skipif(\n        os.getenv(\"GITHUB_ACTIONS\") == \"true\",\n        reason=\"PowerShell tests timeout when run in a github action\",\n    )\n    @missing_annotations_hack\n    def test_ps1(self, config_root, exit_code):\n        # -File is needed to get the exit-code from powershell, and requires a full path\n        script = (config_root / \"..\" / \"bin\" / \"hab.ps1\").resolve()\n        # fmt: off\n        cmd = [\n            \"powershell.exe\", \"-ExecutionPolicy\", \"Unrestricted\",\n            \"-File\", str(script),\n            \"--site\", str(config_root / \"site_main.json\"),\n            *self.sub_cmd,\n            f\"\\\"{self.py_cmd.format(code=exit_code)}\\\"\",\n        ]\n        # fmt: on\n    \n        # Run the hab command in a subprocess\n        proc = subprocess.run(cmd, **self.run_kwargs)\n    \n        # Check that the print statement was actually run\n>       assert proc.stdout == self.output_text\nE       assert \"Hab encounte...a'\\n\\n\\x1b[0m\" == \"Running...\\n...(built-in)>\\n\"\nE         \nE         - Running...\nE         - <module 'sys' (built-in)>\nE         + Hab encountered an error:\nE         + ModuleNotFoundError: No module named 'importlib_metadata'\nE         + \nE         + \u001b[0m\n\ntests\\test_launch.py:263: AssertionError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bash_win[5]",
      "lineno": 265,
      "outcome": "skipped",
      "keywords": [
        "test_bash_win[5]",
        "skip",
        "pytestmark",
        "5",
        "TestCliExitCodes",
        "parametrize",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\test_launch.py', 266, 'Skipped: Find a way to make this test run successfully')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bash_win[4]",
      "lineno": 265,
      "outcome": "skipped",
      "keywords": [
        "test_bash_win[4]",
        "skip",
        "pytestmark",
        "4",
        "TestCliExitCodes",
        "parametrize",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\test_launch.py', 266, 'Skipped: Find a way to make this test run successfully')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bash_win[0]",
      "lineno": 265,
      "outcome": "skipped",
      "keywords": [
        "test_bash_win[0]",
        "skip",
        "pytestmark",
        "0",
        "TestCliExitCodes",
        "parametrize",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\test_launch.py', 266, 'Skipped: Find a way to make this test run successfully')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bash_linux[5]",
      "lineno": 297,
      "outcome": "skipped",
      "keywords": [
        "test_bash_linux[5]",
        "skip",
        "pytestmark",
        "5",
        "TestCliExitCodes",
        "parametrize",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\test_launch.py', 298, 'Skipped: Find a way to make this test run successfully')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bash_linux[4]",
      "lineno": 297,
      "outcome": "skipped",
      "keywords": [
        "test_bash_linux[4]",
        "skip",
        "pytestmark",
        "4",
        "TestCliExitCodes",
        "parametrize",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\test_launch.py', 298, 'Skipped: Find a way to make this test run successfully')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_launch.py::TestCliExitCodes::test_bash_linux[0]",
      "lineno": 297,
      "outcome": "skipped",
      "keywords": [
        "test_bash_linux[0]",
        "skip",
        "pytestmark",
        "0",
        "TestCliExitCodes",
        "parametrize",
        "test_launch.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\test_launch.py', 298, 'Skipped: Find a way to make this test run successfully')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestLoadJsonFile::test_missing",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_missing",
        "TestLoadJsonFile",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestLoadJsonFile::test_binary",
      "lineno": 36,
      "outcome": "passed",
      "keywords": [
        "test_binary",
        "TestLoadJsonFile",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestLoadJsonFile::test_config_load",
      "lineno": 68,
      "outcome": "failed",
      "keywords": [
        "test_config_load",
        "TestLoadJsonFile",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 70,
            "message": ""
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestLoadJsonFile object at 0x00000166544DE930>\nuncached_resolver = <hab.resolver.Resolver object at 0x0000016654877F20>\n\n    def test_config_load(self, uncached_resolver):\n>       cfg = Config({}, uncached_resolver)\n\ntests\\test_parsing.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654876630>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016654877F20>), kwargs = {}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_distro_parse[uncached]",
      "lineno": 80,
      "outcome": "failed",
      "keywords": [
        "test_distro_parse[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 84,
            "message": ""
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nresolver = <hab.resolver.Resolver object at 0x00000166546BEAB0>\n\n    def test_distro_parse(config_root, resolver):\n        \"\"\"Check that a distro json can be parsed correctly\"\"\"\n        forest = {}\n>       app = DistroVersion(forest, resolver)\n\ntests\\test_parsing.py:84: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016654876F30>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546BEAB0>), kwargs = {}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_distro_parse[cached]",
      "lineno": 80,
      "outcome": "error",
      "keywords": [
        "test_distro_parse[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_distro_parse[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_distro_exceptions",
      "lineno": 112,
      "outcome": "failed",
      "keywords": [
        "test_distro_exceptions",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nuncached_resolver = <hab.resolver.Resolver object at 0x0000016654042330>\n\n    def test_distro_exceptions(config_root, uncached_resolver):\n        \"\"\"Check that a exception is raised if you define \"distro\" on an alias.\"\"\"\n        forest = {}\n>       app = DistroVersion(forest, uncached_resolver)\n\ntests\\test_parsing.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x00000166540439B0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016654042330>), kwargs = {}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_distro_version_resolve[uncached]",
      "lineno": 124,
      "outcome": "failed",
      "keywords": [
        "test_distro_version_resolve[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 130,
            "message": ""
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nresolver = <hab.resolver.Resolver object at 0x00000166546B6A20>\nhelpers = <class 'conftest.Helpers'>\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x00000166546B4E30>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_distro_version_resolve_un0')\n\n    def test_distro_version_resolve(config_root, resolver, helpers, monkeypatch, tmpdir):\n        \"\"\"Check the various methods for DistroVersion.version to be populated.\"\"\"\n    \n        # Test that `.hab_version.txt` is respected if it exists.\n        forest = {}\n>       app = DistroVersion(forest, resolver)\n\ntests\\test_parsing.py:130: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x00000166546B63C0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546B6A20>), kwargs = {}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_distro_version_resolve[cached]",
      "lineno": 124,
      "outcome": "error",
      "keywords": [
        "test_distro_version_resolve[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_distro_version_resolve[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_distro_version[uncached]",
      "lineno": 184,
      "outcome": "failed",
      "keywords": [
        "test_distro_version[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 187,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166558AD430>\n\n    def test_distro_version(resolver):\n        \"\"\"Verify that we find the expected version for a given requirement.\"\"\"\n>       maya = resolver.distros[\"maya2020\"]\n\ntests\\test_parsing.py:187: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x00000166558AD250>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166558AD430>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_distro_version[cached]",
      "lineno": 184,
      "outcome": "error",
      "keywords": [
        "test_distro_version[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_distro_version[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_config_parse[uncached]",
      "lineno": 192,
      "outcome": "failed",
      "keywords": [
        "test_config_parse[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 196,
            "message": ""
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nresolver = <hab.resolver.Resolver object at 0x0000016654876000>\nhelpers = <class 'conftest.Helpers'>\n\n    def test_config_parse(config_root, resolver, helpers):\n        \"\"\"Check that a config json can be parsed correctly\"\"\"\n        forest = {}\n>       config = Config(forest, resolver)\n\ntests\\test_parsing.py:196: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654876BA0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016654876000>), kwargs = {}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_config_parse[cached]",
      "lineno": 192,
      "outcome": "error",
      "keywords": [
        "test_config_parse[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_config_parse[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_config_parenting[uncached]",
      "lineno": 216,
      "outcome": "failed",
      "keywords": [
        "test_config_parenting[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 229,
            "message": ""
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nresolver = <hab.resolver.Resolver object at 0x00000166558AEDE0>\n\n    def test_config_parenting(config_root, resolver):\n        \"\"\"Check that a correct tree structure is generated especially when loaded\n        in a incorrect order.\n        \"\"\"\n    \n        def repr_list(node):\n            return [repr(x) for x in anytree.iterators.PreOrderIter(node)]\n    \n        forest = {}\n        root_paths = set((config_root,))\n        # Ensure the forest has multiple trees when processing\n        shared_path = config_root / \"configs\" / \"default\" / \"default.json\"\n>       Config(forest, resolver, filename=shared_path, root_paths=root_paths)\n\ntests\\test_parsing.py:229: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166558AF080>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166558AEDE0>)\nkwargs = {'filename': WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/default/default.json'), 'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_config_parenting[cached]",
      "lineno": 216,
      "outcome": "error",
      "keywords": [
        "test_config_parenting[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_config_parenting[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_metaclass",
      "lineno": 284,
      "outcome": "failed",
      "keywords": [
        "test_metaclass",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\tests\\test_parsing.py",
          "lineno": 286,
          "message": "AssertionError: assert {'alias_mods'...s', 'version'} == {'alias_mods'...ilename', ...}\n  \n  Extra items in the right set:\n  'environment_config'\n  'environment'\n  'distros'\n  'name'\n  'variables'...\n  \n  ...Full output truncated (4 lines hidden), use '-vv' to show"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 286,
            "message": "AssertionError"
          }
        ],
        "longrepr": "def test_metaclass():\n>       assert set(DistroVersion._properties.keys()) == set(\n            [\n                \"alias_mods\",\n                \"aliases\",\n                \"distros\",\n                \"environment\",\n                \"environment_config\",\n                \"filename\",\n                \"min_verbosity\",\n                \"name\",\n                \"optional_distros\",\n                \"variables\",\n                \"version\",\n            ]\n        )\nE       AssertionError: assert {'alias_mods'...s', 'version'} == {'alias_mods'...ilename', ...}\nE         \nE         Extra items in the right set:\nE         'environment_config'\nE         'environment'\nE         'distros'\nE         'name'\nE         'variables'...\nE         \nE         ...Full output truncated (4 lines hidden), use '-vv' to show\n\ntests\\test_parsing.py:286: AssertionError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestDump::test_dump[uncached]",
      "lineno": 320,
      "outcome": "failed",
      "keywords": [
        "test_dump[uncached]",
        "uncached",
        "TestDump",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 348,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestDump object at 0x00000166544DEA80>\nresolver = <hab.resolver.Resolver object at 0x00000166546B41D0>\n\n    def test_dump(self, resolver):\n        line = \"-LINE-\"\n    \n        def standardize(txt):\n            \"\"\"Dump adds an arbitrary length border of -'s that makes str comparing\n            hard. Replace it with a constant value.\"\"\"\n            return re.sub(r\"^-+$\", line, txt, flags=re.M)\n    \n        # Build the test data so we can generate the output to check\n        # Note: using `repr([u\"` so this test passes in python 2 and 3\n        pre = [\"name:  child\", \"uri:  not_set/child\"]\n        post = [\n            \"inherits:  True\",\n            \"min_verbosity:  NotSet\",\n            \"optional_distros:  NotSet\",\n        ]\n        env = [\n            \"environment:  FMT_FOR_OS:  a{;}b;c:{PATH!e}{;}d\",\n            \"              TEST:  case\",\n            \"              UNSET_VARIABLE:  None\",\n        ]\n    \n        env_config = [\n            \"environment_config:  set:  FMT_FOR_OS:  a{;}b;c:{PATH!e}{;}d\",\n            \"                           TEST:  case\",\n            \"                     unset:  UNSET_VARIABLE\",\n        ]\n>       cfg = resolver.closest_config(\"not_set/child\")\n\ntests\\test_parsing.py:348: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654570740>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166546B41D0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestDump::test_dump[cached]",
      "lineno": 320,
      "outcome": "error",
      "keywords": [
        "test_dump[cached]",
        "cached",
        "TestDump",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_dump[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestDump::test_flat[uncached]",
      "lineno": 396,
      "outcome": "failed",
      "keywords": [
        "test_flat[uncached]",
        "uncached",
        "TestDump",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 399,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestDump object at 0x00000166544DED50>\nresolver = <hab.resolver.Resolver object at 0x0000016655925E80>\n\n    def test_flat(self, resolver):\n        \"\"\"Test additional dump settings for FlatConfig objects\"\"\"\n>       cfg = resolver.resolve(\"not_set/child\")\n\ntests\\test_parsing.py:399: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655926180>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655925E80>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestDump::test_flat[cached]",
      "lineno": 396,
      "outcome": "error",
      "keywords": [
        "test_flat[cached]",
        "cached",
        "TestDump",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_flat[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestDump::test_no_values[uncached-not_set/no_distros]",
      "lineno": 424,
      "outcome": "failed",
      "keywords": [
        "test_no_values[uncached-not_set/no_distros]",
        "parametrize",
        "pytestmark",
        "uncached-not_set/no_distros",
        "TestDump",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 428,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestDump object at 0x00000166544DF200>\nresolver = <hab.resolver.Resolver object at 0x0000016655927B00>\nuri = 'not_set/no_distros'\n\n    @pytest.mark.parametrize(\"uri\", (\"not_set/no_distros\", \"not_set/empty_lists\"))\n    def test_no_values(self, resolver, uri):\n        \"\"\"If noting sets aliases or distros, don't include them in the dump text.\"\"\"\n>       cfg = resolver.resolve(uri)\n\ntests\\test_parsing.py:428: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655927E90>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655927B00>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestDump::test_no_values[uncached-not_set/empty_lists]",
      "lineno": 424,
      "outcome": "failed",
      "keywords": [
        "test_no_values[uncached-not_set/empty_lists]",
        "parametrize",
        "pytestmark",
        "uncached-not_set/empty_lists",
        "TestDump",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 428,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestDump object at 0x00000166544DF140>\nresolver = <hab.resolver.Resolver object at 0x00000166558F8CE0>\nuri = 'not_set/empty_lists'\n\n    @pytest.mark.parametrize(\"uri\", (\"not_set/no_distros\", \"not_set/empty_lists\"))\n    def test_no_values(self, resolver, uri):\n        \"\"\"If noting sets aliases or distros, don't include them in the dump text.\"\"\"\n>       cfg = resolver.resolve(uri)\n\ntests\\test_parsing.py:428: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166558F8F20>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166558F8CE0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestDump::test_no_values[cached-not_set/no_distros]",
      "lineno": 424,
      "outcome": "error",
      "keywords": [
        "test_no_values[cached-not_set/no_distros]",
        "parametrize",
        "pytestmark",
        "cached-not_set/no_distros",
        "TestDump",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_no_values[cached-not_set/no_distros]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestDump::test_no_values[cached-not_set/empty_lists]",
      "lineno": 424,
      "outcome": "error",
      "keywords": [
        "test_no_values[cached-not_set/empty_lists]",
        "parametrize",
        "pytestmark",
        "cached-not_set/empty_lists",
        "TestDump",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_no_values[cached-not_set/empty_lists]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_environment[uncached]",
      "lineno": 445,
      "outcome": "failed",
      "keywords": [
        "test_environment[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 448,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166558F84D0>\n\n    def test_environment(resolver):\n        # Check that the correct errors are raised\n>       cfg = resolver.closest_config(\"not_set/env_path_set\")\n\ntests\\test_parsing.py:448: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166558FAE70>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166558F84D0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_environment[cached]",
      "lineno": 445,
      "outcome": "error",
      "keywords": [
        "test_environment[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_environment[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_flat_config[uncached]",
      "lineno": 501,
      "outcome": "failed",
      "keywords": [
        "test_flat_config[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 503,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166559F8DD0>\n\n    def test_flat_config(resolver):\n>       ret = resolver.resolve(\"not_set/child\")\n\ntests\\test_parsing.py:503: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559F9130>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166559F8DD0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_flat_config[cached]",
      "lineno": 501,
      "outcome": "error",
      "keywords": [
        "test_flat_config[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_flat_config[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_flat_config_env_resolve[uncached]",
      "lineno": 535,
      "outcome": "failed",
      "keywords": [
        "test_flat_config_env_resolve[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 541,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166559FBD70>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nhelpers = <class 'conftest.Helpers'>\n\n    def test_flat_config_env_resolve(resolver, config_root, helpers):\n        \"\"\"Checks that environment variables are properly merged when resolving distros\n        including inherited values. Checks that append/prepend are processed correctly\n        and result in a consistent ordering of the resulting environment variables.\n        \"\"\"\n>       ret = resolver.resolve(\"not_set/distros\")\n\ntests\\test_parsing.py:541: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559F9B20>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166559FBD70>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_flat_config_env_resolve[cached]",
      "lineno": 535,
      "outcome": "error",
      "keywords": [
        "test_flat_config_env_resolve[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_flat_config_env_resolve[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_placeholder_handling[uncached]",
      "lineno": 614,
      "outcome": "failed",
      "keywords": [
        "test_placeholder_handling[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 619,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166559CDE50>\n\n    def test_placeholder_handling(resolver):\n        # We haven't defined the top level \"placeholder\" uri or \"placeholder/undefined\",\n        # but we have defined \"placeholder/child\". Check that the Placeholder objects\n        # are processed correctly. Ie in this case it inherits from the default config.\n>       ret = resolver.resolve(\"place-holder/undefined\")\n\ntests\\test_parsing.py:619: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559CE150>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166559CDE50>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_placeholder_handling[cached]",
      "lineno": 614,
      "outcome": "error",
      "keywords": [
        "test_placeholder_handling[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_placeholder_handling[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_invalid_config[uncached]",
      "lineno": 673,
      "outcome": "failed",
      "keywords": [
        "test_invalid_config[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 688,
            "message": ""
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nresolver = <hab.resolver.Resolver object at 0x00000166559CE8D0>\n\n    def test_invalid_config(config_root, resolver):\n        \"\"\"Check that if an invalid json file is processed, its filename is included in\n        the traceback\"\"\"\n        path = config_root / \"invalid.json\"\n    \n        # Resolve if we are using pyjson5 or the native json class\n        native_json = False\n        try:\n            from pyjson5 import Json5Exception as _JsonException\n        except ImportError:\n            native_json = True\n            from builtins import ValueError as _JsonException\n    \n        with pytest.raises(_JsonException) as excinfo:\n>           Config({}, resolver, filename=path)\n\ntests\\test_parsing.py:688: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559CC590>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166559CE8D0>)\nkwargs = {'filename': WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/invalid.json')}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_invalid_config[cached]",
      "lineno": 673,
      "outcome": "error",
      "keywords": [
        "test_invalid_config[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_invalid_config[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_misc_coverage[uncached]",
      "lineno": 697,
      "outcome": "failed",
      "keywords": [
        "test_misc_coverage[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 704,
            "message": ""
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166559CF740>\n\n    def test_misc_coverage(resolver):\n        \"\"\"Test that cover misc lines not covered by the rest of the tests\"\"\"\n        assert str(NotSet) == \"NotSet\"\n        assert copy.copy(NotSet) is NotSet\n    \n        # Check that dirname is modified when setting a blank filename\n>       cfg = Config({}, resolver)\n\ntests\\test_parsing.py:704: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559CFC50>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166559CF740>), kwargs = {}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_misc_coverage[cached]",
      "lineno": 697,
      "outcome": "error",
      "keywords": [
        "test_misc_coverage[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_misc_coverage[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_duplicated_configs[uncached-configs_parent-not_set]",
      "lineno": 714,
      "outcome": "failed",
      "keywords": [
        "test_duplicated_configs[uncached-configs_parent-not_set]",
        "parametrize",
        "pytestmark",
        "uncached-configs_parent-not_set",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 740,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nresolver = <hab.resolver.Resolver object at 0x00000166559CE390>\ndirname = 'configs_parent', uri = 'not_set'\n\n    @pytest.mark.parametrize(\n        \"dirname,uri\",\n        (\n            (\"configs_parent\", \"not_set\"),\n            (\"configs_child\", \"not_set/child\"),\n        ),\n    )\n    def test_duplicated_configs(config_root, resolver, dirname, uri):\n        \"\"\"Check that a specific config can be duplicated and that the first path\n        is the used data. If there is a duplicate in the same config path, an exception\n        is raised.\n    \n        The duplicates/*_1 folders have a second definition, but are in their own unique\n        config_paths, so only the first found config is used.\n    \n        The duplicates/*_2 folders have a third definition. The second and third definitions\n        are in the same config_path so a DuplicateJsonError is raised.\n        \"\"\"\n        original = resolver.config_paths\n        config_paths = list(original)\n        # Check that config_paths raise exceptions correctly\n        config_paths.insert(0, config_root / \"duplicates\" / f\"{dirname}_1\")\n        resolver.config_paths = config_paths\n    \n        # Check that the first config in config_paths was used\n>       cfg = resolver.resolve(uri)\n\ntests\\test_parsing.py:740: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559CE750>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166559CE390>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\duplicates\\\\configs_parent_1\\\\not_set.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/duplicates/configs_parent_1')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_duplicated_configs[uncached-configs_child-not_set/child]",
      "lineno": 714,
      "outcome": "failed",
      "keywords": [
        "test_duplicated_configs[uncached-configs_child-not_set/child]",
        "parametrize",
        "pytestmark",
        "uncached-configs_child-not_set/child",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 740,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nresolver = <hab.resolver.Resolver object at 0x00000166559FA480>\ndirname = 'configs_child', uri = 'not_set/child'\n\n    @pytest.mark.parametrize(\n        \"dirname,uri\",\n        (\n            (\"configs_parent\", \"not_set\"),\n            (\"configs_child\", \"not_set/child\"),\n        ),\n    )\n    def test_duplicated_configs(config_root, resolver, dirname, uri):\n        \"\"\"Check that a specific config can be duplicated and that the first path\n        is the used data. If there is a duplicate in the same config path, an exception\n        is raised.\n    \n        The duplicates/*_1 folders have a second definition, but are in their own unique\n        config_paths, so only the first found config is used.\n    \n        The duplicates/*_2 folders have a third definition. The second and third definitions\n        are in the same config_path so a DuplicateJsonError is raised.\n        \"\"\"\n        original = resolver.config_paths\n        config_paths = list(original)\n        # Check that config_paths raise exceptions correctly\n        config_paths.insert(0, config_root / \"duplicates\" / f\"{dirname}_1\")\n        resolver.config_paths = config_paths\n    \n        # Check that the first config in config_paths was used\n>       cfg = resolver.resolve(uri)\n\ntests\\test_parsing.py:740: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559FA1B0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166559FA480>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\duplicates\\\\configs_child_1\\\\child.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/duplicates/configs_child_1')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_duplicated_configs[cached-configs_parent-not_set]",
      "lineno": 714,
      "outcome": "error",
      "keywords": [
        "test_duplicated_configs[cached-configs_parent-not_set]",
        "parametrize",
        "pytestmark",
        "cached-configs_parent-not_set",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_duplicated_configs[cached-configs_parent-not_set]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_duplicated_configs[cached-configs_child-not_set/child]",
      "lineno": 714,
      "outcome": "error",
      "keywords": [
        "test_duplicated_configs[cached-configs_child-not_set/child]",
        "parametrize",
        "pytestmark",
        "cached-configs_child-not_set/child",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_duplicated_configs[cached-configs_child-not_set/child]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_duplicated_distros[uncached]",
      "lineno": 751,
      "outcome": "failed",
      "keywords": [
        "test_duplicated_distros[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 770,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 269,
            "message": "in find_distro"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nresolver = <hab.resolver.Resolver object at 0x00000166559FBE90>\n\n    def test_duplicated_distros(config_root, resolver):\n        \"\"\"Check that a specific config can be duplicated and that the first path\n        is the used data. If there is a duplicate in the same config path, an exception\n        is raised.\n    \n        The duplicates/distros_1 folders have a second definition, but are in their own\n        unique config_paths, so only the first found config is used.\n    \n        The duplicates/distros_2 folders have a third definition. The second and third\n        definitions are in the same config_path so a DuplicateJsonError is raised.\n        \"\"\"\n        original = resolver.distro_paths\n    \n        # Check that the first config in distro_paths was used\n        distro_paths = list(original)\n        distro_paths.insert(0, config_root / \"duplicates\" / \"distros_1\" / \"*\")\n        resolver.distro_paths = distro_paths\n    \n>       dcc = resolver.find_distro(\"the_dcc==1.2\")\n\ntests\\test_parsing.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:269: in find_distro\n    if requirement.name in self.distros:\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x00000166559F8FE0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166559FBE90>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\duplicates\\\\distros_1\\\\the_dcc\\\\1.2\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/duplicates/distros_1/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_duplicated_distros[cached]",
      "lineno": 751,
      "outcome": "error",
      "keywords": [
        "test_duplicated_distros[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_duplicated_distros[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_os_specific_linux[uncached]",
      "lineno": 783,
      "outcome": "failed",
      "keywords": [
        "test_os_specific_linux[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 789,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x00000166558FA360>\nresolver = <hab.resolver.Resolver object at 0x00000166558FA5A0>\n\n    def test_os_specific_linux(monkeypatch, resolver):\n        \"\"\"Check that if \"os_specific\" is set to true, only env vars for the current\n        os are resolved.\"\"\"\n        # Simulate running on a linux platform.\n        monkeypatch.setattr(utils, \"Platform\", utils.LinuxPlatform)\n>       cfg = resolver.resolve(\"not_set/os\")\n\ntests\\test_parsing.py:789: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166558FA4E0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166558FA5A0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_os_specific_linux[cached]",
      "lineno": 783,
      "outcome": "error",
      "keywords": [
        "test_os_specific_linux[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_os_specific_linux[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_os_specific_win[uncached]",
      "lineno": 796,
      "outcome": "failed",
      "keywords": [
        "test_os_specific_win[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 802,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x00000166559F8440>\nresolver = <hab.resolver.Resolver object at 0x00000166559F8530>\n\n    def test_os_specific_win(monkeypatch, resolver):\n        \"\"\"Check that if \"os_specific\" is set to true, only env vars for the current\n        os are resolved.\"\"\"\n        # Simulate running on a windows platform\n        monkeypatch.setattr(utils, \"Platform\", utils.WinPlatform)\n>       cfg = resolver.resolve(\"not_set/os\")\n\ntests\\test_parsing.py:802: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559FA8A0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166559F8530>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_os_specific_win[cached]",
      "lineno": 796,
      "outcome": "error",
      "keywords": [
        "test_os_specific_win[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_os_specific_win[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestAliasMods::test_global[uncached]",
      "lineno": 810,
      "outcome": "failed",
      "keywords": [
        "test_global[uncached]",
        "uncached",
        "TestAliasMods",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 813,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestAliasMods object at 0x00000166544DF560>\nresolver = <hab.resolver.Resolver object at 0x00000166558AE150>\n\n    def test_global(self, resolver):\n        \"\"\"Check the various operations that alias_mod creates.\"\"\"\n>       cfg = resolver.resolve(\"app/aliased/mod\")\n\ntests\\test_parsing.py:813: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166558AFE60>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166558AE150>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestAliasMods::test_global[cached]",
      "lineno": 810,
      "outcome": "error",
      "keywords": [
        "test_global[cached]",
        "cached",
        "TestAliasMods",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_global[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_list[uncached]",
      "lineno": 857,
      "outcome": "failed",
      "keywords": [
        "test_as_list[uncached]",
        "uncached",
        "TestAliasMods",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 860,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestAliasMods object at 0x00000166544DE8D0>\nresolver = <hab.resolver.Resolver object at 0x0000016655924230>\n\n    def test_as_list(self, resolver):\n        \"\"\"Check that non-dict defined aliases are modified correctly\"\"\"\n>       cfg = resolver.resolve(\"app/aliased/mod\")\n\ntests\\test_parsing.py:860: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559FB3B0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655924230>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_list[cached]",
      "lineno": 857,
      "outcome": "error",
      "keywords": [
        "test_as_list[cached]",
        "cached",
        "TestAliasMods",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_as_list[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_dict[uncached]",
      "lineno": 869,
      "outcome": "failed",
      "keywords": [
        "test_as_dict[uncached]",
        "uncached",
        "TestAliasMods",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 872,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestAliasMods object at 0x00000166544DDBB0>\nresolver = <hab.resolver.Resolver object at 0x0000016654877200>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\n\n    def test_as_dict(self, resolver, config_root):\n        \"\"\"Additional tests for alias_mod.\"\"\"\n>       cfg = resolver.resolve(\"app/aliased/mod\")\n\ntests\\test_parsing.py:872: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166548756A0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016654877200>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_dict[cached]",
      "lineno": 869,
      "outcome": "error",
      "keywords": [
        "test_as_dict[cached]",
        "cached",
        "TestAliasMods",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_as_dict[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_dict_config[uncached]",
      "lineno": 891,
      "outcome": "failed",
      "keywords": [
        "test_as_dict_config[uncached]",
        "uncached",
        "TestAliasMods",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 894,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestAliasMods object at 0x00000166544DF800>\nresolver = <hab.resolver.Resolver object at 0x000001665477F7D0>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\n\n    def test_as_dict_config(self, resolver, config_root):\n        \"\"\"Additional test for alias_mod being set by a config not a distro.\"\"\"\n>       cfg = resolver.resolve(\"app/aliased/config\")\n\ntests\\test_parsing.py:894: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655924200>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665477F7D0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_dict_config[cached]",
      "lineno": 891,
      "outcome": "error",
      "keywords": [
        "test_as_dict_config[cached]",
        "cached",
        "TestAliasMods",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_as_dict_config[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_dict_mod_config[uncached]",
      "lineno": 905,
      "outcome": "failed",
      "keywords": [
        "test_as_dict_mod_config[uncached]",
        "uncached",
        "TestAliasMods",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 911,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestAliasMods object at 0x00000166544DFB00>\nresolver = <hab.resolver.Resolver object at 0x000001665486D7C0>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\n\n    def test_as_dict_mod_config(self, resolver, config_root):\n        \"\"\"Additional test for alias_mod when set by both config and distro.\n        In this case the config's mods are processed before the distro mod. This\n        means that the distro's changes wrap the config changes.\n        \"\"\"\n>       cfg = resolver.resolve(\"app/aliased/mod/config\")\n\ntests\\test_parsing.py:911: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665486D370>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665486D7C0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestAliasMods::test_as_dict_mod_config[cached]",
      "lineno": 905,
      "outcome": "error",
      "keywords": [
        "test_as_dict_mod_config[cached]",
        "cached",
        "TestAliasMods",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_as_dict_mod_config[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_duplicates[uncached]",
      "lineno": 927,
      "outcome": "failed",
      "keywords": [
        "test_duplicates[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 932,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166547FB080>\n\n    def test_duplicates(resolver):\n        \"\"\"Ensure consistent handling of duplicate alias names.\"\"\"\n    \n        # houdini18.5 is the first distro, it's duplicate generic alias is used\n>       cfg = resolver.resolve(\"app/houdini/a\")\n\ntests\\test_parsing.py:932: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546635C0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166547FB080>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_duplicates[cached]",
      "lineno": 927,
      "outcome": "error",
      "keywords": [
        "test_duplicates[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_duplicates[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_get_min_verbosity[uncached]",
      "lineno": 943,
      "outcome": "failed",
      "keywords": [
        "test_get_min_verbosity[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 945,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x000001665598EE10>\n\n    def test_get_min_verbosity(resolver):\n>       cfg = resolver.resolve(\"verbosity\")\n\ntests\\test_parsing.py:945: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665598D700>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665598EE10>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_get_min_verbosity[cached]",
      "lineno": 943,
      "outcome": "error",
      "keywords": [
        "test_get_min_verbosity[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_get_min_verbosity[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_alias_min_verbosity_default[uncached]",
      "lineno": 958,
      "outcome": "failed",
      "keywords": [
        "test_alias_min_verbosity_default[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 961,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x000001665598DF40>\n\n    def test_alias_min_verbosity_default(resolver):\n        \"\"\"Test dumping of configs using the default target `hab`.\"\"\"\n>       cfg = resolver.resolve(\"verbosity/inherit\")\n\ntests\\test_parsing.py:961: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665477D580>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665598DF40>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_alias_min_verbosity_default[cached]",
      "lineno": 958,
      "outcome": "error",
      "keywords": [
        "test_alias_min_verbosity_default[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_alias_min_verbosity_default[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_alias_min_verbosity_hab_gui[uncached]",
      "lineno": 979,
      "outcome": "failed",
      "keywords": [
        "test_alias_min_verbosity_hab_gui[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 982,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655A11730>\n\n    def test_alias_min_verbosity_hab_gui(resolver):\n        \"\"\"Test dumping of aliases using the non-default target `hab-gui`..\"\"\"\n>       cfg = resolver.resolve(\"verbosity/inherit\")\n\ntests\\test_parsing.py:982: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655A11A30>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A11730>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_alias_min_verbosity_hab_gui[cached]",
      "lineno": 979,
      "outcome": "error",
      "keywords": [
        "test_alias_min_verbosity_hab_gui[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_alias_min_verbosity_hab_gui[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_update_environ[uncached]",
      "lineno": 1000,
      "outcome": "failed",
      "keywords": [
        "test_update_environ[uncached]",
        "uncached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 1003,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655A10740>\n\n    def test_update_environ(resolver):\n        pathsep = utils.Platform.pathsep(utils.Platform.default_ext())\n>       cfg = resolver.resolve(\"app/aliased/mod\")\n\ntests\\test_parsing.py:1003: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166546A3A70>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A10740>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::test_update_environ[cached]",
      "lineno": 1000,
      "outcome": "error",
      "keywords": [
        "test_update_environ[cached]",
        "cached",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_update_environ[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestCustomVariables::test_distro",
      "lineno": 1086,
      "outcome": "failed",
      "keywords": [
        "test_distro",
        "TestCustomVariables",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 1089,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestCustomVariables object at 0x00000166544DFDA0>\nuncached_resolver = <hab.resolver.Resolver object at 0x0000016655A346B0>\n\n    def test_distro(self, uncached_resolver):\n        \"\"\"Test that a distro processes valid custom variables correctly.\"\"\"\n>       distro = uncached_resolver.distros[\"maya2024\"].latest_version(\"maya2024\")\n\ntests\\test_parsing.py:1089: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655A34980>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A346B0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestCustomVariables::test_config[Config]",
      "lineno": 1116,
      "outcome": "failed",
      "keywords": [
        "test_config[Config]",
        "parametrize",
        "pytestmark",
        "Config",
        "TestCustomVariables",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 1121,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestCustomVariables object at 0x00000166544DFFE0>\nuncached_resolver = <hab.resolver.Resolver object at 0x0000016655A37AD0>\nconfig_class = 'Config'\n\n    @pytest.mark.parametrize(\"config_class\", (\"Config\", \"FlatConfig\"))\n    def test_config(self, uncached_resolver, config_class):\n        \"\"\"Test that a config processes valid custom variables correctly.\"\"\"\n        if config_class == \"Config\":\n>           cfg = uncached_resolver.closest_config(\"project_a\")\n\ntests\\test_parsing.py:1121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655A35EB0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A37AD0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestCustomVariables::test_config[FlatConfig]",
      "lineno": 1116,
      "outcome": "failed",
      "keywords": [
        "test_config[FlatConfig]",
        "parametrize",
        "pytestmark",
        "FlatConfig",
        "TestCustomVariables",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 1124,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestCustomVariables object at 0x0000016654508170>\nuncached_resolver = <hab.resolver.Resolver object at 0x0000016655A109E0>\nconfig_class = 'FlatConfig'\n\n    @pytest.mark.parametrize(\"config_class\", (\"Config\", \"FlatConfig\"))\n    def test_config(self, uncached_resolver, config_class):\n        \"\"\"Test that a config processes valid custom variables correctly.\"\"\"\n        if config_class == \"Config\":\n            cfg = uncached_resolver.closest_config(\"project_a\")\n            assert type(cfg) == Config\n        else:\n>           cfg = uncached_resolver.resolve(\"project_a\")\n\ntests\\test_parsing.py:1124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655A132F0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A109E0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestCustomVariables::test_reserved[variables0-relative_root]",
      "lineno": 1150,
      "outcome": "failed",
      "keywords": [
        "test_reserved[variables0-relative_root]",
        "parametrize",
        "pytestmark",
        "variables0-relative_root",
        "TestCustomVariables",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 1182,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestCustomVariables object at 0x0000016654508440>\nuncached_resolver = <hab.resolver.Resolver object at 0x0000016655A34E30>\nvariables = {'relative_root': 'Not Valid'}, invalid = 'relative_root'\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_reserved_variables0_relat0')\n\n    @pytest.mark.parametrize(\n        \"variables,invalid\",\n        (\n            ({\"relative_root\": \"Not Valid\"}, \"relative_root\"),\n            ({\"relative_root\": \"Not Valid\", \";\": \"Not Valid\"}, \";, relative_root\"),\n            ({\"valid\": \"Valid\", \";\": \"Not Valid\"}, \";\"),\n        ),\n    )\n    def test_reserved(self, uncached_resolver, variables, invalid, tmpdir):\n        \"\"\"Test that using a reserved variable raises an exception.\"\"\"\n    \n        # Create a test distro file using the given reserved variables\n        template = {\n            \"name\": \"maya2024\",\n            \"version\": \"2024.99\",\n            \"variables\": variables,\n        }\n        distro_file = tmpdir / \"maya2024\" / \".hab.json\"\n        Path(distro_file).parent.mkdir()\n        with distro_file.open(\"w\") as fle:\n            json.dump(template, fle, indent=4, cls=utils.HabJsonEncoder)\n    \n        # Add the test distro to hab's distro search. We don't need to call\n        # `clear_caches` because distros haven't been resolved yet.\n        uncached_resolver.distro_paths.append(Path(tmpdir))\n    \n        # When distros are resolved, an exception should be raised\n        with pytest.raises(\n            ReservedVariableNameError,\n            match=rf\"'{invalid}' are reserved variable name\\(s\\) for hab\",\n        ):\n>           uncached_resolver.distros\n\ntests\\test_parsing.py:1182: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655A37CE0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A34E30>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestCustomVariables::test_reserved[variables1-;, relative_root]",
      "lineno": 1150,
      "outcome": "failed",
      "keywords": [
        "test_reserved[variables1-;, relative_root]",
        "parametrize",
        "pytestmark",
        "variables1-;, relative_root",
        "TestCustomVariables",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 1182,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestCustomVariables object at 0x00000166545085F0>\nuncached_resolver = <hab.resolver.Resolver object at 0x000001665597AF90>\nvariables = {';': 'Not Valid', 'relative_root': 'Not Valid'}\ninvalid = ';, relative_root'\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_reserved_variables1____re0')\n\n    @pytest.mark.parametrize(\n        \"variables,invalid\",\n        (\n            ({\"relative_root\": \"Not Valid\"}, \"relative_root\"),\n            ({\"relative_root\": \"Not Valid\", \";\": \"Not Valid\"}, \";, relative_root\"),\n            ({\"valid\": \"Valid\", \";\": \"Not Valid\"}, \";\"),\n        ),\n    )\n    def test_reserved(self, uncached_resolver, variables, invalid, tmpdir):\n        \"\"\"Test that using a reserved variable raises an exception.\"\"\"\n    \n        # Create a test distro file using the given reserved variables\n        template = {\n            \"name\": \"maya2024\",\n            \"version\": \"2024.99\",\n            \"variables\": variables,\n        }\n        distro_file = tmpdir / \"maya2024\" / \".hab.json\"\n        Path(distro_file).parent.mkdir()\n        with distro_file.open(\"w\") as fle:\n            json.dump(template, fle, indent=4, cls=utils.HabJsonEncoder)\n    \n        # Add the test distro to hab's distro search. We don't need to call\n        # `clear_caches` because distros haven't been resolved yet.\n        uncached_resolver.distro_paths.append(Path(tmpdir))\n    \n        # When distros are resolved, an exception should be raised\n        with pytest.raises(\n            ReservedVariableNameError,\n            match=rf\"'{invalid}' are reserved variable name\\(s\\) for hab\",\n        ):\n>           uncached_resolver.distros\n\ntests\\test_parsing.py:1182: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655978E90>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665597AF90>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_parsing.py::TestCustomVariables::test_reserved[variables2-;]",
      "lineno": 1150,
      "outcome": "failed",
      "keywords": [
        "test_reserved[variables2-;]",
        "parametrize",
        "pytestmark",
        "variables2-;",
        "TestCustomVariables",
        "test_parsing.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_parsing.py",
            "lineno": 1182,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_parsing.TestCustomVariables object at 0x00000166545086B0>\nuncached_resolver = <hab.resolver.Resolver object at 0x0000016655979970>\nvariables = {';': 'Not Valid', 'valid': 'Valid'}, invalid = ';'\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_reserved_variables2___0')\n\n    @pytest.mark.parametrize(\n        \"variables,invalid\",\n        (\n            ({\"relative_root\": \"Not Valid\"}, \"relative_root\"),\n            ({\"relative_root\": \"Not Valid\", \";\": \"Not Valid\"}, \";, relative_root\"),\n            ({\"valid\": \"Valid\", \";\": \"Not Valid\"}, \";\"),\n        ),\n    )\n    def test_reserved(self, uncached_resolver, variables, invalid, tmpdir):\n        \"\"\"Test that using a reserved variable raises an exception.\"\"\"\n    \n        # Create a test distro file using the given reserved variables\n        template = {\n            \"name\": \"maya2024\",\n            \"version\": \"2024.99\",\n            \"variables\": variables,\n        }\n        distro_file = tmpdir / \"maya2024\" / \".hab.json\"\n        Path(distro_file).parent.mkdir()\n        with distro_file.open(\"w\") as fle:\n            json.dump(template, fle, indent=4, cls=utils.HabJsonEncoder)\n    \n        # Add the test distro to hab's distro search. We don't need to call\n        # `clear_caches` because distros haven't been resolved yet.\n        uncached_resolver.distro_paths.append(Path(tmpdir))\n    \n        # When distros are resolved, an exception should be raised\n        with pytest.raises(\n            ReservedVariableNameError,\n            match=rf\"'{invalid}' are reserved variable name\\(s\\) for hab\",\n        ):\n>           uncached_resolver.distros\n\ntests\\test_parsing.py:1182: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x000001665597A030>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655979970>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_environment_variables",
      "lineno": 15,
      "outcome": "passed",
      "keywords": [
        "test_environment_variables",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_config[uncached]",
      "lineno": 60,
      "outcome": "failed",
      "keywords": [
        "test_config[uncached]",
        "uncached",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655A34E30>\n\n    def test_config(resolver):\n        \"\"\"Spot check a few of the parsed configs to ensure config works.\"\"\"\n        any_resolver = anytree.Resolver()\n>       default = resolver.configs[\"default\"]\n\ntests\\test_resolver.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655A36090>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A34E30>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_config[cached]",
      "lineno": 60,
      "outcome": "error",
      "keywords": [
        "test_config[cached]",
        "cached",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_config[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_a-project_a-Complete root path not found]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-project_a-project_a-Complete root path not found]",
        "parametrize",
        "pytestmark",
        "uncached-project_a-project_a-Complete root path not found",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x000001665597B0B0>\npath = 'project_a', result = 'project_a'\nreason = 'Complete root path not found'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665597B050>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665597B0B0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_a/Sc001-project_a/Sc001-Complete secondary path not found]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-project_a/Sc001-project_a/Sc001-Complete secondary path not found]",
        "parametrize",
        "pytestmark",
        "uncached-project_a/Sc001-project_a/Sc001-Complete secondary path not found",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655936FF0>\npath = 'project_a/Sc001', result = 'project_a/Sc001'\nreason = 'Complete secondary path not found'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559342C0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655936FF0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_a/Sc001/Animation-project_a/Sc001/Animation-Complete tertiary path not found]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-project_a/Sc001/Animation-project_a/Sc001/Animation-Complete tertiary path not found]",
        "parametrize",
        "pytestmark",
        "uncached-project_a/Sc001/Animation-project_a/Sc001/Animation-Complete tertiary path not found",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655A36CF0>\npath = 'project_a/Sc001/Animation', result = 'project_a/Sc001/Animation'\nreason = 'Complete tertiary path not found'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665597B6B0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A36CF0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_a/Sc001/Modeling-project_a/Sc001-Invalid tertiary path not fallen back]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-project_a/Sc001/Modeling-project_a/Sc001-Invalid tertiary path not fallen back]",
        "parametrize",
        "pytestmark",
        "uncached-project_a/Sc001/Modeling-project_a/Sc001-Invalid tertiary path not fallen back",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655937440>\npath = 'project_a/Sc001/Modeling', result = 'project_a/Sc001'\nreason = 'Invalid tertiary path not fallen back'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655937DD0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655937440>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_a/Sc999/Modeling-project_a-Invalid secondary path not fallen back]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-project_a/Sc999/Modeling-project_a-Invalid secondary path not fallen back]",
        "parametrize",
        "pytestmark",
        "uncached-project_a/Sc999/Modeling-project_a-Invalid secondary path not fallen back",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655934DA0>\npath = 'project_a/Sc999/Modeling', result = 'project_a'\nreason = 'Invalid secondary path not fallen back'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655934EF0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655934DA0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_a/very/many/paths/resolved-project_a-Invalid n-length path not fallen back]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-project_a/very/many/paths/resolved-project_a-Invalid n-length path not fallen back]",
        "parametrize",
        "pytestmark",
        "uncached-project_a/very/many/paths/resolved-project_a-Invalid n-length path not fallen back",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655937C50>\npath = 'project_a/very/many/paths/resolved', result = 'project_a'\nreason = 'Invalid n-length path not fallen back'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166558FDB20>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655937C50>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_z-default-Default root not returned for invalid root.]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-project_z-default-Default root not returned for invalid root.]",
        "parametrize",
        "pytestmark",
        "uncached-project_z-default-Default root not returned for invalid root.",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166559359A0>\npath = 'project_z', result = 'default'\nreason = 'Default root not returned for invalid root.'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655935610>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166559359A0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_z/Sc001-default-Default root not returned if no matching secondary.]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-project_z/Sc001-default-Default root not returned if no matching secondary.]",
        "parametrize",
        "pytestmark",
        "uncached-project_z/Sc001-default-Default root not returned if no matching secondary.",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x000001665597B7D0>\npath = 'project_z/Sc001', result = 'default'\nreason = 'Default root not returned if no matching secondary.'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665597B8F0>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665597B7D0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_z/Sc101-default/Sc1-Default secondary not returned]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-project_z/Sc101-default/Sc1-Default secondary not returned]",
        "parametrize",
        "pytestmark",
        "uncached-project_z/Sc101-default/Sc1-Default secondary not returned",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166558FFF80>\npath = 'project_z/Sc101', result = 'default/Sc1'\nreason = 'Default secondary not returned'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166558FF410>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166558FFF80>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-project_z/Sc110-default/Sc11-More specific default secondary not returned]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-project_z/Sc110-default/Sc11-More specific default secondary not returned]",
        "parametrize",
        "pytestmark",
        "uncached-project_z/Sc110-default/Sc11-More specific default secondary not returned",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x00000166558FD220>\npath = 'project_z/Sc110', result = 'default/Sc11'\nreason = 'More specific default secondary not returned'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166558FD370>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166558FD220>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-/app-app-Leading slash not ignored]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-/app-app-Leading slash not ignored]",
        "parametrize",
        "pytestmark",
        "uncached-/app-app-Leading slash not ignored",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655A36CF0>, path = '/app'\nresult = 'app', reason = 'Leading slash not ignored'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655934470>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A36CF0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-app/-app-Trailing slash not sanitized correctly]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-app/-app-Trailing slash not sanitized correctly]",
        "parametrize",
        "pytestmark",
        "uncached-app/-app-Trailing slash not sanitized correctly",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655936FC0>, path = 'app/'\nresult = 'app', reason = 'Trailing slash not sanitized correctly'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655937AA0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655936FC0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[uncached-app/case/-app-Trailing slash not sanitized correctly]",
      "lineno": 69,
      "outcome": "failed",
      "keywords": [
        "test_closest_config[uncached-app/case/-app-Trailing slash not sanitized correctly]",
        "parametrize",
        "pytestmark",
        "uncached-app/case/-app-Trailing slash not sanitized correctly",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655978D10>\npath = 'app/case/', result = 'app'\nreason = 'Trailing slash not sanitized correctly'\n\n    @pytest.mark.parametrize(\n        \"path,result,reason\",\n        (\n            (\"project_a\", \"project_a\", \"Complete root path not found\"),\n            (\"project_a/Sc001\", \"project_a/Sc001\", \"Complete secondary path not found\"),\n            (\n                \"project_a/Sc001/Animation\",\n                \"project_a/Sc001/Animation\",\n                \"Complete tertiary path not found\",\n            ),\n            (\n                \"project_a/Sc001/Modeling\",\n                \"project_a/Sc001\",\n                \"Invalid tertiary path not fallen back\",\n            ),\n            (\n                \"project_a/Sc999/Modeling\",\n                \"project_a\",\n                \"Invalid secondary path not fallen back\",\n            ),\n            (\n                \"project_a/very/many/paths/resolved\",\n                \"project_a\",\n                \"Invalid n-length path not fallen back\",\n            ),\n            # Default fallback\n            (\"project_z\", \"default\", \"Default root not returned for invalid root.\"),\n            (\n                \"project_z/Sc001\",\n                \"default\",\n                \"Default root not returned if no matching secondary.\",\n            ),\n            (\"project_z/Sc101\", \"default/Sc1\", \"Default secondary not returned\"),\n            (\n                \"project_z/Sc110\",\n                \"default/Sc11\",\n                \"More specific default secondary not returned\",\n            ),\n            # Leading/trailing separators\n            (\"/app\", \"app\", \"Leading slash not ignored\"),\n            (\"app/\", \"app\", \"Trailing slash not sanitized correctly\"),\n            (\"app/case/\", \"app\", \"Trailing slash not sanitized correctly\"),\n        ),\n    )\n    def test_closest_config(resolver, path, result, reason):\n        \"\"\"Test that closest_config returns the expected results.\"\"\"\n>       assert resolver.closest_config(path).fullpath == result, reason\n\ntests\\test_resolver.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655A358B0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655978D10>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_a-project_a-Complete root path not found]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-project_a-project_a-Complete root path not found]",
        "parametrize",
        "pytestmark",
        "cached-project_a-project_a-Complete root path not found",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-project_a-project_a-Complete root path not found]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_a/Sc001-project_a/Sc001-Complete secondary path not found]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-project_a/Sc001-project_a/Sc001-Complete secondary path not found]",
        "parametrize",
        "pytestmark",
        "cached-project_a/Sc001-project_a/Sc001-Complete secondary path not found",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-project_a/Sc001-project_a/Sc001-Complete secondary path not found]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_a/Sc001/Animation-project_a/Sc001/Animation-Complete tertiary path not found]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-project_a/Sc001/Animation-project_a/Sc001/Animation-Complete tertiary path not found]",
        "parametrize",
        "pytestmark",
        "cached-project_a/Sc001/Animation-project_a/Sc001/Animation-Complete tertiary path not found",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-project_a/Sc001/Animation-project_a/Sc001/Animation-Complete tertiary path not found]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_a/Sc001/Modeling-project_a/Sc001-Invalid tertiary path not fallen back]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-project_a/Sc001/Modeling-project_a/Sc001-Invalid tertiary path not fallen back]",
        "parametrize",
        "pytestmark",
        "cached-project_a/Sc001/Modeling-project_a/Sc001-Invalid tertiary path not fallen back",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-project_a/Sc001/Modeling-project_a/Sc001-Invalid tertiary path not fallen back]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_a/Sc999/Modeling-project_a-Invalid secondary path not fallen back]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-project_a/Sc999/Modeling-project_a-Invalid secondary path not fallen back]",
        "parametrize",
        "pytestmark",
        "cached-project_a/Sc999/Modeling-project_a-Invalid secondary path not fallen back",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-project_a/Sc999/Modeling-project_a-Invalid secondary path not fallen back]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_a/very/many/paths/resolved-project_a-Invalid n-length path not fallen back]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-project_a/very/many/paths/resolved-project_a-Invalid n-length path not fallen back]",
        "parametrize",
        "pytestmark",
        "cached-project_a/very/many/paths/resolved-project_a-Invalid n-length path not fallen back",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-project_a/very/many/paths/resolved-project_a-Invalid n-length path not fallen back]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_z-default-Default root not returned for invalid root.]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-project_z-default-Default root not returned for invalid root.]",
        "parametrize",
        "pytestmark",
        "cached-project_z-default-Default root not returned for invalid root.",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-project_z-default-Default root not returned for invalid root.]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_z/Sc001-default-Default root not returned if no matching secondary.]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-project_z/Sc001-default-Default root not returned if no matching secondary.]",
        "parametrize",
        "pytestmark",
        "cached-project_z/Sc001-default-Default root not returned if no matching secondary.",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-project_z/Sc001-default-Default root not returned if no matching secondary.]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_z/Sc101-default/Sc1-Default secondary not returned]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-project_z/Sc101-default/Sc1-Default secondary not returned]",
        "parametrize",
        "pytestmark",
        "cached-project_z/Sc101-default/Sc1-Default secondary not returned",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-project_z/Sc101-default/Sc1-Default secondary not returned]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-project_z/Sc110-default/Sc11-More specific default secondary not returned]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-project_z/Sc110-default/Sc11-More specific default secondary not returned]",
        "parametrize",
        "pytestmark",
        "cached-project_z/Sc110-default/Sc11-More specific default secondary not returned",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-project_z/Sc110-default/Sc11-More specific default secondary not returned]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-/app-app-Leading slash not ignored]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-/app-app-Leading slash not ignored]",
        "parametrize",
        "pytestmark",
        "cached-/app-app-Leading slash not ignored",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-/app-app-Leading slash not ignored]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-app/-app-Trailing slash not sanitized correctly]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-app/-app-Trailing slash not sanitized correctly]",
        "parametrize",
        "pytestmark",
        "cached-app/-app-Trailing slash not sanitized correctly",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-app/-app-Trailing slash not sanitized correctly]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_closest_config[cached-app/case/-app-Trailing slash not sanitized correctly]",
      "lineno": 69,
      "outcome": "error",
      "keywords": [
        "test_closest_config[cached-app/case/-app-Trailing slash not sanitized correctly]",
        "parametrize",
        "pytestmark",
        "cached-app/case/-app-Trailing slash not sanitized correctly",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_closest_config[cached-app/case/-app-Trailing slash not sanitized correctly]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestDumpForest::test_uris_target_default[uncached]",
      "lineno": 163,
      "outcome": "failed",
      "keywords": [
        "test_uris_target_default[uncached]",
        "uncached",
        "TestDumpForest",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 171,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestDumpForest object at 0x0000016654545040>\nresolver = <hab.resolver.Resolver object at 0x000001665598EFF0>\n\n    def test_uris_target_default(self, resolver):\n        \"\"\"Test dumping of configs using the default target `hab`. This also\n        falls back to global setting.\"\"\"\n        check = list(self.all_uris)\n        # Verbosity filter disabled, show all results\n        assert resolver._verbosity_target == \"hab\"\n        assert resolver._verbosity_value is None\n>       result = list(resolver.dump_forest(resolver.configs))\n\ntests\\test_resolver.py:171: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665598ED80>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665598EFF0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestDumpForest::test_uris_target_default[cached]",
      "lineno": 163,
      "outcome": "error",
      "keywords": [
        "test_uris_target_default[cached]",
        "cached",
        "TestDumpForest",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_uris_target_default[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestDumpForest::test_uris_objs[uncached]",
      "lineno": 195,
      "outcome": "failed",
      "keywords": [
        "test_uris_objs[uncached]",
        "uncached",
        "TestDumpForest",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 198,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestDumpForest object at 0x00000166545452E0>\nresolver = <hab.resolver.Resolver object at 0x00000166558F9040>\n\n    def test_uris_objs(self, resolver):\n        # If attr is \"uri\" then the uri as a string is returned.\n>       result = list(resolver.dump_forest(resolver.configs, attr=\"uri\"))\n\ntests\\test_resolver.py:198: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166558FA4E0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166558F9040>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestDumpForest::test_uris_objs[cached]",
      "lineno": 195,
      "outcome": "error",
      "keywords": [
        "test_uris_objs[cached]",
        "cached",
        "TestDumpForest",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_uris_objs[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestDumpForest::test_uris_target_hab_gui[uncached]",
      "lineno": 205,
      "outcome": "failed",
      "keywords": [
        "test_uris_target_hab_gui[uncached]",
        "uncached",
        "TestDumpForest",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 214,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestDumpForest object at 0x000001665450BFE0>\nresolver = <hab.resolver.Resolver object at 0x00000166558FD1F0>\n\n    def test_uris_target_hab_gui(self, resolver):\n        \"\"\"Test dumping of configs using the non-default target `hab-gui`. This\n        also falls back to global setting.\"\"\"\n        check = list(self.all_uris)\n        # Verbosity filter disabled, show all results\n        assert resolver._verbosity_target == \"hab\"\n        assert resolver._verbosity_value is None\n        with utils.verbosity_filter(resolver, verbosity=None, target=\"hab-gui\"):\n>           result = list(resolver.dump_forest(resolver.configs))\n\ntests\\test_resolver.py:214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166558FF4A0>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166558FD1F0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestDumpForest::test_uris_target_hab_gui[cached]",
      "lineno": 205,
      "outcome": "error",
      "keywords": [
        "test_uris_target_hab_gui[cached]",
        "cached",
        "TestDumpForest",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_uris_target_hab_gui[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestDumpForest::test_distros[uncached]",
      "lineno": 238,
      "outcome": "failed",
      "keywords": [
        "test_distros[uncached]",
        "uncached",
        "TestDumpForest",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 241,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestDumpForest object at 0x0000016654545790>\nresolver = <hab.resolver.Resolver object at 0x00000166558FEC30>\n\n    def test_distros(self, resolver):\n        \"\"\"Test dumping distros using name attr\"\"\"\n>       result = list(resolver.dump_forest(resolver.distros, attr=\"name\"))\n\ntests\\test_resolver.py:241: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x00000166558FCB90>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166558FEC30>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestDumpForest::test_distros[cached]",
      "lineno": 238,
      "outcome": "error",
      "keywords": [
        "test_distros[cached]",
        "cached",
        "TestDumpForest",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_distros[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestDumpForest::test_distros_truncate[uncached]",
      "lineno": 293,
      "outcome": "failed",
      "keywords": [
        "test_distros_truncate[uncached]",
        "uncached",
        "TestDumpForest",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 296,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestDumpForest object at 0x0000016654544860>\nresolver = <hab.resolver.Resolver object at 0x0000016655A50D40>\n\n    def test_distros_truncate(self, resolver):\n        \"\"\"Test truncate feature by dumping distros\"\"\"\n>       result = list(resolver.dump_forest(resolver.distros, attr=\"name\", truncate=1))\n\ntests\\test_resolver.py:296: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655A50D10>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A50D40>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestDumpForest::test_distros_truncate[cached]",
      "lineno": 293,
      "outcome": "error",
      "keywords": [
        "test_distros_truncate[cached]",
        "cached",
        "TestDumpForest",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_distros_truncate[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_reduced[uncached]",
      "lineno": 349,
      "outcome": "failed",
      "keywords": [
        "test_reduced[uncached]",
        "uncached",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 352,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655A53770>\nhelpers = <class 'conftest.Helpers'>\n\n    def test_reduced(resolver, helpers):\n        \"\"\"Check that NotSet is used if no value is provided.\"\"\"\n>       cfg = resolver.closest_config(\"not_set\")\n\ntests\\test_resolver.py:352: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655A51640>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A53770>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_reduced[cached]",
      "lineno": 349,
      "outcome": "error",
      "keywords": [
        "test_reduced[cached]",
        "cached",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_reduced[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_simple[uncached]",
      "lineno": 394,
      "outcome": "failed",
      "keywords": [
        "test_simple[uncached]",
        "uncached",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 401,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 381,
            "message": "in resolve_requirements"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestResolveRequirements object at 0x0000016654544830>\nresolver = <hab.resolver.Resolver object at 0x0000016655B47A10>\n\n    def test_simple(self, resolver):\n        requirements = {\n            \"the_dcc\": Requirement(\"the_dcc\"),\n        }\n    \n        # A simple resolve with no recalculations\n>       resolved = resolver.resolve_requirements(requirements)\n\ntests\\test_resolver.py:401: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:381: in resolve_requirements\n    return solver.resolve()\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655B45460>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655B47A10>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_simple[cached]",
      "lineno": 394,
      "outcome": "error",
      "keywords": [
        "test_simple[cached]",
        "cached",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_simple[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_recalculate[uncached]",
      "lineno": 433,
      "outcome": "failed",
      "keywords": [
        "test_recalculate[uncached]",
        "uncached",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 450,
            "message": ""
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestResolveRequirements object at 0x0000016654545C10>\nresolver = <hab.resolver.Resolver object at 0x0000016655B46690>\n\n    def test_recalculate(self, resolver):\n        \"\"\"The first pick \"the_dcc==1.2\" gets discarded by plugin_b. Make sure the correct\n        distros are picked.\n        \"\"\"\n    \n        # Resolve requires re-calculating\n        # Note: To have a stable test, the order of requirements matters. Use an OrderedDict\n        requirements = OrderedDict(\n            (\n                (\"the_dcc\", Requirement(\"the_dcc\")),\n                (\"the_dcc_plugin_b\", Requirement(\"the_dcc_plugin_b==0.9\")),\n            )\n        )\n    \n        # Use the underlying Solver so we have access to debug resolve_requirements obscures\n        solver = Solver(requirements, resolver)\n>       resolved = solver.resolve()\n\ntests\\test_resolver.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655B47080>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655B46690>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_recalculate[cached]",
      "lineno": 433,
      "outcome": "error",
      "keywords": [
        "test_recalculate[cached]",
        "cached",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_recalculate[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_markers[uncached-windows-Windows]",
      "lineno": 486,
      "outcome": "failed",
      "keywords": [
        "test_markers[uncached-windows-Windows]",
        "parametrize",
        "pytestmark",
        "uncached-windows-Windows",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 522,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 381,
            "message": "in resolve_requirements"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestResolveRequirements object at 0x0000016654546120>\nresolver = <hab.resolver.Resolver object at 0x0000016655A12030>\nplatform = 'windows', marker = 'Windows'\n\n    @pytest.mark.parametrize(\n        \"platform,marker\",\n        (\n            (\"windows\", \"Windows\"),\n            (\"linux\", \"Linux\"),\n            (\"osx\", \"Darwin\"),\n        ),\n    )\n    def test_markers(self, resolver, platform, marker):\n        \"\"\"Test that platform_system for current host is included or excluded correctly.\n    \n        The packaging marker library isn't setup to allow for testing on other\n        platforms, so these tests need to pass on all platforms, if running the test\n        on this platform, the dependency is included, otherwise it should be ignored.\n        \"\"\"\n        check = [\n            \"the_dcc\",\n            \"the_dcc_plugin_a\",\n            \"the_dcc_plugin_b\",\n            \"the_dcc_plugin_d\",\n            \"the_dcc_plugin_e\",\n        ]\n        # This requirement is only included if running on the target platform\n        if utils.Platform.name() == platform:\n            check.append(\"the_dcc_plugin_c\")\n    \n        # Build requirements utilizing the platform marker.\n        requirements = {\n            \"the_dcc\": Requirement(\"the_dcc\"),\n            # the_dcc_plugin_c is only included if the current platform matches that.\n            \"the_dcc_plugin_c\": Requirement(\n                f\"the_dcc_plugin_c;platform_system=='{marker}'\"\n            ),\n        }\n    \n>       ret = resolver.resolve_requirements(requirements)\n\ntests\\test_resolver.py:522: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:381: in resolve_requirements\n    return solver.resolve()\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655B467B0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A12030>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_markers[uncached-linux-Linux]",
      "lineno": 486,
      "outcome": "failed",
      "keywords": [
        "test_markers[uncached-linux-Linux]",
        "parametrize",
        "pytestmark",
        "uncached-linux-Linux",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 522,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 381,
            "message": "in resolve_requirements"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestResolveRequirements object at 0x0000016654546000>\nresolver = <hab.resolver.Resolver object at 0x0000016655BB3EC0>\nplatform = 'linux', marker = 'Linux'\n\n    @pytest.mark.parametrize(\n        \"platform,marker\",\n        (\n            (\"windows\", \"Windows\"),\n            (\"linux\", \"Linux\"),\n            (\"osx\", \"Darwin\"),\n        ),\n    )\n    def test_markers(self, resolver, platform, marker):\n        \"\"\"Test that platform_system for current host is included or excluded correctly.\n    \n        The packaging marker library isn't setup to allow for testing on other\n        platforms, so these tests need to pass on all platforms, if running the test\n        on this platform, the dependency is included, otherwise it should be ignored.\n        \"\"\"\n        check = [\n            \"the_dcc\",\n            \"the_dcc_plugin_a\",\n            \"the_dcc_plugin_b\",\n            \"the_dcc_plugin_d\",\n            \"the_dcc_plugin_e\",\n        ]\n        # This requirement is only included if running on the target platform\n        if utils.Platform.name() == platform:\n            check.append(\"the_dcc_plugin_c\")\n    \n        # Build requirements utilizing the platform marker.\n        requirements = {\n            \"the_dcc\": Requirement(\"the_dcc\"),\n            # the_dcc_plugin_c is only included if the current platform matches that.\n            \"the_dcc_plugin_c\": Requirement(\n                f\"the_dcc_plugin_c;platform_system=='{marker}'\"\n            ),\n        }\n    \n>       ret = resolver.resolve_requirements(requirements)\n\ntests\\test_resolver.py:522: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:381: in resolve_requirements\n    return solver.resolve()\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655BB0290>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BB3EC0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_markers[uncached-osx-Darwin]",
      "lineno": 486,
      "outcome": "failed",
      "keywords": [
        "test_markers[uncached-osx-Darwin]",
        "parametrize",
        "pytestmark",
        "uncached-osx-Darwin",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 522,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 381,
            "message": "in resolve_requirements"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestResolveRequirements object at 0x0000016654546330>\nresolver = <hab.resolver.Resolver object at 0x0000016655BB3BC0>\nplatform = 'osx', marker = 'Darwin'\n\n    @pytest.mark.parametrize(\n        \"platform,marker\",\n        (\n            (\"windows\", \"Windows\"),\n            (\"linux\", \"Linux\"),\n            (\"osx\", \"Darwin\"),\n        ),\n    )\n    def test_markers(self, resolver, platform, marker):\n        \"\"\"Test that platform_system for current host is included or excluded correctly.\n    \n        The packaging marker library isn't setup to allow for testing on other\n        platforms, so these tests need to pass on all platforms, if running the test\n        on this platform, the dependency is included, otherwise it should be ignored.\n        \"\"\"\n        check = [\n            \"the_dcc\",\n            \"the_dcc_plugin_a\",\n            \"the_dcc_plugin_b\",\n            \"the_dcc_plugin_d\",\n            \"the_dcc_plugin_e\",\n        ]\n        # This requirement is only included if running on the target platform\n        if utils.Platform.name() == platform:\n            check.append(\"the_dcc_plugin_c\")\n    \n        # Build requirements utilizing the platform marker.\n        requirements = {\n            \"the_dcc\": Requirement(\"the_dcc\"),\n            # the_dcc_plugin_c is only included if the current platform matches that.\n            \"the_dcc_plugin_c\": Requirement(\n                f\"the_dcc_plugin_c;platform_system=='{marker}'\"\n            ),\n        }\n    \n>       ret = resolver.resolve_requirements(requirements)\n\ntests\\test_resolver.py:522: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:381: in resolve_requirements\n    return solver.resolve()\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655BB1640>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BB3BC0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_markers[cached-windows-Windows]",
      "lineno": 486,
      "outcome": "error",
      "keywords": [
        "test_markers[cached-windows-Windows]",
        "parametrize",
        "pytestmark",
        "cached-windows-Windows",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_markers[cached-windows-Windows]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_markers[cached-linux-Linux]",
      "lineno": 486,
      "outcome": "error",
      "keywords": [
        "test_markers[cached-linux-Linux]",
        "parametrize",
        "pytestmark",
        "cached-linux-Linux",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_markers[cached-linux-Linux]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_markers[cached-osx-Darwin]",
      "lineno": 486,
      "outcome": "error",
      "keywords": [
        "test_markers[cached-osx-Darwin]",
        "parametrize",
        "pytestmark",
        "cached-osx-Darwin",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_markers[cached-osx-Darwin]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_forced_requirements[uncached-None-check0-check_versions0]",
      "lineno": 524,
      "outcome": "failed",
      "keywords": [
        "test_forced_requirements[uncached-None-check0-check_versions0]",
        "parametrize",
        "pytestmark",
        "uncached-None-check0-check_versions0",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 566,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 381,
            "message": "in resolve_requirements"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestResolveRequirements object at 0x0000016654546900>\nresolver = <hab.resolver.Resolver object at 0x0000016655BB4860>\nhelpers = <class 'conftest.Helpers'>, forced = None\ncheck = ['the_dcc_plugin_a', 'the_dcc_plugin_d', 'the_dcc_plugin_e<1.0,<2.0']\ncheck_versions = []\n\n    @pytest.mark.parametrize(\n        \"forced,check,check_versions\",\n        (\n            # No forced items\n            (\n                None,\n                [\"the_dcc_plugin_a\", \"the_dcc_plugin_d\", \"the_dcc_plugin_e<1.0,<2.0\"],\n                [],\n            ),\n            # Force\n            (\n                {\n                    # Adds a completely new requirement not specified in the config\n                    \"the_dcc_plugin_c\": Requirement(\"the_dcc_plugin_c\"),\n                    # Forces the requirement to a invalid version for the config\n                    \"the_dcc_plugin_e\": Requirement(\"the_dcc_plugin_e==1.1\"),\n                },\n                [\n                    \"the_dcc_plugin_a\",\n                    \"the_dcc_plugin_c\",\n                    \"the_dcc_plugin_d\",\n                    \"the_dcc_plugin_e==1.1\",\n                ],\n                [\"the_dcc_plugin_c==1.1\", \"the_dcc_plugin_e==1.1\"],\n            ),\n        ),\n    )\n    def test_forced_requirements(\n        self, resolver, helpers, forced, check, check_versions\n    ):\n        requirements = {\n            # plugin_a adds an extra dependency outside of the requirements or forced\n            \"the_dcc_plugin_a\": Requirement(\"the_dcc_plugin_a\"),\n            \"the_dcc_plugin_e\": Requirement(\"the_dcc_plugin_e<1.0\"),\n        }\n    \n        # Check that forced_requirement's are included in the resolved requirements\n        resolver_forced = Resolver(\n            site=resolver.site,\n            forced_requirements=forced,\n        )\n>       resolved = resolver_forced.resolve_requirements(requirements)\n\ntests\\test_resolver.py:566: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:381: in resolve_requirements\n    return solver.resolve()\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655BB4D40>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BB4CE0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_forced_requirements[uncached-forced1-check1-check_versions1]",
      "lineno": 524,
      "outcome": "failed",
      "keywords": [
        "test_forced_requirements[uncached-forced1-check1-check_versions1]",
        "parametrize",
        "pytestmark",
        "uncached-forced1-check1-check_versions1",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 566,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 381,
            "message": "in resolve_requirements"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestResolveRequirements object at 0x0000016654546810>\nresolver = <hab.resolver.Resolver object at 0x0000016655BB0740>\nhelpers = <class 'conftest.Helpers'>\nforced = {'the_dcc_plugin_c': <Requirement('the_dcc_plugin_c')>, 'the_dcc_plugin_e': <Requirement('the_dcc_plugin_e==1.1')>}\ncheck = ['the_dcc_plugin_a', 'the_dcc_plugin_c', 'the_dcc_plugin_d', 'the_dcc_plugin_e==1.1']\ncheck_versions = ['the_dcc_plugin_c==1.1', 'the_dcc_plugin_e==1.1']\n\n    @pytest.mark.parametrize(\n        \"forced,check,check_versions\",\n        (\n            # No forced items\n            (\n                None,\n                [\"the_dcc_plugin_a\", \"the_dcc_plugin_d\", \"the_dcc_plugin_e<1.0,<2.0\"],\n                [],\n            ),\n            # Force\n            (\n                {\n                    # Adds a completely new requirement not specified in the config\n                    \"the_dcc_plugin_c\": Requirement(\"the_dcc_plugin_c\"),\n                    # Forces the requirement to a invalid version for the config\n                    \"the_dcc_plugin_e\": Requirement(\"the_dcc_plugin_e==1.1\"),\n                },\n                [\n                    \"the_dcc_plugin_a\",\n                    \"the_dcc_plugin_c\",\n                    \"the_dcc_plugin_d\",\n                    \"the_dcc_plugin_e==1.1\",\n                ],\n                [\"the_dcc_plugin_c==1.1\", \"the_dcc_plugin_e==1.1\"],\n            ),\n        ),\n    )\n    def test_forced_requirements(\n        self, resolver, helpers, forced, check, check_versions\n    ):\n        requirements = {\n            # plugin_a adds an extra dependency outside of the requirements or forced\n            \"the_dcc_plugin_a\": Requirement(\"the_dcc_plugin_a\"),\n            \"the_dcc_plugin_e\": Requirement(\"the_dcc_plugin_e<1.0\"),\n        }\n    \n        # Check that forced_requirement's are included in the resolved requirements\n        resolver_forced = Resolver(\n            site=resolver.site,\n            forced_requirements=forced,\n        )\n>       resolved = resolver_forced.resolve_requirements(requirements)\n\ntests\\test_resolver.py:566: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:381: in resolve_requirements\n    return solver.resolve()\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655BB09E0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BB08C0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_forced_requirements[cached-None-check0-check_versions0]",
      "lineno": 524,
      "outcome": "error",
      "keywords": [
        "test_forced_requirements[cached-None-check0-check_versions0]",
        "parametrize",
        "pytestmark",
        "cached-None-check0-check_versions0",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_forced_requirements[cached-None-check0-check_versions0]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_forced_requirements[cached-forced1-check1-check_versions1]",
      "lineno": 524,
      "outcome": "error",
      "keywords": [
        "test_forced_requirements[cached-forced1-check1-check_versions1]",
        "parametrize",
        "pytestmark",
        "cached-forced1-check1-check_versions1",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_forced_requirements[cached-forced1-check1-check_versions1]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements0-False-check0]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements0-False-check0]",
        "parametrize",
        "pytestmark",
        "requirements0-False-check0",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements1-True-check1]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements1-True-check1]",
        "parametrize",
        "pytestmark",
        "requirements1-True-check1",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements2-True-check2]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements2-True-check2]",
        "parametrize",
        "pytestmark",
        "requirements2-True-check2",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements3-False-check3]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements3-False-check3]",
        "parametrize",
        "pytestmark",
        "requirements3-False-check3",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements4-True-check4]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements4-True-check4]",
        "parametrize",
        "pytestmark",
        "requirements4-True-check4",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements5-False-check5]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements5-False-check5]",
        "parametrize",
        "pytestmark",
        "requirements5-False-check5",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements6-True-check6]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements6-True-check6]",
        "parametrize",
        "pytestmark",
        "requirements6-True-check6",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements7-False-check7]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements7-False-check7]",
        "parametrize",
        "pytestmark",
        "requirements7-False-check7",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements8-True-False]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements8-True-False]",
        "parametrize",
        "pytestmark",
        "requirements8-True-False",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements9-False-False]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements9-False-False]",
        "parametrize",
        "pytestmark",
        "requirements9-False-False",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements10-True-check10]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements10-True-check10]",
        "parametrize",
        "pytestmark",
        "requirements10-True-check10",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements11-False-check11]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements11-False-check11]",
        "parametrize",
        "pytestmark",
        "requirements11-False-check11",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements12-True-check12]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements12-True-check12]",
        "parametrize",
        "pytestmark",
        "requirements12-True-check12",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements13-False-check13]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements13-False-check13]",
        "parametrize",
        "pytestmark",
        "requirements13-False-check13",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements14-False-check14]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements14-False-check14]",
        "parametrize",
        "pytestmark",
        "requirements14-False-check14",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_pre_releases[requirements15-True-check15]",
      "lineno": 591,
      "outcome": "error",
      "keywords": [
        "test_pre_releases[requirements15-True-check15]",
        "parametrize",
        "pytestmark",
        "requirements15-True-check15",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_forced_requirements_uri[uncached]",
      "lineno": 646,
      "outcome": "failed",
      "keywords": [
        "test_forced_requirements_uri[uncached]",
        "uncached",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 656,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestResolveRequirements object at 0x0000016654547C20>\nresolver = <hab.resolver.Resolver object at 0x00000166544DC110>\nhelpers = <class 'conftest.Helpers'>\n\n    def test_forced_requirements_uri(self, resolver, helpers):\n        resolver_forced = Resolver(\n            site=resolver.site,\n            forced_requirements={\"houdini19.5\": Requirement(\"houdini19.5\")},\n        )\n        # We are checking cfg.versions, so these need to be resolved to `==` requirements\n        check = [\"aliased==2.0\", \"houdini19.5==19.5.493\"]\n    \n        # Forced requirement includes direct distro assignments from the config\n>       cfg = resolver_forced.resolve(\"app/aliased\")\n\ntests\\test_resolver.py:656: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559CF800>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166559CE990>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_forced_requirements_uri[cached]",
      "lineno": 646,
      "outcome": "error",
      "keywords": [
        "test_forced_requirements_uri[cached]",
        "cached",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_forced_requirements_uri[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_override_forced",
      "lineno": 665,
      "outcome": "failed",
      "keywords": [
        "test_override_forced",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 682,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestResolveRequirements object at 0x0000016654547F50>\nuncached_resolver = <hab.resolver.Resolver object at 0x000001665598E1E0>\nhelpers = <class 'conftest.Helpers'>\n\n    def test_override_forced(self, uncached_resolver, helpers):\n        \"\"\"Test forced_requirements passed to `resolve` with global\n        forced_requirements temporarily replaces any already set on the Resolver.\n        \"\"\"\n        hou_requirement = \"houdini19.5==19.5.493\"\n        uncached_resolver = Resolver(\n            site=uncached_resolver.site, forced_requirements=[hou_requirement]\n        )\n        global_requirements = [hou_requirement]\n    \n        # This resolver has the expected forced requirements\n        helpers.assert_requirements_equal(\n            uncached_resolver.forced_requirements, global_requirements\n        )\n    \n        # Passing an override forced_requirement is respected\n>       cfg = uncached_resolver.resolve(\"app/aliased\", forced_requirements=[\"maya2024\"])\n\ntests\\test_resolver.py:682: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166558AED20>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665598E1E0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_override_forced_empty",
      "lineno": 693,
      "outcome": "failed",
      "keywords": [
        "test_override_forced_empty",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 709,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestResolveRequirements object at 0x0000016654570170>\nuncached_resolver = <hab.resolver.Resolver object at 0x0000016655925580>\nhelpers = <class 'conftest.Helpers'>\n\n    def test_override_forced_empty(self, uncached_resolver, helpers):\n        \"\"\"Test forced_requirements passed to `resolve` with global\n        forced_requirements temporarily replaces any already set on the Resolver.\n        \"\"\"\n        hou_requirement = \"houdini19.5==19.5.493\"\n        uncached_resolver = Resolver(\n            site=uncached_resolver.site, forced_requirements=[hou_requirement]\n        )\n        global_requirements = [hou_requirement]\n        # This resolver has the expected forced requirements\n        helpers.assert_requirements_equal(\n            uncached_resolver.forced_requirements, global_requirements\n        )\n    \n        # Passing an forced_requirement override removes the global requirement\n>       cfg = uncached_resolver.resolve(\"app/aliased\", forced_requirements=[])\n\ntests\\test_resolver.py:709: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559264E0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655925580>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestResolveRequirements::test_override_forced_unset",
      "lineno": 720,
      "outcome": "failed",
      "keywords": [
        "test_override_forced_unset",
        "TestResolveRequirements",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 729,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_resolver.TestResolveRequirements object at 0x0000016654570350>\nuncached_resolver = <hab.resolver.Resolver object at 0x0000016655A134D0>\nhelpers = <class 'conftest.Helpers'>\n\n    def test_override_forced_unset(self, uncached_resolver, helpers):\n        \"\"\"Test forced_requirements override passed to `resolve` without any\n        global forced_requirements set on the Resolver.\"\"\"\n    \n        # This resolver has no existing forced_requirements\n        assert uncached_resolver.forced_requirements == {}\n    \n        # Ensure our config doesn't include houdini19.5 by default\n>       cfg = uncached_resolver.resolve(\"app/aliased\")\n\ntests\\test_resolver.py:729: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655A13620>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A134D0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_path_expansion[uncached-test_string-check0]",
      "lineno": 748,
      "outcome": "passed",
      "keywords": [
        "test_path_expansion[uncached-test_string-check0]",
        "parametrize",
        "pytestmark",
        "uncached-test_string-check0",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_path_expansion[uncached-one;two-check1]",
      "lineno": 748,
      "outcome": "passed",
      "keywords": [
        "test_path_expansion[uncached-one;two-check1]",
        "parametrize",
        "pytestmark",
        "uncached-one;two-check1",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_path_expansion[cached-test_string-check0]",
      "lineno": 748,
      "outcome": "error",
      "keywords": [
        "test_path_expansion[cached-test_string-check0]",
        "parametrize",
        "pytestmark",
        "cached-test_string-check0",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_path_expansion[cached-test_string-check0]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_path_expansion[cached-one;two-check1]",
      "lineno": 748,
      "outcome": "error",
      "keywords": [
        "test_path_expansion[cached-one;two-check1]",
        "parametrize",
        "pytestmark",
        "cached-one;two-check1",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_path_expansion[cached-one;two-check1]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_collapse_paths",
      "lineno": 769,
      "outcome": "passed",
      "keywords": [
        "test_collapse_paths",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_pathsep",
      "lineno": 820,
      "outcome": "passed",
      "keywords": [
        "test_pathsep",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[WinPlatform-Path]",
      "lineno": 829,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_preserves_cls[WinPlatform-Path]",
        "parametrize",
        "pytestmark",
        "WinPlatform-Path",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[WinPlatform-PurePath]",
      "lineno": 829,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_preserves_cls[WinPlatform-PurePath]",
        "parametrize",
        "pytestmark",
        "WinPlatform-PurePath",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[WinPlatform-PurePosixPath]",
      "lineno": 829,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_preserves_cls[WinPlatform-PurePosixPath]",
        "parametrize",
        "pytestmark",
        "WinPlatform-PurePosixPath",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[WinPlatform-PureWindowsPath]",
      "lineno": 829,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_preserves_cls[WinPlatform-PureWindowsPath]",
        "parametrize",
        "pytestmark",
        "WinPlatform-PureWindowsPath",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[LinuxPlatform-Path]",
      "lineno": 829,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_preserves_cls[LinuxPlatform-Path]",
        "parametrize",
        "pytestmark",
        "LinuxPlatform-Path",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[LinuxPlatform-PurePath]",
      "lineno": 829,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_preserves_cls[LinuxPlatform-PurePath]",
        "parametrize",
        "pytestmark",
        "LinuxPlatform-PurePath",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[LinuxPlatform-PurePosixPath]",
      "lineno": 829,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_preserves_cls[LinuxPlatform-PurePosixPath]",
        "parametrize",
        "pytestmark",
        "LinuxPlatform-PurePosixPath",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[LinuxPlatform-PureWindowsPath]",
      "lineno": 829,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_preserves_cls[LinuxPlatform-PureWindowsPath]",
        "parametrize",
        "pytestmark",
        "LinuxPlatform-PureWindowsPath",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[OsxPlatform-Path]",
      "lineno": 829,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_preserves_cls[OsxPlatform-Path]",
        "parametrize",
        "pytestmark",
        "OsxPlatform-Path",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[OsxPlatform-PurePath]",
      "lineno": 829,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_preserves_cls[OsxPlatform-PurePath]",
        "parametrize",
        "pytestmark",
        "OsxPlatform-PurePath",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[OsxPlatform-PurePosixPath]",
      "lineno": 829,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_preserves_cls[OsxPlatform-PurePosixPath]",
        "parametrize",
        "pytestmark",
        "OsxPlatform-PurePosixPath",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_preserves_cls[OsxPlatform-PureWindowsPath]",
      "lineno": 829,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_preserves_cls[OsxPlatform-PureWindowsPath]",
        "parametrize",
        "pytestmark",
        "OsxPlatform-PureWindowsPath",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[c:\\\\temp-C:/temp]",
      "lineno": 847,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_windows[c:\\\\temp-C:/temp]",
        "parametrize",
        "pytestmark",
        "c:\\\\temp-C:/temp",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[C:\\\\temp-C:/temp]",
      "lineno": 847,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_windows[C:\\\\temp-C:/temp]",
        "parametrize",
        "pytestmark",
        "C:\\\\temp-C:/temp",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[C:\\\\teMP-C:/teMP]",
      "lineno": 847,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_windows[C:\\\\teMP-C:/teMP]",
        "parametrize",
        "pytestmark",
        "C:\\\\teMP-C:/teMP",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[z:\\\\subfolder-Z:/subfolder]",
      "lineno": 847,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_windows[z:\\\\subfolder-Z:/subfolder]",
        "parametrize",
        "pytestmark",
        "z:\\\\subfolder-Z:/subfolder",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[relative\\\\path-relative/path]",
      "lineno": 847,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_windows[relative\\\\path-relative/path]",
        "parametrize",
        "pytestmark",
        "relative\\\\path-relative/path",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[\\\\\\\\unc\\\\share\\\\folder-//unc/share/folder]",
      "lineno": 847,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_windows[\\\\\\\\unc\\\\share\\\\folder-//unc/share/folder]",
        "parametrize",
        "pytestmark",
        "\\\\\\\\unc\\\\share\\\\folder-//unc/share/folder",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::TestPlatform::test_normalize_path_windows[\\\\\\\\UnC\\\\shaRe\\\\folDer-//UnC/shaRe/folDer]",
      "lineno": 847,
      "outcome": "passed",
      "keywords": [
        "test_normalize_path_windows[\\\\\\\\UnC\\\\shaRe\\\\folDer-//UnC/shaRe/folDer]",
        "parametrize",
        "pytestmark",
        "\\\\\\\\UnC\\\\shaRe\\\\folDer-//UnC/shaRe/folDer",
        "TestPlatform",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_cygpath",
      "lineno": 866,
      "outcome": "passed",
      "keywords": [
        "test_cygpath",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_natrual_sort",
      "lineno": 910,
      "outcome": "passed",
      "keywords": [
        "test_natrual_sort",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_star_import",
      "lineno": 931,
      "outcome": "passed",
      "keywords": [
        "test_star_import",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_clear_caches[uncached]",
      "lineno": 956,
      "outcome": "failed",
      "keywords": [
        "test_clear_caches[uncached]",
        "uncached",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 964,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "resolver = <hab.resolver.Resolver object at 0x0000016655BF0470>\n\n    def test_clear_caches(resolver):\n        \"\"\"Test that Resolver.clear_cache works as expected.\"\"\"\n        # Resolver cache is empty\n        assert resolver._configs is None\n        assert resolver._distros is None\n    \n        # Populate resolver cache data\n>       resolver.resolve(\"not_set\")\n\ntests\\test_resolver.py:964: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655BF09E0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BF0470>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_clear_caches[cached]",
      "lineno": 956,
      "outcome": "error",
      "keywords": [
        "test_clear_caches[cached]",
        "cached",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 111,
            "message": ""
          },
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": "in habcached_site_file"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "request = <SubRequest 'resolver' for <Function test_clear_caches[cached]>>\n\n    @pytest.fixture(params=resolver_tests)\n    def resolver(request):\n        \"\"\"Returns a hab.Resolver instance using the site_main.json site config file.\n    \n        This is a parameterized fixture that returns both cached and uncached versions\n        of the `site_main.json` site configuration. Note the cached version uses a\n        copy of it stored in the `_cache0` directory of the pytest temp files. This\n        should be used for most tests to ensure that all features are tested, but if\n        the test is not affected by caching you can use `uncached_resolver` instead.\n        \"\"\"\n        test_map = {\"uncached\": \"uncached_resolver\", \"cached\": \"habcached_resolver\"}\n>       return request.getfixturevalue(test_map[request.param])\n\ntests\\conftest.py:111: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\conftest.py:72: in habcached_site_file\n    site.cache.save_cache(resolver, ret)\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_clear_caches_cached",
      "lineno": 975,
      "outcome": "error",
      "keywords": [
        "test_clear_caches_cached",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_uri_validate",
      "lineno": 987,
      "outcome": "failed",
      "keywords": [
        "test_uri_validate",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_resolver.py",
            "lineno": 1006,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\n\n    def test_uri_validate(config_root):\n        \"\"\"Test the `hab.uri.validate` entry_point.\"\"\"\n        resolver = Resolver(\n            site=Site(\n                [\n                    config_root / \"site\" / \"site_ep_uri_validate.json\",\n                    config_root / \"site_main.json\",\n                ]\n            )\n        )\n    \n        # Test if an entry_point raises an exception\n        with pytest.raises(\n            Exception, match=r'URI \"raise-error\" was used, raising an exception.'\n        ):\n            cfg = resolver.resolve(\"raise-error\")\n    \n        # \"project_a\" should be lower cased by the first validator.\n>       cfg = resolver.resolve(\"pRoJect_A/CammelCase\")\n\ntests\\test_resolver.py:1006: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655BBFB90>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BBD160>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_resolver.py::test_instance",
      "lineno": 1023,
      "outcome": "passed",
      "keywords": [
        "test_instance",
        "test_resolver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[bat_activate]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[bat_activate]",
        "parametrize",
        "pytestmark",
        "bat_activate",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: CMD: Tests `hab activate not_set/child`\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655BBD880>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_bat_activate_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655BBDD60>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'bat_activate'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655BBE270>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BBD880>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[bat_activate_launch]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[bat_activate_launch]",
        "parametrize",
        "pytestmark",
        "bat_activate_launch",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: CMD: Tests `hab activate not_set/child --launch pip` without arguments\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655BF3800>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_bat_activate_laun0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655BF1730>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'bat_activate_launch'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655BBDD30>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BF3800>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[bat_env]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[bat_env]",
        "parametrize",
        "pytestmark",
        "bat_env",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: CMD: Tests `hab env not_set/child`\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655BBFE00>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_bat_env_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C735C0>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'bat_env'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C73E30>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BBFE00>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[bat_env_launch]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[bat_env_launch]",
        "parametrize",
        "pytestmark",
        "bat_env_launch",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: CMD: Tests hab env not_set/child --launch pip`\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C70290>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_bat_env_launch_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C73A10>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'bat_env_launch'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C709E0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C70290>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[bat_launch]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[bat_launch]",
        "parametrize",
        "pytestmark",
        "bat_launch",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: CMD: Tests `hab launch not_set/child pip` without passing arguments\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C71E80>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_bat_launch_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C72C30>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'bat_launch'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C72600>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C71E80>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[bat_launch_args]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[bat_launch_args]",
        "parametrize",
        "pytestmark",
        "bat_launch_args",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: CMD: Tests `hab launch not_set/child as_str` passing a complex string argument to python\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655BBF1A0>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_bat_launch_args_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655BBF650>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'bat_launch_args'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655BBD490>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BBF1A0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[ps1_activate]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[ps1_activate]",
        "parametrize",
        "pytestmark",
        "ps1_activate",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: PowerShell: Tests `hab activate not_set/child`\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C714F0>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_ps1_activate_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C73A10>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'ps1_activate'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C707D0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C714F0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[ps1_activate_launch]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[ps1_activate_launch]",
        "parametrize",
        "pytestmark",
        "ps1_activate_launch",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: PowerShell: Tests `hab activate not_set/child --launch pip` without arguments\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C78A70>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_ps1_activate_laun0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C780B0>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'ps1_activate_launch'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C78290>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C78A70>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[ps1_env]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[ps1_env]",
        "parametrize",
        "pytestmark",
        "ps1_env",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: PowerShell: Tests `hab env not_set/child`\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C791F0>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_ps1_env_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C78F50>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'ps1_env'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C79850>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C791F0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[ps1_env_launch]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[ps1_env_launch]",
        "parametrize",
        "pytestmark",
        "ps1_env_launch",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: PowerShell: Tests hab env not_set/child --launch pip`\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C70F50>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_ps1_env_launch_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C712E0>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'ps1_env_launch'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C72810>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C70F50>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[ps1_launch]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[ps1_launch]",
        "parametrize",
        "pytestmark",
        "ps1_launch",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: PowerShell: Tests `hab launch not_set/child pip` without passing arguments\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655BBF6B0>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_ps1_launch_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C79DC0>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'ps1_launch'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C7B9B0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BBF6B0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[ps1_launch_args]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[ps1_launch_args]",
        "parametrize",
        "pytestmark",
        "ps1_launch_args",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: PowerShell: Tests `hab launch not_set/child as_str` passing a complex string argument to python\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C78AA0>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_ps1_launch_args_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C7B230>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'ps1_launch_args'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C7ADB0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C78AA0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[sh_linux_activate]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[sh_linux_activate]",
        "parametrize",
        "pytestmark",
        "sh_linux_activate",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: Bash for Linux: Tests `hab activate not_set/child`\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C99340>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_sh_linux_activate0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C9B380>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'sh_linux_activate'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C9B4A0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C99340>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[sh_linux_activate_launch]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[sh_linux_activate_launch]",
        "parametrize",
        "pytestmark",
        "sh_linux_activate_launch",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: Bash for Linux: Tests `hab activate not_set/child --launch pip` without arguments\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C7B020>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_sh_linux_activate1')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C78200>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'sh_linux_activate_launch'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C7AC90>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C7B020>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[sh_linux_env]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[sh_linux_env]",
        "parametrize",
        "pytestmark",
        "sh_linux_env",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: Bash for Linux: Tests `hab env not_set/child`\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655BF17F0>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_sh_linux_env_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C70E90>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'sh_linux_env'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C71160>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BF17F0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[sh_linux_env_launch]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[sh_linux_env_launch]",
        "parametrize",
        "pytestmark",
        "sh_linux_env_launch",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: Bash for Linux: Tests hab env not_set/child --launch pip`\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C98290>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_sh_linux_env_laun0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C98AA0>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'sh_linux_env_launch'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C989E0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C98290>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[sh_linux_launch]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[sh_linux_launch]",
        "parametrize",
        "pytestmark",
        "sh_linux_launch",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: Bash for Linux: Tests `hab launch not_set/child pip` without passing arguments\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C9AAE0>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_sh_linux_launch_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C9B800>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'sh_linux_launch'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C9B4D0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C9AAE0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[sh_linux_launch_args]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[sh_linux_launch_args]",
        "parametrize",
        "pytestmark",
        "sh_linux_launch_args",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: Bash for Linux: Tests `hab launch not_set/child as_str` passing a complex string argument to python\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C997F0>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_sh_linux_launch_a0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C9A660>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'sh_linux_launch_args'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655BF18B0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C997F0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[sh_win_activate]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[sh_win_activate]",
        "parametrize",
        "pytestmark",
        "sh_win_activate",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: Bash for Windows: Tests `hab activate not_set/child`\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655C9B050>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_sh_win_activate_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C9B9B0>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'sh_win_activate'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C9B8C0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C9B050>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[sh_win_activate_launch]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[sh_win_activate_launch]",
        "parametrize",
        "pytestmark",
        "sh_win_activate_launch",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: Bash for Windows: Tests `hab activate not_set/child --launch pip` without arguments\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655BF0200>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_sh_win_activate_l0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655BF1130>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'sh_win_activate_launch'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559792B0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BF0200>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[sh_win_env]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[sh_win_env]",
        "parametrize",
        "pytestmark",
        "sh_win_env",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: Bash for Windows: Tests `hab env not_set/child`\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x00000166544DD610>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_sh_win_env_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001665598EC60>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'sh_win_env'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x000001665598FA40>\nargs = ({}, <hab.resolver.Resolver object at 0x00000166544DD610>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[sh_win_env_launch]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[sh_win_env_launch]",
        "parametrize",
        "pytestmark",
        "sh_win_env_launch",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: Bash for Windows: Tests hab env not_set/child --launch pip`\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655A51880>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_sh_win_env_launch0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655A50F20>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'sh_win_env_launch'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655A505C0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655A51880>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[sh_win_launch]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[sh_win_launch]",
        "parametrize",
        "pytestmark",
        "sh_win_launch",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: Bash for Windows: Tests `hab launch not_set/child pip` without passing arguments\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x000001665598F8F0>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_sh_win_launch_0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x00000166558FE9C0>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'sh_win_launch'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x00000166559261B0>\nargs = ({}, <hab.resolver.Resolver object at 0x000001665598F8F0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_scripts[sh_win_launch_args]",
      "lineno": 15,
      "outcome": "failed",
      "keywords": [
        "test_scripts[sh_win_launch_args]",
        "parametrize",
        "pytestmark",
        "sh_win_launch_args",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 65,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "stdout": "Testing: Bash for Windows: Tests `hab launch not_set/child as_str` passing a complex string argument to python\n",
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655BF15B0>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_scripts_sh_win_launch_arg0')\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000016655C98410>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nreference_name = 'sh_win_launch_args'\n\n    @pytest.mark.parametrize(\"reference_name\", reference_names)\n    def test_scripts(uncached_resolver, tmpdir, monkeypatch, config_root, reference_name):\n        \"\"\"Checks all of the scripts HabBase.write_script generates for a specified\n        set of arguments.\n    \n        This is a parametrized test, and each folder inside the tests/reference_scripts\n        directory adds a test. Each directory needs a spec.json file similar to this::\n    \n            {\n                \"description\": \"[shell and platform]: Tests `hab [command] [uri]`\",\n                \"ext\": \".sh\",\n                \"launch\": null,\n                \"exiting\": false,\n                \"args\": null,\n                \"create_launch\": false,\n                \"platform\": \"linux\",\n                \"uri\": \"not_set/child\"\n            }\n    \n        A reference directory needs to have at least one script file generated by hab,\n        and all files are expected to be created by write_script.\n    \n        To add a new test, create the new directory and add the desired spec file.\n        Run the test(it will fail) and in the pytest temp directory you can find the\n        script files that hab generated for your spec. Copy them into your reference\n        directory. You will then need to replace the hard coded file paths with jinja2\n        templates to ensure your test will pass on the next run of pytest, as well\n        as when the git checkout is in a different location. There are a few required\n        replacements needed:\n    \n        1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining\n            paths to tmpdir, do it as part of the format to ensure correct slash\n            direction. `{{ tmpdir / \"filename.txt\" }}`\n        2. Replace the path to your checkout's tests directory with `{{ config_root }}`\n            making sure to convert back slashes to forward slashes\n        3. Replace the HAB_FREEZE value with `{{ freeze }}`.\n        \"\"\"\n        reference = reference_scripts / reference_name\n        spec = json.load((reference / \"spec.json\").open())\n    \n        if \"description\" in spec:\n            print(f\"Testing: {spec['description']}\")\n    \n        # Script formatting is subtly different on different platforms, ensure we\n        # are testing the requested platform, not the current one.\n        platform = spec[\"platform\"]\n        assert platform in (\"linux\", \"osx\", \"win32\")\n        monkeypatch.setattr(utils, \"Platform\", utils.BasePlatform.get_platform(platform))\n    \n>       cfg = uncached_resolver.resolve(spec[\"uri\"])\n\ntests\\test_scripts.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C9A270>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BF15B0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_complex_alias_bat",
      "lineno": 173,
      "outcome": "skipped",
      "keywords": [
        "test_complex_alias_bat",
        "skip",
        "pytestmark",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\test_scripts.py', 174, 'Skipped: Find a way to test complex alias evaluation in pytest')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_complex_alias_ps1",
      "lineno": 210,
      "outcome": "skipped",
      "keywords": [
        "test_complex_alias_ps1",
        "skip",
        "pytestmark",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\test_scripts.py', 211, 'Skipped: Find a way to test complex alias evaluation in pytest')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_complex_alias_sh",
      "lineno": 247,
      "outcome": "skipped",
      "keywords": [
        "test_complex_alias_sh",
        "skip",
        "pytestmark",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\test_scripts.py', 248, 'Skipped: Find a way to test complex alias evaluation in pytest')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_invalid_alias[.bat]",
      "lineno": 284,
      "outcome": "failed",
      "keywords": [
        "test_invalid_alias[.bat]",
        "parametrize",
        "pytestmark",
        ".bat",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 293,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655B44F80>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_invalid_alias__bat_0')\next = '.bat'\n\n    @pytest.mark.parametrize(\"ext\", (\".bat\", \".ps1\", \".sh\"))\n    def test_invalid_alias(uncached_resolver, tmpdir, ext):\n        \"\"\"Check that useful errors are raised if an invalid alias is passed or if\n        the alias doesn't have \"cmd\" defined.\n        \"\"\"\n        kwargs = dict(ext=ext, exit=True, args=None, create_launch=True)\n    \n        # Check that calling a bad alias name raises a useful error message\n>       cfg = uncached_resolver.resolve(\"not_set/child\")\n\ntests\\test_scripts.py:293: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655B44380>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655B44F80>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_invalid_alias[.ps1]",
      "lineno": 284,
      "outcome": "failed",
      "keywords": [
        "test_invalid_alias[.ps1]",
        "parametrize",
        "pytestmark",
        ".ps1",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 293,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655BB17C0>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_invalid_alias__ps1_0')\next = '.ps1'\n\n    @pytest.mark.parametrize(\"ext\", (\".bat\", \".ps1\", \".sh\"))\n    def test_invalid_alias(uncached_resolver, tmpdir, ext):\n        \"\"\"Check that useful errors are raised if an invalid alias is passed or if\n        the alias doesn't have \"cmd\" defined.\n        \"\"\"\n        kwargs = dict(ext=ext, exit=True, args=None, create_launch=True)\n    \n        # Check that calling a bad alias name raises a useful error message\n>       cfg = uncached_resolver.resolve(\"not_set/child\")\n\ntests\\test_scripts.py:293: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C9BBF0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BB17C0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_scripts.py::test_invalid_alias[.sh]",
      "lineno": 284,
      "outcome": "failed",
      "keywords": [
        "test_invalid_alias[.sh]",
        "parametrize",
        "pytestmark",
        ".sh",
        "test_scripts.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_scripts.py",
            "lineno": 293,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655B44830>\ntmpdir = local('C:\\\\Users\\\\Mohay\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-Mohay\\\\pytest-1195\\\\test_invalid_alias__sh_0')\next = '.sh'\n\n    @pytest.mark.parametrize(\"ext\", (\".bat\", \".ps1\", \".sh\"))\n    def test_invalid_alias(uncached_resolver, tmpdir, ext):\n        \"\"\"Check that useful errors are raised if an invalid alias is passed or if\n        the alias doesn't have \"cmd\" defined.\n        \"\"\"\n        kwargs = dict(ext=ext, exit=True, args=None, create_launch=True)\n    \n        # Check that calling a bad alias name raises a useful error message\n>       cfg = uncached_resolver.resolve(\"not_set/child\")\n\ntests\\test_scripts.py:293: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655B45550>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655B44830>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::test_environment_variables",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_environment_variables",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestMultipleSites::test_left",
      "lineno": 69,
      "outcome": "passed",
      "keywords": [
        "test_left",
        "TestMultipleSites",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestMultipleSites::test_middle",
      "lineno": 81,
      "outcome": "passed",
      "keywords": [
        "test_middle",
        "TestMultipleSites",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestMultipleSites::test_right",
      "lineno": 93,
      "outcome": "passed",
      "keywords": [
        "test_right",
        "TestMultipleSites",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestMultipleSites::test_left_right",
      "lineno": 105,
      "outcome": "passed",
      "keywords": [
        "test_left_right",
        "TestMultipleSites",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestMultipleSites::test_right_left",
      "lineno": 129,
      "outcome": "passed",
      "keywords": [
        "test_right_left",
        "TestMultipleSites",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestMultipleSites::test_left_middle_right",
      "lineno": 154,
      "outcome": "passed",
      "keywords": [
        "test_left_middle_right",
        "TestMultipleSites",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestResolvePaths::test_path",
      "lineno": 184,
      "outcome": "passed",
      "keywords": [
        "test_path",
        "TestResolvePaths",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestResolvePaths::test_paths",
      "lineno": 192,
      "outcome": "passed",
      "keywords": [
        "test_paths",
        "TestResolvePaths",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestResolvePaths::test_paths_reversed",
      "lineno": 215,
      "outcome": "passed",
      "keywords": [
        "test_paths_reversed",
        "TestResolvePaths",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::test_path_in_raise",
      "lineno": 238,
      "outcome": "passed",
      "keywords": [
        "test_path_in_raise",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::test_dump",
      "lineno": 246,
      "outcome": "passed",
      "keywords": [
        "test_dump",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::test_dump_cached",
      "lineno": 272,
      "outcome": "error",
      "keywords": [
        "test_dump_cached",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\conftest.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "hab\\cache.py",
            "lineno": 222,
            "message": "in save_cache"
          },
          {
            "path": "hab\\cache.py",
            "lineno": 136,
            "message": "in generate_cache"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "config_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\ntmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=<pluggy._tracing.TagTracerSub object at 0x0000016653C5E4E0>, _basetemp=WindowsPath('C:/Users/Mohay/AppData/Local/Temp/pytest-of-Mohay/pytest-1195'), _retention_count=3, _retention_policy='all')\n\n    @pytest.fixture(scope=\"session\")\n    def habcached_site_file(config_root, tmp_path_factory):\n        \"\"\"Generates a site.json file and generates its habcache file.\n        This file is stored in a `_cache` directory in the pytest directory.\n        This persists for the entire testing session and can be used by other tests\n        that need to test hab when it is using a habcache.\n        \"\"\"\n        # Create the site file\n        shared = tmp_path_factory.mktemp(\"_cache\")\n        ret = generate_habcached_site_file(config_root, shared)\n    \n        # Generate the habcache file\n        site = Site([ret])\n        resolver = Resolver(site)\n>       site.cache.save_cache(resolver, ret)\n\ntests\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\cache.py:222: in save_cache\n    cache = self.generate_cache(resolver, site_file, version=version)\nhab\\cache.py:136: in generate_cache\n    data = cls(forest={}, resolver=resolver)._load(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016654660F50>, args = ()\nkwargs = {'forest': {}, 'resolver': <hab.resolver.Resolver object at 0x0000016654660C80>}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestOsSpecific::test_linux",
      "lineno": 332,
      "outcome": "passed",
      "keywords": [
        "test_linux",
        "TestOsSpecific",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestOsSpecific::test_osx",
      "lineno": 345,
      "outcome": "passed",
      "keywords": [
        "test_osx",
        "TestOsSpecific",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestOsSpecific::test_win",
      "lineno": 358,
      "outcome": "passed",
      "keywords": [
        "test_win",
        "TestOsSpecific",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestPlatformPathMap::test_linux",
      "lineno": 373,
      "outcome": "passed",
      "keywords": [
        "test_linux",
        "TestPlatformPathMap",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestPlatformPathMap::test_win",
      "lineno": 406,
      "outcome": "passed",
      "keywords": [
        "test_win",
        "TestPlatformPathMap",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestPlatformPathMap::test_unset_variables",
      "lineno": 450,
      "outcome": "passed",
      "keywords": [
        "test_unset_variables",
        "TestPlatformPathMap",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestPlatformPathMapDict::test_main",
      "lineno": 486,
      "outcome": "passed",
      "keywords": [
        "test_main",
        "TestPlatformPathMapDict",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestPlatformPathMapDict::test_override",
      "lineno": 503,
      "outcome": "passed",
      "keywords": [
        "test_override",
        "TestPlatformPathMapDict",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestPlatformPathMapDict::test_merged",
      "lineno": 513,
      "outcome": "passed",
      "keywords": [
        "test_merged",
        "TestPlatformPathMapDict",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestPlatformPathMapDict::test_reversed",
      "lineno": 533,
      "outcome": "passed",
      "keywords": [
        "test_reversed",
        "TestPlatformPathMapDict",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_empty_site",
      "lineno": 555,
      "outcome": "passed",
      "keywords": [
        "test_empty_site",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_default",
      "lineno": 561,
      "outcome": "passed",
      "keywords": [
        "test_default",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_site_cli[site_files0-hab_test_entry_points-gui-True]",
      "lineno": 575,
      "outcome": "passed",
      "keywords": [
        "test_site_cli[site_files0-hab_test_entry_points-gui-True]",
        "parametrize",
        "pytestmark",
        "site_files0-hab_test_entry_points-gui-True",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_site_cli[site_files1-hab_test_entry_points-gui_alt-True]",
      "lineno": 575,
      "outcome": "passed",
      "keywords": [
        "test_site_cli[site_files1-hab_test_entry_points-gui_alt-True]",
        "parametrize",
        "pytestmark",
        "site_files1-hab_test_entry_points-gui_alt-True",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_site_cli[site_files2-hab_test_entry_points-gui-True]",
      "lineno": 575,
      "outcome": "passed",
      "keywords": [
        "test_site_cli[site_files2-hab_test_entry_points-gui-True]",
        "parametrize",
        "pytestmark",
        "site_files2-hab_test_entry_points-gui-True",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_site_cli[site_files3-hab_test_entry_points-gui-True]",
      "lineno": 575,
      "outcome": "passed",
      "keywords": [
        "test_site_cli[site_files3-hab_test_entry_points-gui-True]",
        "parametrize",
        "pytestmark",
        "site_files3-hab_test_entry_points-gui-True",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_site_cli[site_files4-None-None-True]",
      "lineno": 575,
      "outcome": "passed",
      "keywords": [
        "test_site_cli[site_files4-None-None-True]",
        "parametrize",
        "pytestmark",
        "site_files4-None-None-True",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_site_cli[site_files5-None-None-False]",
      "lineno": 575,
      "outcome": "passed",
      "keywords": [
        "test_site_cli[site_files5-None-None-False]",
        "parametrize",
        "pytestmark",
        "site_files5-None-None-False",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_called_by_resolve[cfg_reduce_env.json-hab_test_entry_points.cfg_reduce_env called successfully]",
      "lineno": 649,
      "outcome": "failed",
      "keywords": [
        "test_called_by_resolve[cfg_reduce_env.json-hab_test_entry_points.cfg_reduce_env called successfully]",
        "parametrize",
        "pytestmark",
        "cfg_reduce_env.json-hab_test_entry_points.cfg_reduce_env called successfully",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_site.py",
            "lineno": 684,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_site.TestEntryPoints object at 0x00000166545A3740>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nsite_file = 'cfg_reduce_env.json'\nexcept_match = 'hab_test_entry_points.cfg_reduce_env called successfully'\n\n    @pytest.mark.parametrize(\n        \"site_file,except_match\",\n        (\n            (\n                \"cfg_reduce_env.json\",\n                \"hab_test_entry_points.cfg_reduce_env called successfully\",\n            ),\n            (\n                \"cfg_reduce_finalize.json\",\n                \"hab_test_entry_points.cfg_reduce_finalize called successfully\",\n            ),\n            (\n                \"cfg_uri_validate.json\",\n                \"hab_test_entry_points.uri_validate_error called successfully\",\n            ),\n        ),\n    )\n    def test_called_by_resolve(self, config_root, site_file, except_match):\n        \"\"\"Test that site defined entry_points are called.\n    \n        This expects that the entry point will raise a `NotImplementedError` with\n        a specific message. This requires that each test has its own site json\n        file enabling that specific entry_point. See `tests/site/eps/README.md`.\n        \"\"\"\n        site = Site(\n            [\n                config_root / \"site\" / \"eps\" / site_file,\n                config_root / \"site_main.json\",\n            ]\n        )\n        resolver = Resolver(site=site)\n    \n        # The module has now been imported and the correct function was loaded\n        with pytest.raises(NotImplementedError, match=except_match):\n>           resolver.resolve(\"default\")\n\ntests\\test_site.py:684: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C79910>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C7B6E0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_called_by_resolve[cfg_reduce_finalize.json-hab_test_entry_points.cfg_reduce_finalize called successfully]",
      "lineno": 649,
      "outcome": "failed",
      "keywords": [
        "test_called_by_resolve[cfg_reduce_finalize.json-hab_test_entry_points.cfg_reduce_finalize called successfully]",
        "parametrize",
        "pytestmark",
        "cfg_reduce_finalize.json-hab_test_entry_points.cfg_reduce_finalize called successfully",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\config.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_site.py",
            "lineno": 684,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 347,
            "message": "in resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 125,
            "message": "in closest_config"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 164,
            "message": "in configs"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 324,
            "message": "in parse_configs"
          },
          {
            "path": "hab\\parsers\\config.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <test_site.TestEntryPoints object at 0x00000166545A38F0>\nconfig_root = WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests')\nsite_file = 'cfg_reduce_finalize.json'\nexcept_match = 'hab_test_entry_points.cfg_reduce_finalize called successfully'\n\n    @pytest.mark.parametrize(\n        \"site_file,except_match\",\n        (\n            (\n                \"cfg_reduce_env.json\",\n                \"hab_test_entry_points.cfg_reduce_env called successfully\",\n            ),\n            (\n                \"cfg_reduce_finalize.json\",\n                \"hab_test_entry_points.cfg_reduce_finalize called successfully\",\n            ),\n            (\n                \"cfg_uri_validate.json\",\n                \"hab_test_entry_points.uri_validate_error called successfully\",\n            ),\n        ),\n    )\n    def test_called_by_resolve(self, config_root, site_file, except_match):\n        \"\"\"Test that site defined entry_points are called.\n    \n        This expects that the entry point will raise a `NotImplementedError` with\n        a specific message. This requires that each test has its own site json\n        file enabling that specific entry_point. See `tests/site/eps/README.md`.\n        \"\"\"\n        site = Site(\n            [\n                config_root / \"site\" / \"eps\" / site_file,\n                config_root / \"site_main.json\",\n            ]\n        )\n        resolver = Resolver(site=site)\n    \n        # The module has now been imported and the correct function was loaded\n        with pytest.raises(NotImplementedError, match=except_match):\n>           resolver.resolve(\"default\")\n\ntests\\test_site.py:684: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:347: in resolve\n    context = self.closest_config(uri)\nhab\\resolver.py:125: in closest_config\n    if root_name not in self.configs:\nhab\\resolver.py:164: in configs\n    self._configs = self.parse_configs(self.config_paths)\nhab\\resolver.py:324: in parse_configs\n    Config(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.config.Config object at 0x0000016655C72570>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655BF08C0>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\configs\\\\app\\\\app_aliased.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/configs/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\config.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_called_by_resolve[cfg_uri_validate.json-hab_test_entry_points.uri_validate_error called successfully]",
      "lineno": 649,
      "outcome": "passed",
      "keywords": [
        "test_called_by_resolve[cfg_uri_validate.json-hab_test_entry_points.uri_validate_error called successfully]",
        "parametrize",
        "pytestmark",
        "cfg_uri_validate.json-hab_test_entry_points.uri_validate_error called successfully",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_site_add_paths_non_recursive",
      "lineno": 685,
      "outcome": "passed",
      "keywords": [
        "test_site_add_paths_non_recursive",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_site_add_paths_multiple",
      "lineno": 706,
      "outcome": "passed",
      "keywords": [
        "test_site_add_paths_multiple",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_site_finalize",
      "lineno": 730,
      "outcome": "passed",
      "keywords": [
        "test_site_finalize",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_site.py::TestEntryPoints::test_habcache_cls",
      "lineno": 747,
      "outcome": "passed",
      "keywords": [
        "test_habcache_cls",
        "TestEntryPoints",
        "test_site.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_simplify_requirements[value0-check0]",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_simplify_requirements[value0-check0]",
        "parametrize",
        "pytestmark",
        "value0-check0",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_simplify_requirements[value1-check1]",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_simplify_requirements[value1-check1]",
        "parametrize",
        "pytestmark",
        "value1-check1",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_simplify_requirements[value2-check2]",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_simplify_requirements[value2-check2]",
        "parametrize",
        "pytestmark",
        "value2-check2",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_simplify_requirements[value3-check3]",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_simplify_requirements[value3-check3]",
        "parametrize",
        "pytestmark",
        "value3-check3",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_simplify_requirements[value4-check4]",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_simplify_requirements[value4-check4]",
        "parametrize",
        "pytestmark",
        "value4-check4",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_simplify_requirements[value5-check5]",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_simplify_requirements[value5-check5]",
        "parametrize",
        "pytestmark",
        "value5-check5",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_simplify_requirements[value6-check6]",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_simplify_requirements[value6-check6]",
        "parametrize",
        "pytestmark",
        "value6-check6",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_simplify_requirements[value7-check7]",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_simplify_requirements[value7-check7]",
        "parametrize",
        "pytestmark",
        "value7-check7",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_simplify_requirements[value8-check8]",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_simplify_requirements[value8-check8]",
        "parametrize",
        "pytestmark",
        "value8-check8",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_simplify_requirements[value9-check9]",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_simplify_requirements[value9-check9]",
        "parametrize",
        "pytestmark",
        "value9-check9",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_simplify_requirements[value10-check10]",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_simplify_requirements[value10-check10]",
        "parametrize",
        "pytestmark",
        "value10-check10",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_simplify_requirements[value11-check11]",
      "lineno": 10,
      "outcome": "passed",
      "keywords": [
        "test_simplify_requirements[value11-check11]",
        "parametrize",
        "pytestmark",
        "value11-check11",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_invalid_requirement_errors[requirements0-Unable to find a distro for requirement: no_existant_distro]",
      "lineno": 39,
      "outcome": "failed",
      "keywords": [
        "test_invalid_requirement_errors[requirements0-Unable to find a distro for requirement: no_existant_distro]",
        "parametrize",
        "pytestmark",
        "requirements0-Unable to find a distro for requirement: no_existant_distro",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_solver.py",
            "lineno": 70,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 381,
            "message": "in resolve_requirements"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655CC5550>\nrequirements = {'no_existant_distro': <Requirement('no_existant_distro')>}\nmatch = 'Unable to find a distro for requirement: no_existant_distro'\n\n    @pytest.mark.parametrize(\n        \"requirements,match\",\n        (\n            (\n                {\"no_existant_distro\": Requirement(\"no_existant_distro\")},\n                \"Unable to find a distro for requirement: no_existant_distro\",\n            ),\n            # Testing marker output. Using Invalid so this test works on all platforms\n            (\n                {\"no_exist\": Requirement(\"no_exist;platform_system!='Invalid'\")},\n                'Unable to find a distro for requirement: no_exist; platform_system != \"Invalid\"',\n            ),\n            (\n                {\"the_dcc\": Requirement(\"the_dcc==0.0.0\")},\n                r'Unable to find a valid version for \"the_dcc==0.0.0\" in versions \\[.+\\]',\n            ),\n            (\n                # This requirement is not possible because the_dcc_plugin_b requires the_dcc<1.2\n                {\n                    \"the_dcc\": Requirement(\"the_dcc>1.1\"),\n                    \"the_dcc_plugin_b\": Requirement(\"the_dcc_plugin_b<1.0\"),\n                },\n                r'Unable to find a valid version for \"the_dcc<1.2,>1.1\" in versions \\[.+\\]',\n            ),\n        ),\n    )\n    def test_invalid_requirement_errors(uncached_resolver, requirements, match):\n        \"\"\"Test that the correct error is raised if an invalid or missing requirement\n        is specified.\"\"\"\n        with pytest.raises(InvalidRequirementError, match=match):\n>           uncached_resolver.resolve_requirements(requirements)\n\ntests\\test_solver.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:381: in resolve_requirements\n    return solver.resolve()\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655CC4BF0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655CC5550>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_invalid_requirement_errors[requirements1-Unable to find a distro for requirement: no_exist; platform_system != \"Invalid\"]",
      "lineno": 39,
      "outcome": "failed",
      "keywords": [
        "test_invalid_requirement_errors[requirements1-Unable to find a distro for requirement: no_exist; platform_system != \"Invalid\"]",
        "parametrize",
        "pytestmark",
        "requirements1-Unable to find a distro for requirement: no_exist; platform_system != \"Invalid\"",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_solver.py",
            "lineno": 70,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 381,
            "message": "in resolve_requirements"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655CC7A70>\nrequirements = {'no_exist': <Requirement('no_exist; platform_system != \"Invalid\"')>}\nmatch = 'Unable to find a distro for requirement: no_exist; platform_system != \"Invalid\"'\n\n    @pytest.mark.parametrize(\n        \"requirements,match\",\n        (\n            (\n                {\"no_existant_distro\": Requirement(\"no_existant_distro\")},\n                \"Unable to find a distro for requirement: no_existant_distro\",\n            ),\n            # Testing marker output. Using Invalid so this test works on all platforms\n            (\n                {\"no_exist\": Requirement(\"no_exist;platform_system!='Invalid'\")},\n                'Unable to find a distro for requirement: no_exist; platform_system != \"Invalid\"',\n            ),\n            (\n                {\"the_dcc\": Requirement(\"the_dcc==0.0.0\")},\n                r'Unable to find a valid version for \"the_dcc==0.0.0\" in versions \\[.+\\]',\n            ),\n            (\n                # This requirement is not possible because the_dcc_plugin_b requires the_dcc<1.2\n                {\n                    \"the_dcc\": Requirement(\"the_dcc>1.1\"),\n                    \"the_dcc_plugin_b\": Requirement(\"the_dcc_plugin_b<1.0\"),\n                },\n                r'Unable to find a valid version for \"the_dcc<1.2,>1.1\" in versions \\[.+\\]',\n            ),\n        ),\n    )\n    def test_invalid_requirement_errors(uncached_resolver, requirements, match):\n        \"\"\"Test that the correct error is raised if an invalid or missing requirement\n        is specified.\"\"\"\n        with pytest.raises(InvalidRequirementError, match=match):\n>           uncached_resolver.resolve_requirements(requirements)\n\ntests\\test_solver.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:381: in resolve_requirements\n    return solver.resolve()\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655CC6C30>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655CC7A70>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_invalid_requirement_errors[requirements2-Unable to find a valid version for \"the_dcc==0.0.0\" in versions \\\\[.+\\\\]]",
      "lineno": 39,
      "outcome": "failed",
      "keywords": [
        "test_invalid_requirement_errors[requirements2-Unable to find a valid version for \"the_dcc==0.0.0\" in versions \\\\[.+\\\\]]",
        "parametrize",
        "pytestmark",
        "requirements2-Unable to find a valid version for \"the_dcc==0.0.0\" in versions \\\\[.+\\\\]",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_solver.py",
            "lineno": 70,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 381,
            "message": "in resolve_requirements"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655CC5220>\nrequirements = {'the_dcc': <Requirement('the_dcc==0.0.0')>}\nmatch = 'Unable to find a valid version for \"the_dcc==0.0.0\" in versions \\\\[.+\\\\]'\n\n    @pytest.mark.parametrize(\n        \"requirements,match\",\n        (\n            (\n                {\"no_existant_distro\": Requirement(\"no_existant_distro\")},\n                \"Unable to find a distro for requirement: no_existant_distro\",\n            ),\n            # Testing marker output. Using Invalid so this test works on all platforms\n            (\n                {\"no_exist\": Requirement(\"no_exist;platform_system!='Invalid'\")},\n                'Unable to find a distro for requirement: no_exist; platform_system != \"Invalid\"',\n            ),\n            (\n                {\"the_dcc\": Requirement(\"the_dcc==0.0.0\")},\n                r'Unable to find a valid version for \"the_dcc==0.0.0\" in versions \\[.+\\]',\n            ),\n            (\n                # This requirement is not possible because the_dcc_plugin_b requires the_dcc<1.2\n                {\n                    \"the_dcc\": Requirement(\"the_dcc>1.1\"),\n                    \"the_dcc_plugin_b\": Requirement(\"the_dcc_plugin_b<1.0\"),\n                },\n                r'Unable to find a valid version for \"the_dcc<1.2,>1.1\" in versions \\[.+\\]',\n            ),\n        ),\n    )\n    def test_invalid_requirement_errors(uncached_resolver, requirements, match):\n        \"\"\"Test that the correct error is raised if an invalid or missing requirement\n        is specified.\"\"\"\n        with pytest.raises(InvalidRequirementError, match=match):\n>           uncached_resolver.resolve_requirements(requirements)\n\ntests\\test_solver.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:381: in resolve_requirements\n    return solver.resolve()\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655C9A7E0>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655CC5220>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_invalid_requirement_errors[requirements3-Unable to find a valid version for \"the_dcc<1.2,>1.1\" in versions \\\\[.+\\\\]]",
      "lineno": 39,
      "outcome": "failed",
      "keywords": [
        "test_invalid_requirement_errors[requirements3-Unable to find a valid version for \"the_dcc<1.2,>1.1\" in versions \\\\[.+\\\\]]",
        "parametrize",
        "pytestmark",
        "requirements3-Unable to find a valid version for \"the_dcc<1.2,>1.1\" in versions \\\\[.+\\\\]",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_solver.py",
            "lineno": 70,
            "message": ""
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 381,
            "message": "in resolve_requirements"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655D34740>\nrequirements = {'the_dcc': <Requirement('the_dcc>1.1')>, 'the_dcc_plugin_b': <Requirement('the_dcc_plugin_b<1.0')>}\nmatch = 'Unable to find a valid version for \"the_dcc<1.2,>1.1\" in versions \\\\[.+\\\\]'\n\n    @pytest.mark.parametrize(\n        \"requirements,match\",\n        (\n            (\n                {\"no_existant_distro\": Requirement(\"no_existant_distro\")},\n                \"Unable to find a distro for requirement: no_existant_distro\",\n            ),\n            # Testing marker output. Using Invalid so this test works on all platforms\n            (\n                {\"no_exist\": Requirement(\"no_exist;platform_system!='Invalid'\")},\n                'Unable to find a distro for requirement: no_exist; platform_system != \"Invalid\"',\n            ),\n            (\n                {\"the_dcc\": Requirement(\"the_dcc==0.0.0\")},\n                r'Unable to find a valid version for \"the_dcc==0.0.0\" in versions \\[.+\\]',\n            ),\n            (\n                # This requirement is not possible because the_dcc_plugin_b requires the_dcc<1.2\n                {\n                    \"the_dcc\": Requirement(\"the_dcc>1.1\"),\n                    \"the_dcc_plugin_b\": Requirement(\"the_dcc_plugin_b<1.0\"),\n                },\n                r'Unable to find a valid version for \"the_dcc<1.2,>1.1\" in versions \\[.+\\]',\n            ),\n        ),\n    )\n    def test_invalid_requirement_errors(uncached_resolver, requirements, match):\n        \"\"\"Test that the correct error is raised if an invalid or missing requirement\n        is specified.\"\"\"\n        with pytest.raises(InvalidRequirementError, match=match):\n>           uncached_resolver.resolve_requirements(requirements)\n\ntests\\test_solver.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\resolver.py:381: in resolve_requirements\n    return solver.resolve()\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655D37470>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655D34740>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_solver_errors",
      "lineno": 72,
      "outcome": "failed",
      "keywords": [
        "test_solver_errors",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_solver.py",
            "lineno": 90,
            "message": ""
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "uncached_resolver = <hab.resolver.Resolver object at 0x0000016655D35310>\n\n    def test_solver_errors(uncached_resolver):\n        \"\"\"Test that the correct errors are raised\"\"\"\n    \n        # Check that if we exceed max_redirects a MaxRedirectError is raised\n        # Note: To have a stable test, the order of requirements matters. So this needs to\n        # use a list or OrderedDict to guarantee that the_dcc==1.2 requirements are\n        # processed before the_dcc_plugin_b which specifies the_dcc<1.2 forcing a redirect.\n        requirements = OrderedDict(\n            (\n                (\"the_dcc\", Requirement(\"the_dcc\")),\n                (\"the_dcc_plugin_b\", Requirement(\"the_dcc_plugin_b==0.9\")),\n            )\n        )\n    \n        solver = Solver(requirements, uncached_resolver)\n        solver.max_redirects = 0\n        with pytest.raises(MaxRedirectError, match=\"Redirect limit of 0 reached\"):\n>           solver.resolve()\n\ntests\\test_solver.py:90: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655D36630>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655D35310>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_solver.py::test_omittable",
      "lineno": 92,
      "outcome": "failed",
      "keywords": [
        "test_omittable",
        "test_solver.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\parsers\\distro_version.py",
          "lineno": 19,
          "message": "TypeError: object.__init__() takes exactly one argument (the instance to initialize)"
        },
        "traceback": [
          {
            "path": "tests\\test_solver.py",
            "lineno": 109,
            "message": ""
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 194,
            "message": "in resolve"
          },
          {
            "path": "hab\\solvers.py",
            "lineno": 149,
            "message": "in _resolve"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 185,
            "message": "in distros"
          },
          {
            "path": "hab\\resolver.py",
            "lineno": 332,
            "message": "in parse_distros"
          },
          {
            "path": "hab\\parsers\\distro_version.py",
            "lineno": 19,
            "message": "TypeError"
          }
        ],
        "longrepr": "caplog = <_pytest.logging.LogCaptureFixture object at 0x0000016655C706E0>\nuncached_resolver = <hab.resolver.Resolver object at 0x0000016655C71310>\n\n    def test_omittable(caplog, uncached_resolver):\n        \"\"\"Test the solver respects the `omittable` property. This will prevent raising\n        an error if a distro is required but is not found.\n        \"\"\"\n        # A set of requirements that includes distros that hab can't find\n        requirements = OrderedDict(\n            (\n                (\"the_dcc\", Requirement(\"the_dcc\")),\n                (\"the_dcc_plugin_b\", Requirement(\"the_dcc_plugin_b==0.9\")),\n                (\"missing_distro\", Requirement(\"missing_distro\")),\n                (\"missing_distro_b\", Requirement(\"missing_distro_b==1.0\")),\n            )\n        )\n        # By default this should raise an InvalidRequirementError\n        solver = Solver(requirements, uncached_resolver)\n        with pytest.raises(InvalidRequirementError, match=\"requirement: missing_distro\"):\n>           solver.resolve()\n\ntests\\test_solver.py:109: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhab\\solvers.py:194: in resolve\n    return self._resolve(self.requirements)\nhab\\solvers.py:149: in _resolve\n    dist = self.resolver.distros[name]\nhab\\resolver.py:185: in distros\n    self._distros = self.parse_distros(self.distro_paths)\nhab\\resolver.py:332: in parse_distros\n    DistroVersion(forest, self, path, root_paths=set((dirname,)))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hab.parsers.distro_version.DistroVersion object at 0x0000016655D36C30>\nargs = ({}, <hab.resolver.Resolver object at 0x0000016655C71310>, 'D:\\\\repos\\\\blurstudio@hab__177503df__pygments__rich\\\\tests\\\\distros\\\\aliased\\\\2.0\\\\.hab.json')\nkwargs = {'root_paths': {WindowsPath('D:/repos/blurstudio@hab__177503df__pygments__rich/tests/distros/*')}}\n\n    def __init__(self, *args, **kwargs):\n        self._alias_mods = NotSet\n>       super().__init__(*args, **kwargs)\nE       TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n\nhab\\parsers\\distro_version.py:19: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_user_prefs_filename",
      "lineno": 9,
      "outcome": "passed",
      "keywords": [
        "test_user_prefs_filename",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_configure_logging",
      "lineno": 20,
      "outcome": "passed",
      "keywords": [
        "test_configure_logging",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_filename",
      "lineno": 56,
      "outcome": "passed",
      "keywords": [
        "test_filename",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_enabled_no_default",
      "lineno": 69,
      "outcome": "passed",
      "keywords": [
        "test_enabled_no_default",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_enabled[setting0-False-None-False]",
      "lineno": 76,
      "outcome": "passed",
      "keywords": [
        "test_enabled[setting0-False-None-False]",
        "parametrize",
        "pytestmark",
        "setting0-False-None-False",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_enabled[setting1-False-True-False]",
      "lineno": 76,
      "outcome": "passed",
      "keywords": [
        "test_enabled[setting1-False-True-False]",
        "parametrize",
        "pytestmark",
        "setting1-False-True-False",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_enabled[setting2-False-False-False]",
      "lineno": 76,
      "outcome": "passed",
      "keywords": [
        "test_enabled[setting2-False-False-False]",
        "parametrize",
        "pytestmark",
        "setting2-False-False-False",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_enabled[setting3-True-None-True]",
      "lineno": 76,
      "outcome": "passed",
      "keywords": [
        "test_enabled[setting3-True-None-True]",
        "parametrize",
        "pytestmark",
        "setting3-True-None-True",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_enabled[setting4-True-True-True]",
      "lineno": 76,
      "outcome": "passed",
      "keywords": [
        "test_enabled[setting4-True-True-True]",
        "parametrize",
        "pytestmark",
        "setting4-True-True-True",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_enabled[setting5-True-False-False]",
      "lineno": 76,
      "outcome": "passed",
      "keywords": [
        "test_enabled[setting5-True-False-False]",
        "parametrize",
        "pytestmark",
        "setting5-True-False-False",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_enabled[setting6-True-True-True]",
      "lineno": 76,
      "outcome": "passed",
      "keywords": [
        "test_enabled[setting6-True-True-True]",
        "parametrize",
        "pytestmark",
        "setting6-True-True-True",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_enabled[setting7-False-None-False]",
      "lineno": 76,
      "outcome": "passed",
      "keywords": [
        "test_enabled[setting7-False-None-False]",
        "parametrize",
        "pytestmark",
        "setting7-False-None-False",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_enabled[setting8-False-True-True]",
      "lineno": 76,
      "outcome": "passed",
      "keywords": [
        "test_enabled[setting8-False-True-True]",
        "parametrize",
        "pytestmark",
        "setting8-False-True-True",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_enabled[setting9-False-False-False]",
      "lineno": 76,
      "outcome": "passed",
      "keywords": [
        "test_enabled[setting9-False-False-False]",
        "parametrize",
        "pytestmark",
        "setting9-False-False-False",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_enabled[setting10-False-False-False]",
      "lineno": 76,
      "outcome": "passed",
      "keywords": [
        "test_enabled[setting10-False-False-False]",
        "parametrize",
        "pytestmark",
        "setting10-False-False-False",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_timeout",
      "lineno": 104,
      "outcome": "passed",
      "keywords": [
        "test_timeout",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_uri",
      "lineno": 135,
      "outcome": "passed",
      "keywords": [
        "test_uri",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_corruption[None]",
      "lineno": 210,
      "outcome": "passed",
      "keywords": [
        "test_corruption[None]",
        "parametrize",
        "pytestmark",
        "None",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed",
        "stdout": "<LogRecord: hab.user_prefs, 30, D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\user_prefs.py, 118, \"User pref file corrupt, resetting.\">\n<LogRecord: hab.user_prefs, 20, D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\user_prefs.py, 119, \"User pref exception suppressed:\">\n"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_user_prefs.py::test_corruption[{\\n    \"uri\": \"app]",
      "lineno": 210,
      "outcome": "passed",
      "keywords": [
        "test_corruption[{\\n    \"uri\": \"app]",
        "parametrize",
        "pytestmark",
        "{\\n    \"uri\": \"app",
        "test_user_prefs.py",
        "tests",
        "blurstudio@hab__177503df__pygments__rich",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed",
        "stdout": "<LogRecord: hab.user_prefs, 30, D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\user_prefs.py, 118, \"User pref file corrupt, resetting.\">\n<LogRecord: hab.user_prefs, 20, D:\\repos\\blurstudio@hab__177503df__pygments__rich\\hab\\user_prefs.py, 119, \"User pref exception suppressed:\">\n"
      },
      "teardown": {
        "outcome": "passed"
      }
    }
  ]
}