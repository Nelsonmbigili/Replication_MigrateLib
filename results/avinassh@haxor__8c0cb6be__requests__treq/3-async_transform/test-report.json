{
  "exitcode": 1,
  "summary": {
    "passed": 6,
    "error": 20,
    "skipped": 1,
    "failed": 4,
    "total": 31,
    "collected": 31
  },
  "collectors": [
    {
      "nodeid": "",
      "outcome": "passed",
      "result": [
        {
          "nodeid": ".",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "hackernews",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/test_api_version.py::TestAPIVersion",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_api_version.py::TestAPIVersion::test_invalid_api_version",
          "type": "TestCaseFunction",
          "lineno": 25
        },
        {
          "nodeid": "tests/test_api_version.py::TestAPIVersion::test_valid_api_version_1",
          "type": "TestCaseFunction",
          "lineno": 17
        },
        {
          "nodeid": "tests/test_api_version.py::TestAPIVersion::test_valid_api_version_2",
          "type": "TestCaseFunction",
          "lineno": 21
        }
      ]
    },
    {
      "nodeid": "tests/test_api_version.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_api_version.py::TestAPIVersion",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_ask_stories.py::TestAskStories",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_ask_stories.py::TestAskStories::test_ask_stories",
          "type": "TestCaseFunction",
          "lineno": 21
        },
        {
          "nodeid": "tests/test_ask_stories.py::TestAskStories::test_ask_stories_raw",
          "type": "TestCaseFunction",
          "lineno": 28
        }
      ]
    },
    {
      "nodeid": "tests/test_ask_stories.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_ask_stories.py::TestAskStories",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_all.py::TestAll",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_all.py::TestAll::test_get_all",
          "type": "TestCaseFunction",
          "lineno": 20
        }
      ]
    },
    {
      "nodeid": "tests/test_get_all.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_all.py::TestAll",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_async.py::TestGetAsync",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_async.py::TestGetAsync::test_get_async",
          "type": "TestCaseFunction",
          "lineno": 40
        },
        {
          "nodeid": "tests/test_get_async.py::TestGetAsync::test_get_async_error",
          "type": "TestCaseFunction",
          "lineno": 46
        }
      ]
    },
    {
      "nodeid": "tests/test_get_async.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_async.py::TestGetAsync",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_item.py::TestGetItem",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_item.py::TestGetItem::test_get_item",
          "type": "TestCaseFunction",
          "lineno": 22
        },
        {
          "nodeid": "tests/test_get_item.py::TestGetItem::test_get_item_expand",
          "type": "TestCaseFunction",
          "lineno": 38
        },
        {
          "nodeid": "tests/test_get_item.py::TestGetItem::test_invalid_item",
          "type": "TestCaseFunction",
          "lineno": 34
        }
      ]
    },
    {
      "nodeid": "tests/test_get_item.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_item.py::TestGetItem",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_items_by_ids.py::TestGetItemsByIDs",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_items_by_ids.py::TestGetItemsByIDs::test_get_items_by_ids",
          "type": "TestCaseFunction",
          "lineno": 21
        },
        {
          "nodeid": "tests/test_get_items_by_ids.py::TestGetItemsByIDs::test_get_items_by_ids_filtered",
          "type": "TestCaseFunction",
          "lineno": 28
        }
      ]
    },
    {
      "nodeid": "tests/test_get_items_by_ids.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_items_by_ids.py::TestGetItemsByIDs",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_last.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/test_get_last.py::TestGetLast",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_last.py::TestGetLast::test_get_item",
          "type": "TestCaseFunction",
          "lineno": 22
        }
      ]
    },
    {
      "nodeid": "tests/test_get_last.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_last.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/test_get_last.py::TestGetLast",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_max_item.py::TestGetMaxItem",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_max_item.py::TestGetMaxItem::test_get_max_item",
          "type": "TestCaseFunction",
          "lineno": 20
        },
        {
          "nodeid": "tests/test_get_max_item.py::TestGetMaxItem::test_get_max_item_expand",
          "type": "TestCaseFunction",
          "lineno": 25
        }
      ]
    },
    {
      "nodeid": "tests/test_get_max_item.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_max_item.py::TestGetMaxItem",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_sync.py::TestGetSync",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_sync.py::TestGetSync::test_get_sync",
          "type": "TestCaseFunction",
          "lineno": 40
        },
        {
          "nodeid": "tests/test_get_sync.py::TestGetSync::test_get_sync_error",
          "type": "TestCaseFunction",
          "lineno": 55
        }
      ]
    },
    {
      "nodeid": "tests/test_get_sync.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_sync.py::TestGetSync",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_user.py::TestGetUser",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_user.py::TestGetUser::test_get_invalid_user",
          "type": "TestCaseFunction",
          "lineno": 33
        },
        {
          "nodeid": "tests/test_get_user.py::TestGetUser::test_get_user",
          "type": "TestCaseFunction",
          "lineno": 24
        },
        {
          "nodeid": "tests/test_get_user.py::TestGetUser::test_get_user_expand",
          "type": "TestCaseFunction",
          "lineno": 37
        }
      ]
    },
    {
      "nodeid": "tests/test_get_user.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_user.py::TestGetUser",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_users_by_ids.py::TestGetUsersByIDs",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_users_by_ids.py::TestGetUsersByIDs::test_get_users_by_ids",
          "type": "TestCaseFunction",
          "lineno": 21
        }
      ]
    },
    {
      "nodeid": "tests/test_get_users_by_ids.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_users_by_ids.py::TestGetUsersByIDs",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_job_stories.py::TestJobStories",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_job_stories.py::TestJobStories::test_job_stories",
          "type": "TestCaseFunction",
          "lineno": 21
        },
        {
          "nodeid": "tests/test_job_stories.py::TestJobStories::test_job_stories_raw",
          "type": "TestCaseFunction",
          "lineno": 28
        }
      ]
    },
    {
      "nodeid": "tests/test_job_stories.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_job_stories.py::TestJobStories",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_new_stories.py::TestNewStories",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_new_stories.py::TestNewStories::test_new_stories",
          "type": "TestCaseFunction",
          "lineno": 22
        },
        {
          "nodeid": "tests/test_new_stories.py::TestNewStories::test_new_stories_raw",
          "type": "TestCaseFunction",
          "lineno": 29
        }
      ]
    },
    {
      "nodeid": "tests/test_new_stories.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_new_stories.py::TestNewStories",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_show_stories.py::TestShowStories",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_show_stories.py::TestShowStories::test_show_stories",
          "type": "TestCaseFunction",
          "lineno": 60
        },
        {
          "nodeid": "tests/test_show_stories.py::TestShowStories::test_show_stories_raw",
          "type": "TestCaseFunction",
          "lineno": 67
        }
      ]
    },
    {
      "nodeid": "tests/test_show_stories.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_show_stories.py::TestShowStories",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_top_stories.py::TestTopStories",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_top_stories.py::TestTopStories::test_top_stories",
          "type": "TestCaseFunction",
          "lineno": 21
        },
        {
          "nodeid": "tests/test_top_stories.py::TestTopStories::test_top_stories_raw",
          "type": "TestCaseFunction",
          "lineno": 28
        }
      ]
    },
    {
      "nodeid": "tests/test_top_stories.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_top_stories.py::TestTopStories",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_updates.py::TestUpdates",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_updates.py::TestUpdates::test_top_stories",
          "type": "TestCaseFunction",
          "lineno": 20
        }
      ]
    },
    {
      "nodeid": "tests/test_updates.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_updates.py::TestUpdates",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_api_version.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_ask_stories.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_all.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_async.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_item.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_items_by_ids.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_last.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_max_item.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_sync.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_user.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_users_by_ids.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_job_stories.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_new_stories.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_show_stories.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_top_stories.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_updates.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": ".",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "hackernews",
          "type": "Package"
        },
        {
          "nodeid": "tests",
          "type": "Package"
        }
      ]
    }
  ],
  "tests": [
    {
      "nodeid": "tests/test_api_version.py::TestAPIVersion::test_invalid_api_version",
      "lineno": 25,
      "outcome": "passed",
      "keywords": [
        "test_invalid_api_version",
        "TestAPIVersion",
        "test_api_version.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_api_version.py::TestAPIVersion::test_valid_api_version_1",
      "lineno": 17,
      "outcome": "passed",
      "keywords": [
        "test_valid_api_version_1",
        "TestAPIVersion",
        "test_api_version.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_api_version.py::TestAPIVersion::test_valid_api_version_2",
      "lineno": 21,
      "outcome": "passed",
      "keywords": [
        "test_valid_api_version_2",
        "TestAPIVersion",
        "test_api_version.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_ask_stories.py::TestAskStories::test_ask_stories",
      "lineno": 21,
      "outcome": "error",
      "keywords": [
        "test_ask_stories",
        "asyncio",
        "pytestmark",
        "TestAskStories",
        "test_ask_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_ask_stories.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 321,
            "message": "in ask_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DA32E70>\nurl = 'https://hacker-news.firebaseio.com/v0/askstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DA70930>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_ask_stories.TestAskStories testMethod=test_ask_stories>\n\n    @pytest.mark.asyncio\n    async def test_ask_stories(self):\n>       ask_stories = await self.hn.ask_stories(limit=10)\n\ntests\\test_ask_stories.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:321: in ask_stories\n    ask_stories = self._get_stories('askstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DA32E70>\nurl = 'https://hacker-news.firebaseio.com/v0/askstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_ask_stories.py",
          "lineno": 37,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_ask_stories.py",
            "lineno": 37,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_ask_stories.TestAskStories testMethod=test_ask_stories>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_ask_stories.py:37: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_ask_stories.py::TestAskStories::test_ask_stories_raw",
      "lineno": 28,
      "outcome": "error",
      "keywords": [
        "test_ask_stories_raw",
        "asyncio",
        "pytestmark",
        "TestAskStories",
        "test_ask_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_ask_stories.py",
            "lineno": 31,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 321,
            "message": "in ask_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DB40860>\nurl = 'https://hacker-news.firebaseio.com/v0/askstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DA73920>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_ask_stories.TestAskStories testMethod=test_ask_stories_raw>\n\n    @pytest.mark.asyncio\n    async def test_ask_stories_raw(self):\n>       ask_stories = await self.hn.ask_stories(raw=True)\n\ntests\\test_ask_stories.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:321: in ask_stories\n    ask_stories = self._get_stories('askstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DB40860>\nurl = 'https://hacker-news.firebaseio.com/v0/askstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_ask_stories.py",
          "lineno": 37,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_ask_stories.py",
            "lineno": 37,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_ask_stories.TestAskStories testMethod=test_ask_stories_raw>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_ask_stories.py:37: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_all.py::TestAll::test_get_all",
      "lineno": 20,
      "outcome": "skipped",
      "keywords": [
        "test_get_all",
        "__wrapped__",
        "__unittest_skip__",
        "__unittest_skip_why__",
        "TestAll",
        "test_get_all.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\avinassh@haxor__8c0cb6be__requests__treq\\\\tests\\\\test_get_all.py', 21, 'Skipped: Skip for timeout issue due to long runtime')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_get_async.py::TestGetAsync::test_get_async",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_get_async",
        "asyncio",
        "pytestmark",
        "TestGetAsync",
        "test_get_async.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_async.py",
          "lineno": 44,
          "message": "TypeError: 'NoneType' object is not subscriptable"
        },
        "traceback": [
          {
            "path": "tests\\test_get_async.py",
            "lineno": 44,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <tests.test_get_async.TestGetAsync testMethod=test_get_async>\n\n    @pytest.mark.asyncio\n    async def test_get_async(self):\n        response = await self.hn._run_async([self.url])\n>       self.assertEqual(response[0]['id'], 8863)\nE       TypeError: 'NoneType' object is not subscriptable\n\ntests\\test_get_async.py:44: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_get_async.py::TestGetAsync::test_get_async_error",
      "lineno": 46,
      "outcome": "passed",
      "keywords": [
        "test_get_async_error",
        "asyncio",
        "pytestmark",
        "TestGetAsync",
        "test_get_async.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_get_item.py::TestGetItem::test_get_item",
      "lineno": 22,
      "outcome": "error",
      "keywords": [
        "test_get_item",
        "asyncio",
        "pytestmark",
        "TestGetItem",
        "test_get_item.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_item.py",
            "lineno": 25,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 186,
            "message": "in get_item"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DCB1D00>\nurl = 'https://hacker-news.firebaseio.com/v0/item/8863.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DC1B780>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_item.TestGetItem testMethod=test_get_item>\n\n    @pytest.mark.asyncio\n    async def test_get_item(self):\n>       item = await self.hn.get_item(8863)  # Await the asynchronous call\n\ntests\\test_get_item.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:186: in get_item\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DCB1D00>\nurl = 'https://hacker-news.firebaseio.com/v0/item/8863.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_item.py",
          "lineno": 48,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_item.py",
            "lineno": 48,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_item.TestGetItem testMethod=test_get_item>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Close the session asynchronously\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_item.py:48: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_item.py::TestGetItem::test_get_item_expand",
      "lineno": 38,
      "outcome": "error",
      "keywords": [
        "test_get_item_expand",
        "asyncio",
        "pytestmark",
        "TestGetItem",
        "test_get_item.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_item.py",
            "lineno": 41,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 186,
            "message": "in get_item"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DCB2A50>\nurl = 'https://hacker-news.firebaseio.com/v0/item/8863.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DD59220>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_item.TestGetItem testMethod=test_get_item_expand>\n\n    @pytest.mark.asyncio\n    async def test_get_item_expand(self):\n>       item = await self.hn.get_item(8863, expand=True)  # Await the asynchronous call\n\ntests\\test_get_item.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:186: in get_item\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DCB2A50>\nurl = 'https://hacker-news.firebaseio.com/v0/item/8863.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_item.py",
          "lineno": 48,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_item.py",
            "lineno": 48,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_item.TestGetItem testMethod=test_get_item_expand>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Close the session asynchronously\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_item.py:48: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_item.py::TestGetItem::test_invalid_item",
      "lineno": 34,
      "outcome": "error",
      "keywords": [
        "test_invalid_item",
        "TestGetItem",
        "test_get_item.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_item.py",
            "lineno": 37,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 186,
            "message": "in get_item"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DD5B370>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_item.TestGetItem testMethod=test_invalid_item>\n\n    async def test_invalid_item(self):\n        with self.assertRaises(InvalidItemID):\n>           await self.hn.get_item(0)  # Await the asynchronous call\n\ntests\\test_get_item.py:37: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:186: in get_item\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_item.py",
          "lineno": 48,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_item.py",
            "lineno": 48,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_item.TestGetItem testMethod=test_invalid_item>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Close the session asynchronously\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_item.py:48: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_items_by_ids.py::TestGetItemsByIDs::test_get_items_by_ids",
      "lineno": 21,
      "outcome": "error",
      "keywords": [
        "test_get_items_by_ids",
        "asyncio",
        "pytestmark",
        "TestGetItemsByIDs",
        "test_get_items_by_ids.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
          "lineno": 622,
          "message": "RuntimeError: This event loop is already running"
        },
        "traceback": [
          {
            "path": "tests\\test_get_items_by_ids.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 215,
            "message": "in get_items_by_ids"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 139,
            "message": "in _run_async"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 663,
            "message": "in run_until_complete"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 622,
            "message": "RuntimeError"
          }
        ],
        "longrepr": "self = <tests.test_get_items_by_ids.TestGetItemsByIDs testMethod=test_get_items_by_ids>\n\n    @pytest.mark.asyncio\n    async def test_get_items_by_ids(self):\n>       items = await self.hn.get_items_by_ids([1, 2, 3])\n\ntests\\test_get_items_by_ids.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:215: in get_items_by_ids\n    result = self._run_async(urls=urls)\nhackernews\\__init__.py:139: in _run_async\n    results = loop.run_until_complete(self._async_loop(urls))\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:663: in run_until_complete\n    self._check_running()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <ProactorEventLoop running=False closed=True debug=True>\n\n    def _check_running(self):\n        if self.is_running():\n>           raise RuntimeError('This event loop is already running')\nE           RuntimeError: This event loop is already running\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:622: RuntimeError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_items_by_ids.py",
          "lineno": 40,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_items_by_ids.py",
            "lineno": 40,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_items_by_ids.TestGetItemsByIDs testMethod=test_get_items_by_ids>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_items_by_ids.py:40: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_items_by_ids.py::TestGetItemsByIDs::test_get_items_by_ids_filtered",
      "lineno": 28,
      "outcome": "error",
      "keywords": [
        "test_get_items_by_ids_filtered",
        "asyncio",
        "pytestmark",
        "TestGetItemsByIDs",
        "test_get_items_by_ids.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
          "lineno": 622,
          "message": "RuntimeError: This event loop is already running"
        },
        "traceback": [
          {
            "path": "tests\\test_get_items_by_ids.py",
            "lineno": 31,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 215,
            "message": "in get_items_by_ids"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 139,
            "message": "in _run_async"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 663,
            "message": "in run_until_complete"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 622,
            "message": "RuntimeError"
          }
        ],
        "longrepr": "self = <tests.test_get_items_by_ids.TestGetItemsByIDs testMethod=test_get_items_by_ids_filtered>\n\n    @pytest.mark.asyncio\n    async def test_get_items_by_ids_filtered(self):\n>       items = await self.hn.get_items_by_ids(\n            [i for i in range(1, 50)],\n            item_type='story'\n        )\n\ntests\\test_get_items_by_ids.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:215: in get_items_by_ids\n    result = self._run_async(urls=urls)\nhackernews\\__init__.py:139: in _run_async\n    results = loop.run_until_complete(self._async_loop(urls))\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:663: in run_until_complete\n    self._check_running()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <ProactorEventLoop running=False closed=True debug=True>\n\n    def _check_running(self):\n        if self.is_running():\n>           raise RuntimeError('This event loop is already running')\nE           RuntimeError: This event loop is already running\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:622: RuntimeError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_items_by_ids.py",
          "lineno": 40,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_items_by_ids.py",
            "lineno": 40,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_items_by_ids.TestGetItemsByIDs testMethod=test_get_items_by_ids_filtered>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_items_by_ids.py:40: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_last.py::TestGetLast::test_get_item",
      "lineno": 22,
      "outcome": "failed",
      "keywords": [
        "test_get_item",
        "__wrapped__",
        "TestGetLast",
        "test_get_last.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_last.py",
            "lineno": 25,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 420,
            "message": "in get_last"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 393,
            "message": "in get_max_item"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DD4C710>\nurl = 'https://hacker-news.firebaseio.com/v0/maxitem.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:194: in run\n    return runner.run(main)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:118: in run\n    return self._loop.run_until_complete(task)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:687: in run_until_complete\n    return future.result()\nhackernews\\__init__.py:104: in fetch\n    return await self._get_async(url)\nhackernews\\__init__.py:85: in _get_async\n    response = await treq.get(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Deferred at 0x2283dd4e2a0>\n\n    def __iter__(self) -> Generator[Deferred[_SelfResultT], None, _SelfResultT]:\n        while True:\n            if self.paused:\n                # If we're paused, we have no result to give\n                yield self\n                continue\n    \n            result = getattr(self, \"result\", _NO_RESULT)\n            if result is _NO_RESULT:\n>               yield self\nE               RuntimeError: Task got bad yield: <Deferred at 0x2283dd4e2a0>\n\n.venv\\Lib\\site-packages\\twisted\\internet\\defer.py:1183: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_last.TestGetLast testMethod=test_get_item>\n\n    @defer.inlineCallbacks\n    def test_get_item(self):\n>       items = yield self.hn.get_last(5)\n\ntests\\test_get_last.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:420: in get_last\n    max_item = self.get_max_item()\nhackernews\\__init__.py:393: in get_max_item\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DD4C710>\nurl = 'https://hacker-news.firebaseio.com/v0/maxitem.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_get_max_item.py::TestGetMaxItem::test_get_max_item",
      "lineno": 20,
      "outcome": "error",
      "keywords": [
        "test_get_max_item",
        "asyncio",
        "pytestmark",
        "TestGetMaxItem",
        "test_get_max_item.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_max_item.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 393,
            "message": "in get_max_item"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DD4FC50>\nurl = 'https://hacker-news.firebaseio.com/v0/maxitem.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DC1B5E0>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_max_item.TestGetMaxItem testMethod=test_get_max_item>\n\n    @pytest.mark.asyncio\n    async def test_get_max_item(self):\n>       max_item_id = await self.hn.get_max_item()\n\ntests\\test_get_max_item.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:393: in get_max_item\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DD4FC50>\nurl = 'https://hacker-news.firebaseio.com/v0/maxitem.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_max_item.py",
          "lineno": 32,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_max_item.py",
            "lineno": 32,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_max_item.TestGetMaxItem testMethod=test_get_max_item>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_max_item.py:32: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_max_item.py::TestGetMaxItem::test_get_max_item_expand",
      "lineno": 25,
      "outcome": "error",
      "keywords": [
        "test_get_max_item_expand",
        "asyncio",
        "pytestmark",
        "TestGetMaxItem",
        "test_get_max_item.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_max_item.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 393,
            "message": "in get_max_item"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DDB0C50>\nurl = 'https://hacker-news.firebaseio.com/v0/maxitem.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DD1C1E0>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_max_item.TestGetMaxItem testMethod=test_get_max_item_expand>\n\n    @pytest.mark.asyncio\n    async def test_get_max_item_expand(self):\n>       max_item = await self.hn.get_max_item(expand=True)\n\ntests\\test_get_max_item.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:393: in get_max_item\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DDB0C50>\nurl = 'https://hacker-news.firebaseio.com/v0/maxitem.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_max_item.py",
          "lineno": 32,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_max_item.py",
            "lineno": 32,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_max_item.TestGetMaxItem testMethod=test_get_max_item_expand>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_max_item.py:32: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_sync.py::TestGetSync::test_get_sync",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_get_sync",
        "TestGetSync",
        "test_get_sync.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_sync.py",
          "lineno": 47,
          "message": "AttributeError: 'TestGetSync' object has no attribute '_assert_valid_response'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_sync.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "tests\\test_get_sync.py",
            "lineno": 47,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_sync.TestGetSync testMethod=test_get_sync>\n\n    def test_get_sync(self):\n        \"\"\"\n        Test the _get_sync method for a valid URL.\n        \"\"\"\n        def run_test():\n            d = self.hn._get_sync(self.url)\n            d.addCallback(self._assert_valid_response)\n            return d\n    \n        def _assert_valid_response(self, response):\n            self.assertEqual(response['id'], 8863)\n            self.assertEqual(response['by'], 'dhouston')\n    \n>       return run_test()\n\ntests\\test_get_sync.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def run_test():\n        d = self.hn._get_sync(self.url)\n>       d.addCallback(self._assert_valid_response)\nE       AttributeError: 'TestGetSync' object has no attribute '_assert_valid_response'\n\ntests\\test_get_sync.py:47: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_get_sync.py::TestGetSync::test_get_sync_error",
      "lineno": 55,
      "outcome": "failed",
      "keywords": [
        "test_get_sync_error",
        "TestGetSync",
        "test_get_sync.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_sync.py",
          "lineno": 62,
          "message": "AttributeError: 'TestGetSync' object has no attribute '_assert_error_raised'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_sync.py",
            "lineno": 68,
            "message": ""
          },
          {
            "path": "tests\\test_get_sync.py",
            "lineno": 62,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_sync.TestGetSync testMethod=test_get_sync_error>\n\n    def test_get_sync_error(self):\n        \"\"\"\n        Test the _get_sync method for an invalid URL.\n        \"\"\"\n        def run_test():\n            d = self.hn._get_sync(self.err_url)\n            d.addErrback(self._assert_error_raised)\n            return d\n    \n        def _assert_error_raised(self, failure):\n            self.assertIsInstance(failure.value, HTTPError)\n    \n>       return run_test()\n\ntests\\test_get_sync.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def run_test():\n        d = self.hn._get_sync(self.err_url)\n>       d.addErrback(self._assert_error_raised)\nE       AttributeError: 'TestGetSync' object has no attribute '_assert_error_raised'\n\ntests\\test_get_sync.py:62: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_get_user.py::TestGetUser::test_get_invalid_user",
      "lineno": 33,
      "outcome": "error",
      "keywords": [
        "test_get_invalid_user",
        "TestGetUser",
        "test_get_user.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_user.py",
            "lineno": 36,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 243,
            "message": "in get_user"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DA71FF0>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_user.TestGetUser testMethod=test_get_invalid_user>\n\n    async def test_get_invalid_user(self):\n        with self.assertRaises(InvalidUserID):\n>           await self.hn.get_user('a')\n\ntests\\test_get_user.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:243: in get_user\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_user.py",
          "lineno": 47,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_user.py",
            "lineno": 47,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_user.TestGetUser testMethod=test_get_invalid_user>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_user.py:47: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_user.py::TestGetUser::test_get_user",
      "lineno": 24,
      "outcome": "error",
      "keywords": [
        "test_get_user",
        "asyncio",
        "pytestmark",
        "TestGetUser",
        "test_get_user.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_user.py",
            "lineno": 27,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 243,
            "message": "in get_user"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DDDC560>\nurl = 'https://hacker-news.firebaseio.com/v0/user/pg.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DD1C860>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_user.TestGetUser testMethod=test_get_user>\n\n    @pytest.mark.asyncio\n    async def test_get_user(self):\n>       user = await self.hn.get_user('pg')\n\ntests\\test_get_user.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:243: in get_user\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DDDC560>\nurl = 'https://hacker-news.firebaseio.com/v0/user/pg.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_user.py",
          "lineno": 47,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_user.py",
            "lineno": 47,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_user.TestGetUser testMethod=test_get_user>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_user.py:47: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_user.py::TestGetUser::test_get_user_expand",
      "lineno": 37,
      "outcome": "error",
      "keywords": [
        "test_get_user_expand",
        "asyncio",
        "pytestmark",
        "TestGetUser",
        "test_get_user.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_user.py",
            "lineno": 40,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 243,
            "message": "in get_user"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DDDD100>\nurl = 'https://hacker-news.firebaseio.com/v0/user/avinassh.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DB6ADC0>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_user.TestGetUser testMethod=test_get_user_expand>\n\n    @pytest.mark.asyncio\n    async def test_get_user_expand(self):\n>       user = await self.hn.get_user('avinassh', expand=True)\n\ntests\\test_get_user.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:243: in get_user\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DDDD100>\nurl = 'https://hacker-news.firebaseio.com/v0/user/avinassh.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_user.py",
          "lineno": 47,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_user.py",
            "lineno": 47,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_user.TestGetUser testMethod=test_get_user_expand>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_user.py:47: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_users_by_ids.py::TestGetUsersByIDs::test_get_users_by_ids",
      "lineno": 21,
      "outcome": "error",
      "keywords": [
        "test_get_users_by_ids",
        "asyncio",
        "pytestmark",
        "TestGetUsersByIDs",
        "test_get_users_by_ids.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
          "lineno": 622,
          "message": "RuntimeError: This event loop is already running"
        },
        "traceback": [
          {
            "path": "tests\\test_get_users_by_ids.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 272,
            "message": "in get_users_by_ids"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 139,
            "message": "in _run_async"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 663,
            "message": "in run_until_complete"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 622,
            "message": "RuntimeError"
          }
        ],
        "longrepr": "self = <tests.test_get_users_by_ids.TestGetUsersByIDs testMethod=test_get_users_by_ids>\n\n    @pytest.mark.asyncio\n    async def test_get_users_by_ids(self):\n>       users = await self.hn.get_users_by_ids(['pg', 'tptacek', 'jacquesm'])\n\ntests\\test_get_users_by_ids.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:272: in get_users_by_ids\n    result = self._run_async(urls=urls)\nhackernews\\__init__.py:139: in _run_async\n    results = loop.run_until_complete(self._async_loop(urls))\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:663: in run_until_complete\n    self._check_running()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <ProactorEventLoop running=False closed=True debug=True>\n\n    def _check_running(self):\n        if self.is_running():\n>           raise RuntimeError('This event loop is already running')\nE           RuntimeError: This event loop is already running\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:622: RuntimeError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_users_by_ids.py",
          "lineno": 30,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_users_by_ids.py",
            "lineno": 30,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_users_by_ids.TestGetUsersByIDs testMethod=test_get_users_by_ids>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_users_by_ids.py:30: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_job_stories.py::TestJobStories::test_job_stories",
      "lineno": 21,
      "outcome": "error",
      "keywords": [
        "test_job_stories",
        "asyncio",
        "pytestmark",
        "TestJobStories",
        "test_job_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_job_stories.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 355,
            "message": "in job_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DDDF6E0>\nurl = 'https://hacker-news.firebaseio.com/v0/jobstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DB69220>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_job_stories.TestJobStories testMethod=test_job_stories>\n\n    @pytest.mark.asyncio\n    async def test_job_stories(self):\n>       job_stories = await self.hn.job_stories(limit=10)  # Await the async method\n\ntests\\test_job_stories.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:355: in job_stories\n    job_stories = self._get_stories('jobstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DDDF6E0>\nurl = 'https://hacker-news.firebaseio.com/v0/jobstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_job_stories.py",
          "lineno": 37,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_job_stories.py",
            "lineno": 37,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_job_stories.TestJobStories testMethod=test_job_stories>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Ensure proper cleanup of async resources\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_job_stories.py:37: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_job_stories.py::TestJobStories::test_job_stories_raw",
      "lineno": 28,
      "outcome": "error",
      "keywords": [
        "test_job_stories_raw",
        "asyncio",
        "pytestmark",
        "TestJobStories",
        "test_job_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_job_stories.py",
            "lineno": 31,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 355,
            "message": "in job_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DDDD6A0>\nurl = 'https://hacker-news.firebaseio.com/v0/jobstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DDA01E0>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_job_stories.TestJobStories testMethod=test_job_stories_raw>\n\n    @pytest.mark.asyncio\n    async def test_job_stories_raw(self):\n>       job_stories = await self.hn.job_stories(raw=True)  # Await the async method\n\ntests\\test_job_stories.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:355: in job_stories\n    job_stories = self._get_stories('jobstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DDDD6A0>\nurl = 'https://hacker-news.firebaseio.com/v0/jobstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_job_stories.py",
          "lineno": 37,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_job_stories.py",
            "lineno": 37,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_job_stories.TestJobStories testMethod=test_job_stories_raw>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Ensure proper cleanup of async resources\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_job_stories.py:37: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_new_stories.py::TestNewStories::test_new_stories",
      "lineno": 22,
      "outcome": "error",
      "keywords": [
        "test_new_stories",
        "asyncio",
        "pytestmark",
        "TestNewStories",
        "test_new_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_new_stories.py",
            "lineno": 25,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 304,
            "message": "in new_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DD4EBA0>\nurl = 'https://hacker-news.firebaseio.com/v0/newstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DD1F9F0>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_new_stories.TestNewStories testMethod=test_new_stories>\n\n    @pytest.mark.asyncio\n    async def test_new_stories(self):\n>       new_stories = await self.hn.new_stories(limit=10)  # Await the async method\n\ntests\\test_new_stories.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:304: in new_stories\n    new_stories = self._get_stories('newstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DD4EBA0>\nurl = 'https://hacker-news.firebaseio.com/v0/newstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_new_stories.py",
          "lineno": 38,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_new_stories.py",
            "lineno": 38,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_new_stories.TestNewStories testMethod=test_new_stories>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Close the async session properly\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_new_stories.py:38: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_new_stories.py::TestNewStories::test_new_stories_raw",
      "lineno": 29,
      "outcome": "error",
      "keywords": [
        "test_new_stories_raw",
        "asyncio",
        "pytestmark",
        "TestNewStories",
        "test_new_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_new_stories.py",
            "lineno": 32,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 304,
            "message": "in new_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DDE08F0>\nurl = 'https://hacker-news.firebaseio.com/v0/newstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DDA3920>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_new_stories.TestNewStories testMethod=test_new_stories_raw>\n\n    @pytest.mark.asyncio\n    async def test_new_stories_raw(self):\n>       new_stories = await self.hn.new_stories(raw=True)  # Await the async method\n\ntests\\test_new_stories.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:304: in new_stories\n    new_stories = self._get_stories('newstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DDE08F0>\nurl = 'https://hacker-news.firebaseio.com/v0/newstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_new_stories.py",
          "lineno": 38,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_new_stories.py",
            "lineno": 38,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_new_stories.TestNewStories testMethod=test_new_stories_raw>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Close the async session properly\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_new_stories.py:38: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_show_stories.py::TestShowStories::test_show_stories",
      "lineno": 60,
      "outcome": "passed",
      "keywords": [
        "test_show_stories",
        "__wrapped__",
        "TestShowStories",
        "test_show_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_show_stories.py::TestShowStories::test_show_stories_raw",
      "lineno": 67,
      "outcome": "passed",
      "keywords": [
        "test_show_stories_raw",
        "__wrapped__",
        "TestShowStories",
        "test_show_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_top_stories.py::TestTopStories::test_top_stories",
      "lineno": 21,
      "outcome": "error",
      "keywords": [
        "test_top_stories",
        "asyncio",
        "pytestmark",
        "TestTopStories",
        "test_top_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_top_stories.py",
            "lineno": 24,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 287,
            "message": "in top_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DDC01D0>\nurl = 'https://hacker-news.firebaseio.com/v0/topstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DD1D080>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_top_stories.TestTopStories testMethod=test_top_stories>\n\n    @pytest.mark.asyncio\n    async def test_top_stories(self):\n>       top_stories = await self.hn.top_stories(limit=10)  # Await the async method\n\ntests\\test_top_stories.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:287: in top_stories\n    top_stories = self._get_stories('topstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DDC01D0>\nurl = 'https://hacker-news.firebaseio.com/v0/topstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_top_stories.py",
          "lineno": 37,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_top_stories.py",
            "lineno": 37,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_top_stories.TestTopStories testMethod=test_top_stories>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Ensure the session is closed asynchronously\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_top_stories.py:37: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_top_stories.py::TestTopStories::test_top_stories_raw",
      "lineno": 28,
      "outcome": "error",
      "keywords": [
        "test_top_stories_raw",
        "asyncio",
        "pytestmark",
        "TestTopStories",
        "test_top_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_top_stories.py",
            "lineno": 31,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 287,
            "message": "in top_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DDC13A0>\nurl = 'https://hacker-news.firebaseio.com/v0/topstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DD58BA0>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_top_stories.TestTopStories testMethod=test_top_stories_raw>\n\n    @pytest.mark.asyncio\n    async def test_top_stories_raw(self):\n>       top_stories = await self.hn.top_stories(raw=True)  # Await the async method\n\ntests\\test_top_stories.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:287: in top_stories\n    top_stories = self._get_stories('topstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DDC13A0>\nurl = 'https://hacker-news.firebaseio.com/v0/topstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_top_stories.py",
          "lineno": 37,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_top_stories.py",
            "lineno": 37,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_top_stories.TestTopStories testMethod=test_top_stories_raw>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Ensure the session is closed asynchronously\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_top_stories.py:37: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_updates.py::TestUpdates::test_top_stories",
      "lineno": 20,
      "outcome": "error",
      "keywords": [
        "test_top_stories",
        "asyncio",
        "pytestmark",
        "TestUpdates",
        "test_updates.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_updates.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 372,
            "message": "in updates"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002283DDC27B0>\nurl = 'https://hacker-news.firebaseio.com/v0/updates.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002283DA71560>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_updates.TestUpdates testMethod=test_top_stories>\n\n    @pytest.mark.asyncio\n    async def test_top_stories(self):\n>       updates = await self.hn.updates()  # Await the asynchronous method\n\ntests\\test_updates.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:372: in updates\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002283DDC27B0>\nurl = 'https://hacker-news.firebaseio.com/v0/updates.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_updates.py",
          "lineno": 30,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_updates.py",
            "lineno": 30,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_updates.TestUpdates testMethod=test_top_stories>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Ensure proper cleanup of async resources\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_updates.py:30: AttributeError"
      }
    }
  ],
  "warnings": [
    {
      "message": "It is deprecated to return a value that is not None from a test case (<bound method TestShowStories.test_show_stories of <tests.test_show_stories.TestShowStories testMethod=test_show_stories>>)",
      "category": "DeprecationWarning",
      "when": "runtest",
      "filename": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\case.py",
      "lineno": 690
    },
    {
      "message": "It is deprecated to return a value that is not None from a test case (<bound method TestShowStories.test_show_stories_raw of <tests.test_show_stories.TestShowStories testMethod=test_show_stories_raw>>)",
      "category": "DeprecationWarning",
      "when": "runtest",
      "filename": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\case.py",
      "lineno": 690
    }
  ]
}