{
  "exitcode": 1,
  "summary": {
    "passed": 6,
    "error": 20,
    "skipped": 1,
    "failed": 4,
    "total": 31,
    "collected": 31
  },
  "collectors": [
    {
      "nodeid": "",
      "outcome": "passed",
      "result": [
        {
          "nodeid": ".",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "hackernews",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/test_api_version.py::TestAPIVersion",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_api_version.py::TestAPIVersion::test_invalid_api_version",
          "type": "TestCaseFunction",
          "lineno": 25
        },
        {
          "nodeid": "tests/test_api_version.py::TestAPIVersion::test_valid_api_version_1",
          "type": "TestCaseFunction",
          "lineno": 17
        },
        {
          "nodeid": "tests/test_api_version.py::TestAPIVersion::test_valid_api_version_2",
          "type": "TestCaseFunction",
          "lineno": 21
        }
      ]
    },
    {
      "nodeid": "tests/test_api_version.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_api_version.py::TestAPIVersion",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_ask_stories.py::TestAskStories",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_ask_stories.py::TestAskStories::test_ask_stories",
          "type": "TestCaseFunction",
          "lineno": 20
        },
        {
          "nodeid": "tests/test_ask_stories.py::TestAskStories::test_ask_stories_raw",
          "type": "TestCaseFunction",
          "lineno": 26
        }
      ]
    },
    {
      "nodeid": "tests/test_ask_stories.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_ask_stories.py::TestAskStories",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_all.py::TestAll",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_all.py::TestAll::test_get_all",
          "type": "TestCaseFunction",
          "lineno": 20
        }
      ]
    },
    {
      "nodeid": "tests/test_get_all.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_all.py::TestAll",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_async.py::TestGetAsync",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_async.py::TestGetAsync::test_get_async",
          "type": "TestCaseFunction",
          "lineno": 39
        },
        {
          "nodeid": "tests/test_get_async.py::TestGetAsync::test_get_async_error",
          "type": "TestCaseFunction",
          "lineno": 44
        }
      ]
    },
    {
      "nodeid": "tests/test_get_async.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_async.py::TestGetAsync",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_item.py::TestGetItem",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_item.py::TestGetItem::test_get_item",
          "type": "TestCaseFunction",
          "lineno": 21
        },
        {
          "nodeid": "tests/test_get_item.py::TestGetItem::test_get_item_expand",
          "type": "TestCaseFunction",
          "lineno": 36
        },
        {
          "nodeid": "tests/test_get_item.py::TestGetItem::test_invalid_item",
          "type": "TestCaseFunction",
          "lineno": 32
        }
      ]
    },
    {
      "nodeid": "tests/test_get_item.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_item.py::TestGetItem",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_items_by_ids.py::TestGetItemsByIDs",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_items_by_ids.py::TestGetItemsByIDs::test_get_items_by_ids",
          "type": "TestCaseFunction",
          "lineno": 20
        },
        {
          "nodeid": "tests/test_get_items_by_ids.py::TestGetItemsByIDs::test_get_items_by_ids_filtered",
          "type": "TestCaseFunction",
          "lineno": 26
        }
      ]
    },
    {
      "nodeid": "tests/test_get_items_by_ids.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_items_by_ids.py::TestGetItemsByIDs",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_last.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/test_get_last.py::TestGetLast",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_last.py::TestGetLast::test_get_item",
          "type": "TestCaseFunction",
          "lineno": 22
        }
      ]
    },
    {
      "nodeid": "tests/test_get_last.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_last.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/test_get_last.py::TestGetLast",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_max_item.py::TestGetMaxItem",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_max_item.py::TestGetMaxItem::test_get_max_item",
          "type": "TestCaseFunction",
          "lineno": 19
        },
        {
          "nodeid": "tests/test_get_max_item.py::TestGetMaxItem::test_get_max_item_expand",
          "type": "TestCaseFunction",
          "lineno": 23
        }
      ]
    },
    {
      "nodeid": "tests/test_get_max_item.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_max_item.py::TestGetMaxItem",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_sync.py::TestGetSync",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_sync.py::TestGetSync::test_get_sync",
          "type": "TestCaseFunction",
          "lineno": 40
        },
        {
          "nodeid": "tests/test_get_sync.py::TestGetSync::test_get_sync_error",
          "type": "TestCaseFunction",
          "lineno": 55
        }
      ]
    },
    {
      "nodeid": "tests/test_get_sync.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_sync.py::TestGetSync",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_user.py::TestGetUser",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_user.py::TestGetUser::test_get_invalid_user",
          "type": "TestCaseFunction",
          "lineno": 31
        },
        {
          "nodeid": "tests/test_get_user.py::TestGetUser::test_get_user",
          "type": "TestCaseFunction",
          "lineno": 23
        },
        {
          "nodeid": "tests/test_get_user.py::TestGetUser::test_get_user_expand",
          "type": "TestCaseFunction",
          "lineno": 35
        }
      ]
    },
    {
      "nodeid": "tests/test_get_user.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_user.py::TestGetUser",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_get_users_by_ids.py::TestGetUsersByIDs",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_users_by_ids.py::TestGetUsersByIDs::test_get_users_by_ids",
          "type": "TestCaseFunction",
          "lineno": 20
        }
      ]
    },
    {
      "nodeid": "tests/test_get_users_by_ids.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_get_users_by_ids.py::TestGetUsersByIDs",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_job_stories.py::TestJobStories",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_job_stories.py::TestJobStories::test_job_stories",
          "type": "TestCaseFunction",
          "lineno": 20
        },
        {
          "nodeid": "tests/test_job_stories.py::TestJobStories::test_job_stories_raw",
          "type": "TestCaseFunction",
          "lineno": 26
        }
      ]
    },
    {
      "nodeid": "tests/test_job_stories.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_job_stories.py::TestJobStories",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_new_stories.py::TestNewStories",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_new_stories.py::TestNewStories::test_new_stories",
          "type": "TestCaseFunction",
          "lineno": 21
        },
        {
          "nodeid": "tests/test_new_stories.py::TestNewStories::test_new_stories_raw",
          "type": "TestCaseFunction",
          "lineno": 27
        }
      ]
    },
    {
      "nodeid": "tests/test_new_stories.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_new_stories.py::TestNewStories",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_show_stories.py::TestShowStories",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_show_stories.py::TestShowStories::test_show_stories",
          "type": "TestCaseFunction",
          "lineno": 60
        },
        {
          "nodeid": "tests/test_show_stories.py::TestShowStories::test_show_stories_raw",
          "type": "TestCaseFunction",
          "lineno": 67
        }
      ]
    },
    {
      "nodeid": "tests/test_show_stories.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_show_stories.py::TestShowStories",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_top_stories.py::TestTopStories",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_top_stories.py::TestTopStories::test_top_stories",
          "type": "TestCaseFunction",
          "lineno": 20
        },
        {
          "nodeid": "tests/test_top_stories.py::TestTopStories::test_top_stories_raw",
          "type": "TestCaseFunction",
          "lineno": 26
        }
      ]
    },
    {
      "nodeid": "tests/test_top_stories.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_top_stories.py::TestTopStories",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/test_updates.py::TestUpdates",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_updates.py::TestUpdates::test_top_stories",
          "type": "TestCaseFunction",
          "lineno": 19
        }
      ]
    },
    {
      "nodeid": "tests/test_updates.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_updates.py::TestUpdates",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_api_version.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_ask_stories.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_all.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_async.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_item.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_items_by_ids.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_last.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_max_item.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_sync.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_user.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_get_users_by_ids.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_job_stories.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_new_stories.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_show_stories.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_top_stories.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_updates.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": ".",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "hackernews",
          "type": "Package"
        },
        {
          "nodeid": "tests",
          "type": "Package"
        }
      ]
    }
  ],
  "tests": [
    {
      "nodeid": "tests/test_api_version.py::TestAPIVersion::test_invalid_api_version",
      "lineno": 25,
      "outcome": "passed",
      "keywords": [
        "test_invalid_api_version",
        "TestAPIVersion",
        "test_api_version.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_api_version.py::TestAPIVersion::test_valid_api_version_1",
      "lineno": 17,
      "outcome": "passed",
      "keywords": [
        "test_valid_api_version_1",
        "TestAPIVersion",
        "test_api_version.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_api_version.py::TestAPIVersion::test_valid_api_version_2",
      "lineno": 21,
      "outcome": "passed",
      "keywords": [
        "test_valid_api_version_2",
        "TestAPIVersion",
        "test_api_version.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_ask_stories.py::TestAskStories::test_ask_stories",
      "lineno": 20,
      "outcome": "error",
      "keywords": [
        "test_ask_stories",
        "TestAskStories",
        "test_ask_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_ask_stories.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 321,
            "message": "in ask_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD82E8680>\nurl = 'https://hacker-news.firebaseio.com/v0/askstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD8276260>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_ask_stories.TestAskStories testMethod=test_ask_stories>\n\n    async def test_ask_stories(self):\n>       ask_stories = await self.hn.ask_stories(limit=10)\n\ntests\\test_ask_stories.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:321: in ask_stories\n    ask_stories = self._get_stories('askstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD82E8680>\nurl = 'https://hacker-news.firebaseio.com/v0/askstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_ask_stories.py",
          "lineno": 34,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_ask_stories.py",
            "lineno": 34,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_ask_stories.TestAskStories testMethod=test_ask_stories>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_ask_stories.py:34: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_ask_stories.py::TestAskStories::test_ask_stories_raw",
      "lineno": 26,
      "outcome": "error",
      "keywords": [
        "test_ask_stories_raw",
        "TestAskStories",
        "test_ask_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_ask_stories.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 321,
            "message": "in ask_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD82EA0C0>\nurl = 'https://hacker-news.firebaseio.com/v0/askstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD82B5560>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_ask_stories.TestAskStories testMethod=test_ask_stories_raw>\n\n    async def test_ask_stories_raw(self):\n>       ask_stories = await self.hn.ask_stories(raw=True)\n\ntests\\test_ask_stories.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:321: in ask_stories\n    ask_stories = self._get_stories('askstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD82EA0C0>\nurl = 'https://hacker-news.firebaseio.com/v0/askstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_ask_stories.py",
          "lineno": 34,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_ask_stories.py",
            "lineno": 34,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_ask_stories.TestAskStories testMethod=test_ask_stories_raw>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_ask_stories.py:34: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_all.py::TestAll::test_get_all",
      "lineno": 20,
      "outcome": "skipped",
      "keywords": [
        "test_get_all",
        "__wrapped__",
        "__unittest_skip__",
        "__unittest_skip_why__",
        "TestAll",
        "test_get_all.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\avinassh@haxor__8c0cb6be__requests__treq\\\\tests\\\\test_get_all.py', 21, 'Skipped: Skip for timeout issue due to long runtime')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_get_async.py::TestGetAsync::test_get_async",
      "lineno": 39,
      "outcome": "failed",
      "keywords": [
        "test_get_async",
        "TestGetAsync",
        "test_get_async.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_async.py",
          "lineno": 42,
          "message": "TypeError: 'NoneType' object is not subscriptable"
        },
        "traceback": [
          {
            "path": "tests\\test_get_async.py",
            "lineno": 42,
            "message": "TypeError"
          }
        ],
        "longrepr": "self = <tests.test_get_async.TestGetAsync testMethod=test_get_async>\n\n    async def test_get_async(self):\n        response = await self.hn._run_async([self.url])\n>       self.assertEqual(response[0]['id'], 8863)\nE       TypeError: 'NoneType' object is not subscriptable\n\ntests\\test_get_async.py:42: TypeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_get_async.py::TestGetAsync::test_get_async_error",
      "lineno": 44,
      "outcome": "passed",
      "keywords": [
        "test_get_async_error",
        "TestGetAsync",
        "test_get_async.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_get_item.py::TestGetItem::test_get_item",
      "lineno": 21,
      "outcome": "error",
      "keywords": [
        "test_get_item",
        "TestGetItem",
        "test_get_item.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_item.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 186,
            "message": "in get_item"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD855C0E0>\nurl = 'https://hacker-news.firebaseio.com/v0/item/8863.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD848E670>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_item.TestGetItem testMethod=test_get_item>\n\n    async def test_get_item(self):\n>       item = await self.hn.get_item(8863)  # Await the asynchronous call\n\ntests\\test_get_item.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:186: in get_item\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD855C0E0>\nurl = 'https://hacker-news.firebaseio.com/v0/item/8863.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_item.py",
          "lineno": 45,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_item.py",
            "lineno": 45,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_item.TestGetItem testMethod=test_get_item>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Close the session asynchronously\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_item.py:45: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_item.py::TestGetItem::test_get_item_expand",
      "lineno": 36,
      "outcome": "error",
      "keywords": [
        "test_get_item_expand",
        "TestGetItem",
        "test_get_item.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_item.py",
            "lineno": 38,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 186,
            "message": "in get_item"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD855D310>\nurl = 'https://hacker-news.firebaseio.com/v0/item/8863.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD8274AD0>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_item.TestGetItem testMethod=test_get_item_expand>\n\n    async def test_get_item_expand(self):\n>       item = await self.hn.get_item(8863, expand=True)  # Await the asynchronous call\n\ntests\\test_get_item.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:186: in get_item\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD855D310>\nurl = 'https://hacker-news.firebaseio.com/v0/item/8863.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_item.py",
          "lineno": 45,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_item.py",
            "lineno": 45,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_item.TestGetItem testMethod=test_get_item_expand>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Close the session asynchronously\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_item.py:45: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_item.py::TestGetItem::test_invalid_item",
      "lineno": 32,
      "outcome": "error",
      "keywords": [
        "test_invalid_item",
        "TestGetItem",
        "test_get_item.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_item.py",
            "lineno": 35,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 186,
            "message": "in get_item"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD82B4A00>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_item.TestGetItem testMethod=test_invalid_item>\n\n    async def test_invalid_item(self):\n        with self.assertRaises(InvalidItemID):\n>           await self.hn.get_item(0)  # Await the asynchronous call\n\ntests\\test_get_item.py:35: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:186: in get_item\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_item.py",
          "lineno": 45,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_item.py",
            "lineno": 45,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_item.TestGetItem testMethod=test_invalid_item>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Close the session asynchronously\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_item.py:45: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_items_by_ids.py::TestGetItemsByIDs::test_get_items_by_ids",
      "lineno": 20,
      "outcome": "error",
      "keywords": [
        "test_get_items_by_ids",
        "TestGetItemsByIDs",
        "test_get_items_by_ids.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
          "lineno": 622,
          "message": "RuntimeError: This event loop is already running"
        },
        "traceback": [
          {
            "path": "tests\\test_get_items_by_ids.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 215,
            "message": "in get_items_by_ids"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 139,
            "message": "in _run_async"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 663,
            "message": "in run_until_complete"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 622,
            "message": "RuntimeError"
          }
        ],
        "longrepr": "self = <tests.test_get_items_by_ids.TestGetItemsByIDs testMethod=test_get_items_by_ids>\n\n    async def test_get_items_by_ids(self):\n>       items = await self.hn.get_items_by_ids([1, 2, 3])\n\ntests\\test_get_items_by_ids.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:215: in get_items_by_ids\n    result = self._run_async(urls=urls)\nhackernews\\__init__.py:139: in _run_async\n    results = loop.run_until_complete(self._async_loop(urls))\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:663: in run_until_complete\n    self._check_running()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <ProactorEventLoop running=False closed=True debug=True>\n\n    def _check_running(self):\n        if self.is_running():\n>           raise RuntimeError('This event loop is already running')\nE           RuntimeError: This event loop is already running\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:622: RuntimeError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_items_by_ids.py",
          "lineno": 37,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_items_by_ids.py",
            "lineno": 37,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_items_by_ids.TestGetItemsByIDs testMethod=test_get_items_by_ids>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_items_by_ids.py:37: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_items_by_ids.py::TestGetItemsByIDs::test_get_items_by_ids_filtered",
      "lineno": 26,
      "outcome": "error",
      "keywords": [
        "test_get_items_by_ids_filtered",
        "TestGetItemsByIDs",
        "test_get_items_by_ids.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
          "lineno": 622,
          "message": "RuntimeError: This event loop is already running"
        },
        "traceback": [
          {
            "path": "tests\\test_get_items_by_ids.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 215,
            "message": "in get_items_by_ids"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 139,
            "message": "in _run_async"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 663,
            "message": "in run_until_complete"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 622,
            "message": "RuntimeError"
          }
        ],
        "longrepr": "self = <tests.test_get_items_by_ids.TestGetItemsByIDs testMethod=test_get_items_by_ids_filtered>\n\n    async def test_get_items_by_ids_filtered(self):\n>       items = await self.hn.get_items_by_ids(\n            [i for i in range(1, 50)],\n            item_type='story'\n        )\n\ntests\\test_get_items_by_ids.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:215: in get_items_by_ids\n    result = self._run_async(urls=urls)\nhackernews\\__init__.py:139: in _run_async\n    results = loop.run_until_complete(self._async_loop(urls))\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:663: in run_until_complete\n    self._check_running()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <ProactorEventLoop running=False closed=True debug=True>\n\n    def _check_running(self):\n        if self.is_running():\n>           raise RuntimeError('This event loop is already running')\nE           RuntimeError: This event loop is already running\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:622: RuntimeError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_items_by_ids.py",
          "lineno": 37,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_items_by_ids.py",
            "lineno": 37,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_items_by_ids.TestGetItemsByIDs testMethod=test_get_items_by_ids_filtered>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_items_by_ids.py:37: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_last.py::TestGetLast::test_get_item",
      "lineno": 22,
      "outcome": "failed",
      "keywords": [
        "test_get_item",
        "__wrapped__",
        "TestGetLast",
        "test_get_last.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_last.py",
            "lineno": 25,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 420,
            "message": "in get_last"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 393,
            "message": "in get_max_item"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD858DF40>\nurl = 'https://hacker-news.firebaseio.com/v0/maxitem.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:194: in run\n    return runner.run(main)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:118: in run\n    return self._loop.run_until_complete(task)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:687: in run_until_complete\n    return future.result()\nhackernews\\__init__.py:104: in fetch\n    return await self._get_async(url)\nhackernews\\__init__.py:85: in _get_async\n    response = await treq.get(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Deferred at 0x2efd858f080>\n\n    def __iter__(self) -> Generator[Deferred[_SelfResultT], None, _SelfResultT]:\n        while True:\n            if self.paused:\n                # If we're paused, we have no result to give\n                yield self\n                continue\n    \n            result = getattr(self, \"result\", _NO_RESULT)\n            if result is _NO_RESULT:\n>               yield self\nE               RuntimeError: Task got bad yield: <Deferred at 0x2efd858f080>\n\n.venv\\Lib\\site-packages\\twisted\\internet\\defer.py:1183: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_last.TestGetLast testMethod=test_get_item>\n\n    @defer.inlineCallbacks\n    def test_get_item(self):\n>       items = yield self.hn.get_last(5)\n\ntests\\test_get_last.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:420: in get_last\n    max_item = self.get_max_item()\nhackernews\\__init__.py:393: in get_max_item\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD858DF40>\nurl = 'https://hacker-news.firebaseio.com/v0/maxitem.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_get_max_item.py::TestGetMaxItem::test_get_max_item",
      "lineno": 19,
      "outcome": "error",
      "keywords": [
        "test_get_max_item",
        "TestGetMaxItem",
        "test_get_max_item.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_max_item.py",
            "lineno": 21,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 393,
            "message": "in get_max_item"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD855D7F0>\nurl = 'https://hacker-news.firebaseio.com/v0/maxitem.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD848C450>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_max_item.TestGetMaxItem testMethod=test_get_max_item>\n\n    async def test_get_max_item(self):\n>       max_item_id = await self.hn.get_max_item()\n\ntests\\test_get_max_item.py:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:393: in get_max_item\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD855D7F0>\nurl = 'https://hacker-news.firebaseio.com/v0/maxitem.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_max_item.py",
          "lineno": 29,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_max_item.py",
            "lineno": 29,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_max_item.TestGetMaxItem testMethod=test_get_max_item>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_max_item.py:29: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_max_item.py::TestGetMaxItem::test_get_max_item_expand",
      "lineno": 23,
      "outcome": "error",
      "keywords": [
        "test_get_max_item_expand",
        "TestGetMaxItem",
        "test_get_max_item.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_max_item.py",
            "lineno": 25,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 393,
            "message": "in get_max_item"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD858FC50>\nurl = 'https://hacker-news.firebaseio.com/v0/maxitem.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD82997D0>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_max_item.TestGetMaxItem testMethod=test_get_max_item_expand>\n\n    async def test_get_max_item_expand(self):\n>       max_item = await self.hn.get_max_item(expand=True)\n\ntests\\test_get_max_item.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:393: in get_max_item\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD858FC50>\nurl = 'https://hacker-news.firebaseio.com/v0/maxitem.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_max_item.py",
          "lineno": 29,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_max_item.py",
            "lineno": 29,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_max_item.TestGetMaxItem testMethod=test_get_max_item_expand>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_max_item.py:29: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_sync.py::TestGetSync::test_get_sync",
      "lineno": 40,
      "outcome": "failed",
      "keywords": [
        "test_get_sync",
        "TestGetSync",
        "test_get_sync.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_sync.py",
          "lineno": 47,
          "message": "AttributeError: 'TestGetSync' object has no attribute '_assert_valid_response'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_sync.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "tests\\test_get_sync.py",
            "lineno": 47,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_sync.TestGetSync testMethod=test_get_sync>\n\n    def test_get_sync(self):\n        \"\"\"\n        Test the _get_sync method for a valid URL.\n        \"\"\"\n        def run_test():\n            d = self.hn._get_sync(self.url)\n            d.addCallback(self._assert_valid_response)\n            return d\n    \n        def _assert_valid_response(self, response):\n            self.assertEqual(response['id'], 8863)\n            self.assertEqual(response['by'], 'dhouston')\n    \n>       return run_test()\n\ntests\\test_get_sync.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def run_test():\n        d = self.hn._get_sync(self.url)\n>       d.addCallback(self._assert_valid_response)\nE       AttributeError: 'TestGetSync' object has no attribute '_assert_valid_response'\n\ntests\\test_get_sync.py:47: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_get_sync.py::TestGetSync::test_get_sync_error",
      "lineno": 55,
      "outcome": "failed",
      "keywords": [
        "test_get_sync_error",
        "TestGetSync",
        "test_get_sync.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_sync.py",
          "lineno": 62,
          "message": "AttributeError: 'TestGetSync' object has no attribute '_assert_error_raised'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_sync.py",
            "lineno": 68,
            "message": ""
          },
          {
            "path": "tests\\test_get_sync.py",
            "lineno": 62,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_sync.TestGetSync testMethod=test_get_sync_error>\n\n    def test_get_sync_error(self):\n        \"\"\"\n        Test the _get_sync method for an invalid URL.\n        \"\"\"\n        def run_test():\n            d = self.hn._get_sync(self.err_url)\n            d.addErrback(self._assert_error_raised)\n            return d\n    \n        def _assert_error_raised(self, failure):\n            self.assertIsInstance(failure.value, HTTPError)\n    \n>       return run_test()\n\ntests\\test_get_sync.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def run_test():\n        d = self.hn._get_sync(self.err_url)\n>       d.addErrback(self._assert_error_raised)\nE       AttributeError: 'TestGetSync' object has no attribute '_assert_error_raised'\n\ntests\\test_get_sync.py:62: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_get_user.py::TestGetUser::test_get_invalid_user",
      "lineno": 31,
      "outcome": "error",
      "keywords": [
        "test_get_invalid_user",
        "TestGetUser",
        "test_get_user.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_user.py",
            "lineno": 34,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 243,
            "message": "in get_user"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD85F0930>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_user.TestGetUser testMethod=test_get_invalid_user>\n\n    async def test_get_invalid_user(self):\n        with self.assertRaises(InvalidUserID):\n>           await self.hn.get_user('a')\n\ntests\\test_get_user.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:243: in get_user\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_user.py",
          "lineno": 44,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_user.py",
            "lineno": 44,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_user.TestGetUser testMethod=test_get_invalid_user>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_user.py:44: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_user.py::TestGetUser::test_get_user",
      "lineno": 23,
      "outcome": "error",
      "keywords": [
        "test_get_user",
        "TestGetUser",
        "test_get_user.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_user.py",
            "lineno": 25,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 243,
            "message": "in get_user"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD86718B0>\nurl = 'https://hacker-news.firebaseio.com/v0/user/pg.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD8625BE0>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_user.TestGetUser testMethod=test_get_user>\n\n    async def test_get_user(self):\n>       user = await self.hn.get_user('pg')\n\ntests\\test_get_user.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:243: in get_user\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD86718B0>\nurl = 'https://hacker-news.firebaseio.com/v0/user/pg.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_user.py",
          "lineno": 44,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_user.py",
            "lineno": 44,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_user.TestGetUser testMethod=test_get_user>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_user.py:44: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_user.py::TestGetUser::test_get_user_expand",
      "lineno": 35,
      "outcome": "error",
      "keywords": [
        "test_get_user_expand",
        "TestGetUser",
        "test_get_user.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_get_user.py",
            "lineno": 37,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 243,
            "message": "in get_user"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD858D1C0>\nurl = 'https://hacker-news.firebaseio.com/v0/user/avinassh.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD82B6C20>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_get_user.TestGetUser testMethod=test_get_user_expand>\n\n    async def test_get_user_expand(self):\n>       user = await self.hn.get_user('avinassh', expand=True)\n\ntests\\test_get_user.py:37: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:243: in get_user\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD858D1C0>\nurl = 'https://hacker-news.firebaseio.com/v0/user/avinassh.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_user.py",
          "lineno": 44,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_user.py",
            "lineno": 44,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_user.TestGetUser testMethod=test_get_user_expand>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_user.py:44: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_get_users_by_ids.py::TestGetUsersByIDs::test_get_users_by_ids",
      "lineno": 20,
      "outcome": "error",
      "keywords": [
        "test_get_users_by_ids",
        "TestGetUsersByIDs",
        "test_get_users_by_ids.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
          "lineno": 622,
          "message": "RuntimeError: This event loop is already running"
        },
        "traceback": [
          {
            "path": "tests\\test_get_users_by_ids.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 272,
            "message": "in get_users_by_ids"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 139,
            "message": "in _run_async"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 663,
            "message": "in run_until_complete"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py",
            "lineno": 622,
            "message": "RuntimeError"
          }
        ],
        "longrepr": "self = <tests.test_get_users_by_ids.TestGetUsersByIDs testMethod=test_get_users_by_ids>\n\n    async def test_get_users_by_ids(self):\n>       users = await self.hn.get_users_by_ids(['pg', 'tptacek', 'jacquesm'])\n\ntests\\test_get_users_by_ids.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:272: in get_users_by_ids\n    result = self._run_async(urls=urls)\nhackernews\\__init__.py:139: in _run_async\n    results = loop.run_until_complete(self._async_loop(urls))\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:663: in run_until_complete\n    self._check_running()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <ProactorEventLoop running=False closed=True debug=True>\n\n    def _check_running(self):\n        if self.is_running():\n>           raise RuntimeError('This event loop is already running')\nE           RuntimeError: This event loop is already running\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py:622: RuntimeError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_get_users_by_ids.py",
          "lineno": 28,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_get_users_by_ids.py",
            "lineno": 28,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_get_users_by_ids.TestGetUsersByIDs testMethod=test_get_users_by_ids>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_get_users_by_ids.py:28: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_job_stories.py::TestJobStories::test_job_stories",
      "lineno": 20,
      "outcome": "error",
      "keywords": [
        "test_job_stories",
        "TestJobStories",
        "test_job_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_job_stories.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 355,
            "message": "in job_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD86722D0>\nurl = 'https://hacker-news.firebaseio.com/v0/jobstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD82B7850>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_job_stories.TestJobStories testMethod=test_job_stories>\n\n    async def test_job_stories(self):\n>       job_stories = await self.hn.job_stories(limit=10)  # Await the async method\n\ntests\\test_job_stories.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:355: in job_stories\n    job_stories = self._get_stories('jobstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD86722D0>\nurl = 'https://hacker-news.firebaseio.com/v0/jobstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_job_stories.py",
          "lineno": 34,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_job_stories.py",
            "lineno": 34,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_job_stories.TestJobStories testMethod=test_job_stories>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Ensure proper cleanup of async resources\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_job_stories.py:34: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_job_stories.py::TestJobStories::test_job_stories_raw",
      "lineno": 26,
      "outcome": "error",
      "keywords": [
        "test_job_stories_raw",
        "TestJobStories",
        "test_job_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_job_stories.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 355,
            "message": "in job_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD86738F0>\nurl = 'https://hacker-news.firebaseio.com/v0/jobstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD829B5E0>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_job_stories.TestJobStories testMethod=test_job_stories_raw>\n\n    async def test_job_stories_raw(self):\n>       job_stories = await self.hn.job_stories(raw=True)  # Await the async method\n\ntests\\test_job_stories.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:355: in job_stories\n    job_stories = self._get_stories('jobstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD86738F0>\nurl = 'https://hacker-news.firebaseio.com/v0/jobstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_job_stories.py",
          "lineno": 34,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_job_stories.py",
            "lineno": 34,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_job_stories.TestJobStories testMethod=test_job_stories_raw>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Ensure proper cleanup of async resources\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_job_stories.py:34: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_new_stories.py::TestNewStories::test_new_stories",
      "lineno": 21,
      "outcome": "error",
      "keywords": [
        "test_new_stories",
        "TestNewStories",
        "test_new_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_new_stories.py",
            "lineno": 23,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 304,
            "message": "in new_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD8638980>\nurl = 'https://hacker-news.firebaseio.com/v0/newstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD85F2330>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_new_stories.TestNewStories testMethod=test_new_stories>\n\n    async def test_new_stories(self):\n>       new_stories = await self.hn.new_stories(limit=10)  # Await the async method\n\ntests\\test_new_stories.py:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:304: in new_stories\n    new_stories = self._get_stories('newstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD8638980>\nurl = 'https://hacker-news.firebaseio.com/v0/newstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_new_stories.py",
          "lineno": 35,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_new_stories.py",
            "lineno": 35,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_new_stories.TestNewStories testMethod=test_new_stories>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Close the async session properly\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_new_stories.py:35: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_new_stories.py::TestNewStories::test_new_stories_raw",
      "lineno": 27,
      "outcome": "error",
      "keywords": [
        "test_new_stories_raw",
        "TestNewStories",
        "test_new_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_new_stories.py",
            "lineno": 29,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 304,
            "message": "in new_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD8639C40>\nurl = 'https://hacker-news.firebaseio.com/v0/newstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD8624790>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_new_stories.TestNewStories testMethod=test_new_stories_raw>\n\n    async def test_new_stories_raw(self):\n>       new_stories = await self.hn.new_stories(raw=True)  # Await the async method\n\ntests\\test_new_stories.py:29: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:304: in new_stories\n    new_stories = self._get_stories('newstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD8639C40>\nurl = 'https://hacker-news.firebaseio.com/v0/newstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_new_stories.py",
          "lineno": 35,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_new_stories.py",
            "lineno": 35,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_new_stories.TestNewStories testMethod=test_new_stories_raw>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Close the async session properly\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_new_stories.py:35: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_show_stories.py::TestShowStories::test_show_stories",
      "lineno": 60,
      "outcome": "passed",
      "keywords": [
        "test_show_stories",
        "__wrapped__",
        "TestShowStories",
        "test_show_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_show_stories.py::TestShowStories::test_show_stories_raw",
      "lineno": 67,
      "outcome": "passed",
      "keywords": [
        "test_show_stories_raw",
        "__wrapped__",
        "TestShowStories",
        "test_show_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_top_stories.py::TestTopStories::test_top_stories",
      "lineno": 20,
      "outcome": "error",
      "keywords": [
        "test_top_stories",
        "TestTopStories",
        "test_top_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_top_stories.py",
            "lineno": 22,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 287,
            "message": "in top_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD863B230>\nurl = 'https://hacker-news.firebaseio.com/v0/topstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD82B72A0>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_top_stories.TestTopStories testMethod=test_top_stories>\n\n    async def test_top_stories(self):\n>       top_stories = await self.hn.top_stories(limit=10)  # Await the async method\n\ntests\\test_top_stories.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:287: in top_stories\n    top_stories = self._get_stories('topstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD863B230>\nurl = 'https://hacker-news.firebaseio.com/v0/topstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_top_stories.py",
          "lineno": 34,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_top_stories.py",
            "lineno": 34,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_top_stories.TestTopStories testMethod=test_top_stories>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Ensure the session is closed asynchronously\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_top_stories.py:34: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_top_stories.py::TestTopStories::test_top_stories_raw",
      "lineno": 26,
      "outcome": "error",
      "keywords": [
        "test_top_stories_raw",
        "TestTopStories",
        "test_top_stories.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_top_stories.py",
            "lineno": 28,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 287,
            "message": "in top_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 161,
            "message": "in _get_stories"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD86B0110>\nurl = 'https://hacker-news.firebaseio.com/v0/topstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD8626400>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_top_stories.TestTopStories testMethod=test_top_stories_raw>\n\n    async def test_top_stories_raw(self):\n>       top_stories = await self.hn.top_stories(raw=True)  # Await the async method\n\ntests\\test_top_stories.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:287: in top_stories\n    top_stories = self._get_stories('topstories', limit)\nhackernews\\__init__.py:161: in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD86B0110>\nurl = 'https://hacker-news.firebaseio.com/v0/topstories.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_top_stories.py",
          "lineno": 34,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_top_stories.py",
            "lineno": 34,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_top_stories.TestTopStories testMethod=test_top_stories_raw>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Ensure the session is closed asynchronously\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_top_stories.py:34: AttributeError"
      }
    },
    {
      "nodeid": "tests/test_updates.py::TestUpdates::test_top_stories",
      "lineno": 19,
      "outcome": "error",
      "keywords": [
        "test_top_stories",
        "TestUpdates",
        "test_updates.py",
        "tests",
        "avinassh@haxor__8c0cb6be__requests__treq",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py",
          "lineno": 109,
          "message": "hackernews.HTTPError"
        },
        "traceback": [
          {
            "path": "tests\\test_updates.py",
            "lineno": 21,
            "message": ""
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 372,
            "message": "in updates"
          },
          {
            "path": "hackernews\\__init__.py",
            "lineno": 109,
            "message": "HTTPError"
          }
        ],
        "longrepr": "self = <hackernews.HackerNews object at 0x000002EFD86B1010>\nurl = 'https://hacker-news.firebaseio.com/v0/updates.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n>           return asyncio.run(fetch())\n\nhackernews\\__init__.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nmain = <coroutine object HackerNews._get_sync.<locals>.fetch at 0x000002EFD829AA80>\n\n    def run(main, *, debug=None, loop_factory=None):\n        \"\"\"Execute the coroutine and return the result.\n    \n        This function runs the passed coroutine, taking care of\n        managing the asyncio event loop, finalizing asynchronous\n        generators and closing the default executor.\n    \n        This function cannot be called when another asyncio event loop is\n        running in the same thread.\n    \n        If debug is True, the event loop will be run in debug mode.\n    \n        This function always creates a new event loop and closes it at the end.\n        It should be used as a main entry point for asyncio programs, and should\n        ideally only be called once.\n    \n        The executor is given a timeout duration of 5 minutes to shutdown.\n        If the executor hasn't finished within that duration, a warning is\n        emitted and the executor is closed.\n    \n        Example:\n    \n            async def main():\n                await asyncio.sleep(1)\n                print('hello')\n    \n            asyncio.run(main())\n        \"\"\"\n        if events._get_running_loop() is not None:\n            # fail fast with short traceback\n>           raise RuntimeError(\n                \"asyncio.run() cannot be called from a running event loop\")\nE           RuntimeError: asyncio.run() cannot be called from a running event loop\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py:190: RuntimeError\n\nThe above exception was the direct cause of the following exception:\n\nself = <tests.test_updates.TestUpdates testMethod=test_top_stories>\n\n    async def test_top_stories(self):\n>       updates = await self.hn.updates()  # Await the asynchronous method\n\ntests\\test_updates.py:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nhackernews\\__init__.py:372: in updates\n    response = self._get_sync(url)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <hackernews.HackerNews object at 0x000002EFD86B1010>\nurl = 'https://hacker-news.firebaseio.com/v0/updates.json'\n\n    def _get_sync(self, url):\n        \"\"\"Synchronous method used for GET requests\n    \n        Args:\n            url (str): URL to fetch\n    \n        Returns:\n            Individual URL request's response\n    \n        Raises:\n          HTTPError: If HTTP request failed.\n        \"\"\"\n        async def fetch():\n            return await self._get_async(url)\n    \n        try:\n            return asyncio.run(fetch())\n        except Exception as e:\n>           raise HTTPError from e\nE           hackernews.HTTPError\n\nhackernews\\__init__.py:109: HTTPError"
      },
      "teardown": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_updates.py",
          "lineno": 28,
          "message": "AttributeError: 'HackerNews' object has no attribute 'session'"
        },
        "traceback": [
          {
            "path": "tests\\test_updates.py",
            "lineno": 28,
            "message": "AttributeError"
          }
        ],
        "longrepr": "self = <tests.test_updates.TestUpdates testMethod=test_top_stories>\n\n    async def asyncTearDown(self):\n>       await self.hn.session.close()  # Ensure proper cleanup of async resources\nE       AttributeError: 'HackerNews' object has no attribute 'session'\n\ntests\\test_updates.py:28: AttributeError"
      }
    }
  ],
  "warnings": [
    {
      "message": "coroutine 'HackerNews._get_sync.<locals>.fetch' was never awaited\nCoroutine created at (most recent call last)\n  File \"C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py\", line 118, in run\n    return self._loop.run_until_complete(task)\n  File \"C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py\", line 674, in run_until_complete\n    self.run_forever()\n  File \"C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\windows_events.py\", line 322, in run_forever\n    super().run_forever()\n  File \"C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py\", line 641, in run_forever\n    self._run_once()\n  File \"C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py\", line 1979, in _run_once\n    handle._run()\n  File \"C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\events.py\", line 88, in _run\n    self._context.run(self._callback, *self._args)\n  File \"D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_ask_stories.py\", line 22, in test_ask_stories\n    ask_stories = await self.hn.ask_stories(limit=10)\n  File \"D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py\", line 321, in ask_stories\n    ask_stories = self._get_stories('askstories', limit)\n  File \"D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py\", line 161, in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n  File \"D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py\", line 107, in _get_sync\n    return asyncio.run(fetch())",
      "category": "RuntimeWarning",
      "when": "runtest",
      "filename": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py",
      "lineno": 265
    },
    {
      "message": "coroutine 'HackerNews._get_sync.<locals>.fetch' was never awaited\nCoroutine created at (most recent call last)\n  File \"C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\runners.py\", line 118, in run\n    return self._loop.run_until_complete(task)\n  File \"C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py\", line 674, in run_until_complete\n    self.run_forever()\n  File \"C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\windows_events.py\", line 322, in run_forever\n    super().run_forever()\n  File \"C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py\", line 641, in run_forever\n    self._run_once()\n  File \"C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\base_events.py\", line 1979, in _run_once\n    handle._run()\n  File \"C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\asyncio\\events.py\", line 88, in _run\n    self._context.run(self._callback, *self._args)\n  File \"D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\tests\\test_ask_stories.py\", line 28, in test_ask_stories_raw\n    ask_stories = await self.hn.ask_stories(raw=True)\n  File \"D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py\", line 321, in ask_stories\n    ask_stories = self._get_stories('askstories', limit)\n  File \"D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py\", line 161, in _get_stories\n    story_ids = self._get_sync(url)[:limit]\n  File \"D:\\repos\\avinassh@haxor__8c0cb6be__requests__treq\\hackernews\\__init__.py\", line 107, in _get_sync\n    return asyncio.run(fetch())",
      "category": "RuntimeWarning",
      "when": "runtest",
      "filename": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\traceback.py",
      "lineno": 265
    },
    {
      "message": "It is deprecated to return a value that is not None from a test case (<bound method TestShowStories.test_show_stories of <tests.test_show_stories.TestShowStories testMethod=test_show_stories>>)",
      "category": "DeprecationWarning",
      "when": "runtest",
      "filename": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\case.py",
      "lineno": 690
    },
    {
      "message": "It is deprecated to return a value that is not None from a test case (<bound method TestShowStories.test_show_stories_raw of <tests.test_show_stories.TestShowStories testMethod=test_show_stories_raw>>)",
      "category": "DeprecationWarning",
      "when": "runtest",
      "filename": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\case.py",
      "lineno": 690
    }
  ]
}