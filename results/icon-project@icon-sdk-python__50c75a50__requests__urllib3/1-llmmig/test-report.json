{
  "exitcode": 1,
  "summary": {
    "failed": 61,
    "passed": 69,
    "skipped": 4,
    "total": 134,
    "collected": 134
  },
  "collectors": [
    {
      "nodeid": "",
      "outcome": "passed",
      "result": [
        {
          "nodeid": ".",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "iconsdk/builder",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "iconsdk/libs",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "iconsdk/providers",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "iconsdk/utils/typing",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "iconsdk/utils",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "iconsdk/utils/typing",
          "type": "Package"
        }
      ]
    },
    {
      "nodeid": "iconsdk/wallet",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "iconsdk",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "iconsdk/builder",
          "type": "Package"
        },
        {
          "nodeid": "iconsdk/libs",
          "type": "Package"
        },
        {
          "nodeid": "iconsdk/providers",
          "type": "Package"
        },
        {
          "nodeid": "iconsdk/utils",
          "type": "Package"
        },
        {
          "nodeid": "iconsdk/wallet",
          "type": "Package"
        }
      ]
    },
    {
      "nodeid": "iconsdk.egg-info",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "quickstart/examples/sample_data",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "quickstart/examples/test",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "quickstart/examples/util",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "quickstart/examples",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "quickstart/examples/sample_data",
          "type": "Dir"
        },
        {
          "nodeid": "quickstart/examples/test",
          "type": "Package"
        },
        {
          "nodeid": "quickstart/examples/util",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "quickstart",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "quickstart/examples",
          "type": "Package"
        }
      ]
    },
    {
      "nodeid": "tests/api_call/test_call.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_call/test_call.py::TestCall",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_call/test_call.py::TestCall::test_call",
          "type": "TestCaseFunction",
          "lineno": 27
        },
        {
          "nodeid": "tests/api_call/test_call.py::TestCall::test_call_without_from",
          "type": "TestCaseFunction",
          "lineno": 85
        },
        {
          "nodeid": "tests/api_call/test_call.py::TestCall::test_call_without_params",
          "type": "TestCaseFunction",
          "lineno": 58
        }
      ]
    },
    {
      "nodeid": "tests/api_call/test_call.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_call/test_call.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_call/test_call.py::TestCall",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_call",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_call/test_call.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/api_debug/test_estimate_step.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep::test_estimate_step_with_call_transaction",
          "type": "TestCaseFunction",
          "lineno": 156
        },
        {
          "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep::test_estimate_step_with_deploy_transaction",
          "type": "TestCaseFunction",
          "lineno": 106
        },
        {
          "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep::test_estimate_step_with_deposit_transaction_add",
          "type": "TestCaseFunction",
          "lineno": 205
        },
        {
          "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep::test_estimate_step_with_deposit_transaction_withdraw",
          "type": "TestCaseFunction",
          "lineno": 250
        },
        {
          "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep::test_estimate_step_with_message_transaction",
          "type": "TestCaseFunction",
          "lineno": 63
        },
        {
          "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep::test_estimate_step_with_send_icx_transaction",
          "type": "TestCaseFunction",
          "lineno": 21
        }
      ]
    },
    {
      "nodeid": "tests/api_debug/test_estimate_step.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_debug/test_estimate_step.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_debug/test_get_trace.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_debug/test_get_trace.py::TestGetTrace",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_debug/test_get_trace.py::TestGetTrace::test_get_trace",
          "type": "TestCaseFunction",
          "lineno": 28
        },
        {
          "nodeid": "tests/api_debug/test_get_trace.py::TestGetTrace::test_get_trace_invalid",
          "type": "TestCaseFunction",
          "lineno": 48
        }
      ]
    },
    {
      "nodeid": "tests/api_debug/test_get_trace.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_debug/test_get_trace.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_debug/test_get_trace.py::TestGetTrace",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_debug",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_debug/test_estimate_step.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_debug/test_get_trace.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_full_response_base.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_full_response_base.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_full_response_base.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_full_response_base.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_full_response_base.py::TestFullResponseBase",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_balance.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_get_balance.py::TestFullResponseGetBalance",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_balance.py::TestFullResponseGetBalance::test_get_balance_full_response",
          "type": "TestCaseFunction",
          "lineno": 29
        },
        {
          "nodeid": "tests/api_full_response/test_get_balance.py::TestFullResponseGetBalance::test_get_balance_invalid",
          "type": "TestCaseFunction",
          "lineno": 57
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_balance.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_balance.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_get_balance.py::TestFullResponseGetBalance",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_block_by_hash.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_get_block_by_hash.py::TestFullResponseGetBlockByHash",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_block_by_hash.py::TestFullResponseGetBlockByHash::test_get_block_by_hash_full_response",
          "type": "TestCaseFunction",
          "lineno": 29
        },
        {
          "nodeid": "tests/api_full_response/test_get_block_by_hash.py::TestFullResponseGetBlockByHash::test_get_block_by_wrong_hash",
          "type": "TestCaseFunction",
          "lineno": 57
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_block_by_hash.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_block_by_hash.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_get_block_by_hash.py::TestFullResponseGetBlockByHash",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_block_by_height.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_get_block_by_height.py::TestFullResponseGetBlockByHeight",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_block_by_height.py::TestFullResponseGetBlockByHeight::test_get_block_by_height_full_response",
          "type": "TestCaseFunction",
          "lineno": 29
        },
        {
          "nodeid": "tests/api_full_response/test_get_block_by_height.py::TestFullResponseGetBlockByHeight::test_get_block_by_wrong_height",
          "type": "TestCaseFunction",
          "lineno": 57
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_block_by_height.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_block_by_height.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_get_block_by_height.py::TestFullResponseGetBlockByHeight",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_last_block.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_get_last_block.py::TestFullResponseGetBlockByHeight",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_last_block.py::TestFullResponseGetBlockByHeight::test_get_last_block_full_response",
          "type": "TestCaseFunction",
          "lineno": 29
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_last_block.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_last_block.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_get_last_block.py::TestFullResponseGetBlockByHeight",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_score_api.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_get_score_api.py::TestFullResponseGetScoreAPI",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_score_api.py::TestFullResponseGetScoreAPI::test_get_score_api_by_wrong_address",
          "type": "TestCaseFunction",
          "lineno": 50
        },
        {
          "nodeid": "tests/api_full_response/test_get_score_api.py::TestFullResponseGetScoreAPI::test_get_score_api_full_response",
          "type": "TestCaseFunction",
          "lineno": 29
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_score_api.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_score_api.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_get_score_api.py::TestFullResponseGetScoreAPI",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_total_supply.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_get_total_supply.py::TesFullResponseGetTotalSupply",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_total_supply.py::TesFullResponseGetTotalSupply::test_get_total_supply",
          "type": "TestCaseFunction",
          "lineno": 28
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_total_supply.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_total_supply.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_get_total_supply.py::TesFullResponseGetTotalSupply",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_transaction_by_hash.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_get_transaction_by_hash.py::TestFullResponseGetTransactionByHash",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_transaction_by_hash.py::TestFullResponseGetTransactionByHash::test_get_transaction_by_hash",
          "type": "TestCaseFunction",
          "lineno": 28
        },
        {
          "nodeid": "tests/api_full_response/test_get_transaction_by_hash.py::TestFullResponseGetTransactionByHash::test_get_transaction_wrong_hash",
          "type": "TestCaseFunction",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_transaction_by_hash.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_transaction_by_hash.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_get_transaction_by_hash.py::TestFullResponseGetTransactionByHash",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_transaction_result.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_get_transaction_result.py::TestGetTransactionResult",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_transaction_result.py::TestGetTransactionResult::test_get_transaction_result",
          "type": "TestCaseFunction",
          "lineno": 28
        },
        {
          "nodeid": "tests/api_full_response/test_get_transaction_result.py::TestGetTransactionResult::test_get_transaction_result_wrong_hash",
          "type": "TestCaseFunction",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_get_transaction_result.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_get_transaction_result.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_get_transaction_result.py::TestGetTransactionResult",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_send_call.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_send_call.py::TesFullResponseSendDeploy",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_send_call.py::TesFullResponseSendDeploy::test_send_call",
          "type": "TestCaseFunction",
          "lineno": 29
        },
        {
          "nodeid": "tests/api_full_response/test_send_call.py::TesFullResponseSendDeploy::test_send_call_wrong_address",
          "type": "TestCaseFunction",
          "lineno": 56
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_send_call.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_send_call.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_send_call.py::TesFullResponseSendDeploy",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_send_deploy.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_send_deploy.py::TesFullResponseSendDeploy",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_send_deploy.py::TesFullResponseSendDeploy::test_deploy_wrong_address",
          "type": "TestCaseFunction",
          "lineno": 58
        },
        {
          "nodeid": "tests/api_full_response/test_send_deploy.py::TesFullResponseSendDeploy::test_send_deploy",
          "type": "TestCaseFunction",
          "lineno": 30
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_send_deploy.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_send_deploy.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_send_deploy.py::TesFullResponseSendDeploy",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_send_deposit.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_send_deposit.py::TesFullResponseSendDeposit",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_send_deposit.py::TesFullResponseSendDeposit::test_add_deposit",
          "type": "TestCaseFunction",
          "lineno": 30
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_send_deposit.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_send_deposit.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_send_deposit.py::TesFullResponseSendDeposit",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_send_message.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_send_message.py::TestFullResponseSendMessage",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_send_message.py::TestFullResponseSendMessage::test_send_message",
          "type": "TestCaseFunction",
          "lineno": 31
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_send_message.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_send_message.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_send_message.py::TestFullResponseSendMessage",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_send_transfer.py::TestFullResponseBase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_full_response/test_send_transfer.py::TestFullResponseSendTransfer",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_send_transfer.py::TestFullResponseSendTransfer::test_send_transfer",
          "type": "TestCaseFunction",
          "lineno": 31
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response/test_send_transfer.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_send_transfer.py::TestFullResponseBase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_full_response/test_send_transfer.py::TestFullResponseSendTransfer",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_full_response",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_full_response/test_full_response_base.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_get_balance.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_get_block_by_hash.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_get_block_by_height.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_get_last_block.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_get_score_api.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_get_total_supply.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_get_transaction_by_hash.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_get_transaction_result.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_send_call.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_send_deploy.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_send_deposit.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_send_message.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_full_response/test_send_transfer.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_btp2.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_get/test_btp2.py::TestBTP2",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_btp2.py::TestBTP2::test_get_btp_header",
          "type": "TestCaseFunction",
          "lineno": 93
        },
        {
          "nodeid": "tests/api_get/test_btp2.py::TestBTP2::test_get_btp_messages",
          "type": "TestCaseFunction",
          "lineno": 84
        },
        {
          "nodeid": "tests/api_get/test_btp2.py::TestBTP2::test_get_btp_network_info",
          "type": "TestCaseFunction",
          "lineno": 66
        },
        {
          "nodeid": "tests/api_get/test_btp2.py::TestBTP2::test_get_btp_network_type_info",
          "type": "TestCaseFunction",
          "lineno": 75
        },
        {
          "nodeid": "tests/api_get/test_btp2.py::TestBTP2::test_get_btp_proof",
          "type": "TestCaseFunction",
          "lineno": 102
        },
        {
          "nodeid": "tests/api_get/test_btp2.py::TestBTP2::test_get_btp_source_information",
          "type": "TestCaseFunction",
          "lineno": 111
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_btp2.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_btp2.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_get/test_btp2.py::TestBTP2",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_balance.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_get/test_get_balance.py::TestGetBalance",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_balance.py::TestGetBalance::test_get_balance_from_wallet",
          "type": "TestCaseFunction",
          "lineno": 27
        },
        {
          "nodeid": "tests/api_get/test_get_balance.py::TestGetBalance::test_get_balance_invalid",
          "type": "TestCaseFunction",
          "lineno": 55
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_balance.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_balance.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_get/test_get_balance.py::TestGetBalance",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_block_by_hash.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_get/test_get_block_by_hash.py::TestGetBlockByHash",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_block_by_hash.py::TestGetBlockByHash::test_get_block_by_hash",
          "type": "TestCaseFunction",
          "lineno": 28
        },
        {
          "nodeid": "tests/api_get/test_get_block_by_hash.py::TestGetBlockByHash::test_get_block_by_wrong_hash",
          "type": "TestCaseFunction",
          "lineno": 79
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_block_by_hash.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_block_by_hash.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_get/test_get_block_by_hash.py::TestGetBlockByHash",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_block_by_height.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_get/test_get_block_by_height.py::TestGetBlockByHeight",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_block_by_height.py::TestGetBlockByHeight::test_get_block_by_height",
          "type": "TestCaseFunction",
          "lineno": 28
        },
        {
          "nodeid": "tests/api_get/test_get_block_by_height.py::TestGetBlockByHeight::test_get_block_by_height_invalid",
          "type": "TestCaseFunction",
          "lineno": 74
        },
        {
          "nodeid": "tests/api_get/test_get_block_by_height.py::TestGetBlockByHeight::test_get_block_by_wrong_height",
          "type": "TestCaseFunction",
          "lineno": 79
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_block_by_height.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_block_by_height.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_get/test_get_block_by_height.py::TestGetBlockByHeight",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_last_block.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_get/test_get_last_block.py::TestGetLastBlock",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_last_block.py::TestGetLastBlock::test_get_block_by_height",
          "type": "TestCaseFunction",
          "lineno": 27
        },
        {
          "nodeid": "tests/api_get/test_get_last_block.py::TestGetLastBlock::test_get_last_block_invalid",
          "type": "TestCaseFunction",
          "lineno": 68
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_last_block.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_last_block.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_get/test_get_last_block.py::TestGetLastBlock",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_score_api.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_get/test_get_score_api.py::TestGetScoreApi",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_score_api.py::TestGetScoreApi::test_get_score_api",
          "type": "TestCaseFunction",
          "lineno": 28
        },
        {
          "nodeid": "tests/api_get/test_get_score_api.py::TestGetScoreApi::test_get_score_api_by_wrong_address",
          "type": "TestCaseFunction",
          "lineno": 61
        },
        {
          "nodeid": "tests/api_get/test_get_score_api.py::TestGetScoreApi::test_get_score_api_invalid",
          "type": "TestCaseFunction",
          "lineno": 53
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_score_api.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_score_api.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_get/test_get_score_api.py::TestGetScoreApi",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_total_supply.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_get/test_get_total_supply.py::TestGetTotalSupply",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_total_supply.py::TestGetTotalSupply::test_get_total_supply",
          "type": "TestCaseFunction",
          "lineno": 26
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_total_supply.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_total_supply.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_get/test_get_total_supply.py::TestGetTotalSupply",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_transaction_by_hash.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_get/test_get_transaction_by_hash.py::TestGetTransactionByHash",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_transaction_by_hash.py::TestGetTransactionByHash::test_get_transaction_by_hash",
          "type": "TestCaseFunction",
          "lineno": 29
        },
        {
          "nodeid": "tests/api_get/test_get_transaction_by_hash.py::TestGetTransactionByHash::test_get_transaction_invalid",
          "type": "TestCaseFunction",
          "lineno": 67
        },
        {
          "nodeid": "tests/api_get/test_get_transaction_by_hash.py::TestGetTransactionByHash::test_get_transaction_wrong_hash",
          "type": "TestCaseFunction",
          "lineno": 77
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_transaction_by_hash.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_transaction_by_hash.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_get/test_get_transaction_by_hash.py::TestGetTransactionByHash",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_transaction_result.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_get/test_get_transaction_result.py::TestGetTransactionResult",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_transaction_result.py::TestGetTransactionResult::test_get_transaction_result",
          "type": "TestCaseFunction",
          "lineno": 29
        },
        {
          "nodeid": "tests/api_get/test_get_transaction_result.py::TestGetTransactionResult::test_get_transaction_result_invalid",
          "type": "TestCaseFunction",
          "lineno": 98
        },
        {
          "nodeid": "tests/api_get/test_get_transaction_result.py::TestGetTransactionResult::test_get_transaction_result_wrong_hash",
          "type": "TestCaseFunction",
          "lineno": 73
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_get_transaction_result.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_get_transaction_result.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_get/test_get_transaction_result.py::TestGetTransactionResult",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_wait_transaction_result.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_get/test_wait_transaction_result.py::TestWaitTransactionResult",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_wait_transaction_result.py::TestWaitTransactionResult::test_wait_transaction_result",
          "type": "TestCaseFunction",
          "lineno": 29
        },
        {
          "nodeid": "tests/api_get/test_wait_transaction_result.py::TestWaitTransactionResult::test_wait_transaction_result_invalid",
          "type": "TestCaseFunction",
          "lineno": 72
        }
      ]
    },
    {
      "nodeid": "tests/api_get/test_wait_transaction_result.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_wait_transaction_result.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_get/test_wait_transaction_result.py::TestWaitTransactionResult",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_get",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_get/test_btp2.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_get/test_get_balance.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_get/test_get_block_by_hash.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_get/test_get_block_by_height.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_get/test_get_last_block.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_get/test_get_score_api.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_get/test_get_total_supply.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_get/test_get_transaction_by_hash.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_get/test_get_transaction_result.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_get/test_wait_transaction_result.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/api_send/sample_token",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_send/sample_token2",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_send/test_send_deposit.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_send/test_send_deposit.py::TestSendDeposit",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_send/test_send_deposit.py::TestSendDeposit::test_add_deposit",
          "type": "TestCaseFunction",
          "lineno": 14
        },
        {
          "nodeid": "tests/api_send/test_send_deposit.py::TestSendDeposit::test_withdraw_deposit",
          "type": "TestCaseFunction",
          "lineno": 68
        }
      ]
    },
    {
      "nodeid": "tests/api_send/test_send_deposit.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_send/test_send_deposit.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_send/test_send_deposit.py::TestSendDeposit",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_send/test_send_message.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_send/test_send_message.py::TestSendMessage",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_send/test_send_message.py::TestSendMessage::test_get_block",
          "type": "TestCaseFunction",
          "lineno": 113
        },
        {
          "nodeid": "tests/api_send/test_send_message.py::TestSendMessage::test_get_transaction_result",
          "type": "TestCaseFunction",
          "lineno": 76
        },
        {
          "nodeid": "tests/api_send/test_send_message.py::TestSendMessage::test_invalid",
          "type": "TestCaseFunction",
          "lineno": 170
        },
        {
          "nodeid": "tests/api_send/test_send_message.py::TestSendMessage::test_send_message",
          "type": "TestCaseFunction",
          "lineno": 29
        }
      ]
    },
    {
      "nodeid": "tests/api_send/test_send_message.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_send/test_send_message.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_send/test_send_message.py::TestSendMessage",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_send/test_send_super.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_send/test_send_super.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_send/test_send_super.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_send/test_send_super.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_send/test_send_super.py::TestSendSuper",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_send/test_send_transfer.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_send/test_send_transfer.py::TestSendTransfer",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_send/test_send_transfer.py::TestSendTransfer::test_invalid_transfer1",
          "type": "TestCaseFunction",
          "lineno": 74
        },
        {
          "nodeid": "tests/api_send/test_send_transfer.py::TestSendTransfer::test_invalid_transfer2",
          "type": "TestCaseFunction",
          "lineno": 87
        },
        {
          "nodeid": "tests/api_send/test_send_transfer.py::TestSendTransfer::test_transfer",
          "type": "TestCaseFunction",
          "lineno": 29
        }
      ]
    },
    {
      "nodeid": "tests/api_send/test_send_transfer.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_send/test_send_transfer.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_send/test_send_transfer.py::TestSendTransfer",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_send/test_send_tx_wait.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_send/test_send_tx_wait.py::TestSendAndWait",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_send/test_send_tx_wait.py::TestSendAndWait::test_transfer",
          "type": "TestCaseFunction",
          "lineno": 29
        }
      ]
    },
    {
      "nodeid": "tests/api_send/test_send_tx_wait.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_send/test_send_tx_wait.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_send/test_send_tx_wait.py::TestSendAndWait",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_convert_tx_to_jsonrpc_request_for_add_deposit_transaction",
          "type": "TestCaseFunction",
          "lineno": 116
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_convert_tx_to_jsonrpc_request_for_call_transaction",
          "type": "TestCaseFunction",
          "lineno": 90
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_convert_tx_to_jsonrpc_request_for_deploy_transaction",
          "type": "TestCaseFunction",
          "lineno": 63
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_convert_tx_to_jsonrpc_request_for_icx_transaction",
          "type": "TestCaseFunction",
          "lineno": 28
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_convert_tx_to_jsonrpc_request_for_message_transaction",
          "type": "TestCaseFunction",
          "lineno": 104
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_convert_tx_to_jsonrpc_request_for_withdraw_deposit_transaction",
          "type": "TestCaseFunction",
          "lineno": 130
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_signed_transaction_with_call_transaction_without_step_limit",
          "type": "TestCaseFunction",
          "lineno": 170
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_signed_transaction_with_deploy_transaction_without_step_limit",
          "type": "TestCaseFunction",
          "lineno": 156
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_signed_transaction_with_deposit_transaction_of_add_action_without_step_limit",
          "type": "TestCaseFunction",
          "lineno": 194
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_signed_transaction_with_deposit_transaction_of_deposit_action_without_step_limit",
          "type": "TestCaseFunction",
          "lineno": 207
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_signed_transaction_with_icx_transaction_without_step_limit",
          "type": "TestCaseFunction",
          "lineno": 144
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_signed_transaction_with_message_transaction_without_step_limit",
          "type": "TestCaseFunction",
          "lineno": 183
        }
      ]
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/api_send",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_send/sample_token",
          "type": "Package"
        },
        {
          "nodeid": "tests/api_send/sample_token2",
          "type": "Package"
        },
        {
          "nodeid": "tests/api_send/test_send_deposit.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_send/test_send_message.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_send/test_send_super.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_send/test_send_transfer.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_send/test_send_tx_wait.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/api_send/test_signed_transaction.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/builder/test_call_builder.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/builder/test_call_builder.py::TestCallBuilder",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/builder/test_call_builder.py::TestCallBuilder::test_make_call_builder",
          "type": "TestCaseFunction",
          "lineno": 22
        },
        {
          "nodeid": "tests/builder/test_call_builder.py::TestCallBuilder::test_make_call_builder_changed",
          "type": "TestCaseFunction",
          "lineno": 59
        },
        {
          "nodeid": "tests/builder/test_call_builder.py::TestCallBuilder::test_make_call_builder_from_dict_to_dict",
          "type": "TestCaseFunction",
          "lineno": 45
        }
      ]
    },
    {
      "nodeid": "tests/builder/test_call_builder.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/builder/test_call_builder.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/builder/test_call_builder.py::TestCallBuilder",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/builder/test_transaction_builder.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/builder/test_transaction_builder.py::TestTransactionBuilder",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/builder/test_transaction_builder.py::TestTransactionBuilder::test_deposit_transaction_id_and_amount_at_same_time_for_withdraw_action",
          "type": "TestCaseFunction",
          "lineno": 307
        },
        {
          "nodeid": "tests/builder/test_transaction_builder.py::TestTransactionBuilder::test_deposit_transaction_to_dict_for_add_action",
          "type": "TestCaseFunction",
          "lineno": 212
        },
        {
          "nodeid": "tests/builder/test_transaction_builder.py::TestTransactionBuilder::test_deposit_transaction_to_dict_for_withdraw_action",
          "type": "TestCaseFunction",
          "lineno": 266
        },
        {
          "nodeid": "tests/builder/test_transaction_builder.py::TestTransactionBuilder::test_transaction_builder_from_dict",
          "type": "TestCaseFunction",
          "lineno": 129
        }
      ]
    },
    {
      "nodeid": "tests/builder/test_transaction_builder.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/builder/test_transaction_builder.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/builder/test_transaction_builder.py::TestTransactionBuilder",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/builder",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/builder/test_call_builder.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/builder/test_transaction_builder.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/converter/test_converter.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/converter/test_converter.py::TestConverter",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/converter/test_converter.py::TestConverter::test_converter_blocks",
          "type": "TestCaseFunction",
          "lineno": 122
        },
        {
          "nodeid": "tests/converter/test_converter.py::TestConverter::test_converter_transactions",
          "type": "TestCaseFunction",
          "lineno": 143
        },
        {
          "nodeid": "tests/converter/test_converter.py::TestConverter::test_converter_tx_results",
          "type": "TestCaseFunction",
          "lineno": 151
        },
        {
          "nodeid": "tests/converter/test_converter.py::TestConverter::test_integrate_converter",
          "type": "TestCaseFunction",
          "lineno": 157
        }
      ]
    },
    {
      "nodeid": "tests/converter/test_converter.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/converter/test_converter.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/converter/test_converter.py::TestConverter",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/converter",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/converter/test_converter.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/keystore_file/test_keystore.txt",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/keystore_file/test_keystore_for_transfer.txt",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/keystore_file/test_keystore_for_transfer2.txt",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/keystore_file",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/keystore_file/test_keystore.txt",
          "type": "DoctestTextfile"
        },
        {
          "nodeid": "tests/keystore_file/test_keystore_for_transfer.txt",
          "type": "DoctestTextfile"
        },
        {
          "nodeid": "tests/keystore_file/test_keystore_for_transfer2.txt",
          "type": "DoctestTextfile"
        }
      ]
    },
    {
      "nodeid": "tests/libs/sample_token/tests/test_integrate_sample_token.py",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/libs/sample_token/tests",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/libs/sample_token/tests/test_integrate_sample_token.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/libs/sample_token",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/libs/sample_token/tests",
          "type": "Package"
        }
      ]
    },
    {
      "nodeid": "tests/libs/test_in_memory_zip.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/libs/test_in_memory_zip.py::TestInMemoryZip",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/libs/test_in_memory_zip.py::TestInMemoryZip::test_in_memory_zip",
          "type": "TestCaseFunction",
          "lineno": 23
        }
      ]
    },
    {
      "nodeid": "tests/libs/test_in_memory_zip.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/libs/test_in_memory_zip.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/libs/test_in_memory_zip.py::TestInMemoryZip",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/libs/test_serializer.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/libs/test_serializer.py::TestSerializer",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/libs/test_serializer.py::TestSerializer::test_for_serialize_case_for_calling",
          "type": "TestCaseFunction",
          "lineno": 31
        },
        {
          "nodeid": "tests/libs/test_serializer.py::TestSerializer::test_for_serialize_case_for_sending_normal_tx",
          "type": "TestCaseFunction",
          "lineno": 23
        }
      ]
    },
    {
      "nodeid": "tests/libs/test_serializer.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/libs/test_serializer.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/libs/test_serializer.py::TestSerializer",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/libs/test_signer.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/libs/test_signer.py::TestIcxSigner",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/libs/test_signer.py::TestIcxSigner::test_verify_recoverable_sign",
          "type": "TestCaseFunction",
          "lineno": 33
        }
      ]
    },
    {
      "nodeid": "tests/libs/test_signer.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/libs/test_signer.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/libs/test_signer.py::TestIcxSigner",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/libs",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/libs/sample_token",
          "type": "Package"
        },
        {
          "nodeid": "tests/libs/test_in_memory_zip.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/libs/test_serializer.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/libs/test_signer.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/providers/test_http_provider.py::TestSendSuper",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/providers/test_http_provider.py::TestHTTPProvider",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/providers/test_http_provider.py::TestHTTPProvider::test_set_http_provider_by_new_initializer_with_invalid_url",
          "type": "TestCaseFunction",
          "lineno": 70
        },
        {
          "nodeid": "tests/providers/test_http_provider.py::TestHTTPProvider::test_set_http_provider_by_the_initializer_with_valid_url",
          "type": "TestCaseFunction",
          "lineno": 57
        },
        {
          "nodeid": "tests/providers/test_http_provider.py::TestHTTPProvider::test_set_http_provider_with_param",
          "type": "TestCaseFunction",
          "lineno": 27
        },
        {
          "nodeid": "tests/providers/test_http_provider.py::TestHTTPProvider::test_set_http_provider_with_request_kwargs",
          "type": "TestCaseFunction",
          "lineno": 37
        }
      ]
    },
    {
      "nodeid": "tests/providers/test_http_provider.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/providers/test_http_provider.py::TestSendSuper",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/providers/test_http_provider.py::TestHTTPProvider",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/providers",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/providers/test_http_provider.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/utils/test_convert_type.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/utils/test_convert_type.py::TestConvertType",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/utils/test_convert_type.py::TestConvertType::test_convert_hex_str_to_bytes",
          "type": "TestCaseFunction",
          "lineno": 50
        },
        {
          "nodeid": "tests/utils/test_convert_type.py::TestConvertType::test_convert_negative_value_to_hex_str",
          "type": "TestCaseFunction",
          "lineno": 23
        },
        {
          "nodeid": "tests/utils/test_convert_type.py::TestConvertType::test_convert_positive_value_to_hex_str",
          "type": "TestCaseFunction",
          "lineno": 32
        },
        {
          "nodeid": "tests/utils/test_convert_type.py::TestConvertType::test_convert_zero_value_to_hex_str",
          "type": "TestCaseFunction",
          "lineno": 41
        }
      ]
    },
    {
      "nodeid": "tests/utils/test_convert_type.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/utils/test_convert_type.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/utils/test_convert_type.py::TestConvertType",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/utils/test_hexadecimal.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/utils/test_hexadecimal.py::TestHexadecimal",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/utils/test_hexadecimal.py::TestHexadecimal::test_is_hex_string_prefixed_with_0x",
          "type": "TestCaseFunction",
          "lineno": 46
        },
        {
          "nodeid": "tests/utils/test_hexadecimal.py::TestHexadecimal::test_is_lowercase_hex_string",
          "type": "TestCaseFunction",
          "lineno": 29
        }
      ]
    },
    {
      "nodeid": "tests/utils/test_hexadecimal.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/utils/test_hexadecimal.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/utils/test_hexadecimal.py::TestHexadecimal",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/utils/test_validation.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/utils/test_validation.py::TestValidation",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/utils/test_validation.py::TestValidation::test_method_has_keys",
          "type": "TestCaseFunction",
          "lineno": 36
        },
        {
          "nodeid": "tests/utils/test_validation.py::TestValidation::test_method_validate_keystore_file",
          "type": "TestCaseFunction",
          "lineno": 29
        },
        {
          "nodeid": "tests/utils/test_validation.py::TestValidation::test_validate_keystore_file_is_for_icon",
          "type": "TestCaseFunction",
          "lineno": 70
        }
      ]
    },
    {
      "nodeid": "tests/utils/test_validation.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/utils/test_validation.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/utils/test_validation.py::TestValidation",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/utils",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/utils/test_convert_type.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/utils/test_hexadecimal.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/utils/test_validation.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_get_public_key[True-True-str-33]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_get_public_key[True-False-bytes-33]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_get_public_key[False-True-str-65]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_get_public_key[False-False-bytes-65]",
          "type": "Function",
          "lineno": 11
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_get_private_key",
          "type": "Function",
          "lineno": 31
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_private_key",
          "type": "Function",
          "lineno": 41
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_public_key",
          "type": "Function",
          "lineno": 49
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_to_dict",
          "type": "Function",
          "lineno": 55
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_copy",
          "type": "Function",
          "lineno": 65
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_hash",
          "type": "Function",
          "lineno": 73
        }
      ]
    },
    {
      "nodeid": "tests/wallet/test_wallet.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet",
          "type": "Class"
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::test_public_key_to_address",
          "type": "Function",
          "lineno": 79
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::test_convert_public_key_format[True-True-33]",
          "type": "Function",
          "lineno": 89
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::test_convert_public_key_format[True-False-65]",
          "type": "Function",
          "lineno": 89
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::test_convert_public_key_format[False-True-33]",
          "type": "Function",
          "lineno": 89
        },
        {
          "nodeid": "tests/wallet/test_wallet.py::test_convert_public_key_format[False-False-65]",
          "type": "Function",
          "lineno": 89
        }
      ]
    },
    {
      "nodeid": "tests/wallet/test_wallet_create.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/wallet/test_wallet_create.py::TestWalletCreate",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/wallet/test_wallet_create.py::TestWalletCreate::test_wallet_create_successfully",
          "type": "TestCaseFunction",
          "lineno": 23
        }
      ]
    },
    {
      "nodeid": "tests/wallet/test_wallet_create.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/wallet/test_wallet_create.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/wallet/test_wallet_create.py::TestWalletCreate",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/wallet/test_wallet_load_by_private_key.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/wallet/test_wallet_load_by_private_key.py::TestWalletLoadByPrivateKey",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/wallet/test_wallet_load_by_private_key.py::TestWalletLoadByPrivateKey::test_wallet_load_by_private_key",
          "type": "TestCaseFunction",
          "lineno": 25
        }
      ]
    },
    {
      "nodeid": "tests/wallet/test_wallet_load_by_private_key.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/wallet/test_wallet_load_by_private_key.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/wallet/test_wallet_load_by_private_key.py::TestWalletLoadByPrivateKey",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py::TestWalletLoadFromKeystoreFile",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py::TestWalletLoadFromKeystoreFile::test_wallet_load_and_call_api",
          "type": "TestCaseFunction",
          "lineno": 63
        },
        {
          "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py::TestWalletLoadFromKeystoreFile::test_wallet_load_from_invalid_directory",
          "type": "TestCaseFunction",
          "lineno": 53
        },
        {
          "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py::TestWalletLoadFromKeystoreFile::test_wallet_load_from_keystore_file",
          "type": "TestCaseFunction",
          "lineno": 37
        },
        {
          "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py::TestWalletLoadFromKeystoreFile::test_wallet_load_with_invalid_password",
          "type": "TestCaseFunction",
          "lineno": 58
        }
      ]
    },
    {
      "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py::TestWalletLoadFromKeystoreFile",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/wallet/test_wallet_store.py::TestCase",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/wallet/test_wallet_store.py::TestWalletStore",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/wallet/test_wallet_store.py::TestWalletStore::test_wallet_store_on_the_wrong_path",
          "type": "TestCaseFunction",
          "lineno": 41
        },
        {
          "nodeid": "tests/wallet/test_wallet_store.py::TestWalletStore::test_wallet_store_overwriting",
          "type": "TestCaseFunction",
          "lineno": 52
        },
        {
          "nodeid": "tests/wallet/test_wallet_store.py::TestWalletStore::test_wallet_store_successfully",
          "type": "TestCaseFunction",
          "lineno": 32
        },
        {
          "nodeid": "tests/wallet/test_wallet_store.py::TestWalletStore::test_wallet_store_with_wrong_password",
          "type": "TestCaseFunction",
          "lineno": 47
        }
      ]
    },
    {
      "nodeid": "tests/wallet/test_wallet_store.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/wallet/test_wallet_store.py::TestCase",
          "type": "UnitTestCase"
        },
        {
          "nodeid": "tests/wallet/test_wallet_store.py::TestWalletStore",
          "type": "UnitTestCase"
        }
      ]
    },
    {
      "nodeid": "tests/wallet",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/wallet/test_wallet.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/wallet/test_wallet_create.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/wallet/test_wallet_load_by_private_key.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/wallet/test_wallet_store.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": "tests",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/api_call",
          "type": "Package"
        },
        {
          "nodeid": "tests/api_debug",
          "type": "Package"
        },
        {
          "nodeid": "tests/api_full_response",
          "type": "Package"
        },
        {
          "nodeid": "tests/api_get",
          "type": "Package"
        },
        {
          "nodeid": "tests/api_send",
          "type": "Package"
        },
        {
          "nodeid": "tests/builder",
          "type": "Package"
        },
        {
          "nodeid": "tests/converter",
          "type": "Package"
        },
        {
          "nodeid": "tests/keystore_file",
          "type": "Dir"
        },
        {
          "nodeid": "tests/libs",
          "type": "Package"
        },
        {
          "nodeid": "tests/providers",
          "type": "Package"
        },
        {
          "nodeid": "tests/utils",
          "type": "Package"
        },
        {
          "nodeid": "tests/wallet",
          "type": "Package"
        }
      ]
    },
    {
      "nodeid": ".",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "iconsdk",
          "type": "Package"
        },
        {
          "nodeid": "iconsdk.egg-info",
          "type": "Dir"
        },
        {
          "nodeid": "quickstart",
          "type": "Dir"
        },
        {
          "nodeid": "tests",
          "type": "Package"
        }
      ]
    }
  ],
  "tests": [
    {
      "nodeid": "tests/api_call/test_call.py::TestCall::test_call",
      "lineno": 27,
      "outcome": "failed",
      "keywords": [
        "test_call",
        "__wrapped__",
        "patchings",
        "TestCall",
        "test_call.py",
        "api_call",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C986E060>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_call\\test_call.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 289,
            "message": "in call"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C986E060>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C986CEC0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_call\", \"id\": 1234, \"params\": {\"to\": \"hx5bfdb090f43a808005ffc27c25b213145e80b7cd\", \"dataType\": \"call\", \"data\": {\"method\": \"getStepCosts\"}, \"from\": \"hxe7af5fcfd8dfc67530a01a0e403882687528dfcb\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C986E060>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C986E060>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_call.test_call.TestCall testMethod=test_call>\n_make_id = <MagicMock name='_make_id' id='1592487015680'>\n\n    def test_call(self, _make_id):\n    \n        # with from\n        test_call = CallBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(self.setting[\"to\"]) \\\n            .method(\"getStepCosts\") \\\n            .params({}) \\\n            .build()\n    \n        with requests_mock.Mocker() as m:\n            expected_request = {\n                \"jsonrpc\": \"2.0\",\n                \"method\": \"icx_call\",\n                \"id\": 1234,\n                \"params\": {\n                    \"to\": self.setting[\"to\"],\n                    \"dataType\": \"call\",\n                    \"data\": {\n                        \"method\": \"getStepCosts\"\n                    },\n                    \"from\": self.setting[\"from\"]\n                }\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.call(test_call)\n\ntests\\api_call\\test_call.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:289: in call\n    return self.__provider.make_request('icx_call', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C986E060>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C986CEC0>\n_stacktrace = <traceback object at 0x00000172C9867F40>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C986E060>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_call/test_call.py::TestCall::test_call_without_from",
      "lineno": 85,
      "outcome": "failed",
      "keywords": [
        "test_call_without_from",
        "__wrapped__",
        "patchings",
        "TestCall",
        "test_call.py",
        "api_call",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C17770>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_call\\test_call.py",
            "lineno": 106,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 289,
            "message": "in call"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9C17770>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C151F0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_call\", \"id\": 1234, \"params\": {\"to\": \"hx5bfdb090f43a808005ffc27c25b213145e80b7cd\", \"dataType\": \"call\", \"data\": {\"method\": \"getStepCosts\"}}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9C17770>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9C17770>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_call.test_call.TestCall testMethod=test_call_without_from>\n_make_id = <MagicMock name='_make_id' id='1592522799344'>\n\n    def test_call_without_from(self, _make_id):\n        test_call = CallBuilder() \\\n            .to(self.setting[\"to\"]) \\\n            .method(\"getStepCosts\") \\\n            .build()\n    \n        with requests_mock.Mocker() as m:\n            expected_request = {\n                \"jsonrpc\": \"2.0\",\n                \"method\": \"icx_call\",\n                \"id\": 1234,\n                \"params\": {\n                    \"to\": self.setting[\"to\"],\n                    \"dataType\": \"call\",\n                    \"data\": {\n                        \"method\": \"getStepCosts\"\n                    },\n                }\n            }\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.call(test_call)\n\ntests\\api_call\\test_call.py:106: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:289: in call\n    return self.__provider.make_request('icx_call', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C17770>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C151F0>\n_stacktrace = <traceback object at 0x00000172C9FE42C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C17770>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_call/test_call.py::TestCall::test_call_without_params",
      "lineno": 58,
      "outcome": "failed",
      "keywords": [
        "test_call_without_params",
        "__wrapped__",
        "patchings",
        "TestCall",
        "test_call.py",
        "api_call",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E29CD0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_call\\test_call.py",
            "lineno": 81,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 289,
            "message": "in call"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9E29CD0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E282C0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_call\", \"id\": 1234, \"params\": {\"to\": \"hx5bfdb090f43a808005ffc27c25b213145e80b7cd\", \"dataType\": \"call\", \"data\": {\"method\": \"getStepCosts\"}, \"from\": \"hxe7af5fcfd8dfc67530a01a0e403882687528dfcb\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9E29CD0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9E29CD0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_call.test_call.TestCall testMethod=test_call_without_params>\n_make_id = <MagicMock name='_make_id' id='1592518962608'>\n\n    def test_call_without_params(self, _make_id):\n        test_call = CallBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(self.setting[\"to\"]) \\\n            .method(\"getStepCosts\") \\\n            .build()\n    \n        with requests_mock.Mocker() as m:\n            expected_request = {\n                \"jsonrpc\": \"2.0\",\n                \"method\": \"icx_call\",\n                \"id\": 1234,\n                \"params\": {\n                    \"to\": self.setting[\"to\"],\n                    \"dataType\": \"call\",\n                    \"data\": {\n                        \"method\": \"getStepCosts\"\n                    },\n                    \"from\": self.setting[\"from\"]\n                }\n            }\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.call(test_call)\n\ntests\\api_call\\test_call.py:81: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:289: in call\n    return self.__provider.make_request('icx_call', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E29CD0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E282C0>\n_stacktrace = <traceback object at 0x00000172CA07D2C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E29CD0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep::test_estimate_step_with_call_transaction",
      "lineno": 156,
      "outcome": "failed",
      "keywords": [
        "test_estimate_step_with_call_transaction",
        "__wrapped__",
        "patchings",
        "TestEstimateStep",
        "test_estimate_step.py",
        "api_debug",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E2A060>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_debug\\test_estimate_step.py",
            "lineno": 199,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 351,
            "message": "in estimate_step"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9E2A060>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E2A3C0>\nmethod = 'POST', url = '/api/v3d'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"debug_estimateStep\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc6...ta\": {\"method\": \"transfer\", \"params\": {\"addr_to\": \"hx5bfdb090f43a808005ffc27c25b213145e80b7cd\", \"value\": \"0xf4240\"}}}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3d'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3d', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9E2A060>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9E2A060>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_debug.test_estimate_step.TestEstimateStep testMethod=test_estimate_step_with_call_transaction>\n_make_id = <MagicMock name='_make_id' id='1592522800256'>\n\n    def test_estimate_step_with_call_transaction(self, _make_id):\n        params = {\"addr_to\": self.setting[\"to\"], \"value\": 1000000}\n        call_transaction = (CallTransactionBuilder()\n            .from_(self.setting[\"from\"])\n            .to(\"cx4d6f646441a3f9c9b91019c9b98e3c342cceb114\")\n            .nid(self.setting[\"nid\"])\n            .timestamp(self.setting[\"timestamp\"])\n            .nonce(self.setting[\"nonce\"])\n            .method(\"transfer\")\n            .params(params)\n            .build())\n        with requests_mock.Mocker() as m:\n            expected_step = 155_160\n    \n            expected_request = {\n                'jsonrpc': '2.0',\n                'method': 'debug_estimateStep',\n                'id': 1234,\n                'params': {\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'to': \"cx4d6f646441a3f9c9b91019c9b98e3c342cceb114\",\n                    'version': hex(self.version),\n                    'dataType': 'call',\n                    'data': {\n                        'method': 'transfer',\n                        'params': {\n                            'addr_to': 'hx5bfdb090f43a808005ffc27c25b213145e80b7cd',\n                            'value': '0xf4240'\n                        }\n                    }\n                }\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': hex(expected_step),\n                'id': 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.estimate_step(call_transaction)\n\ntests\\api_debug\\test_estimate_step.py:199: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:351: in estimate_step\n    result = self.__provider.make_request('debug_estimateStep', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3d', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E2A060>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E2A3C0>\n_stacktrace = <traceback object at 0x00000172CA0FE180>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E2A060>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep::test_estimate_step_with_deploy_transaction",
      "lineno": 106,
      "outcome": "failed",
      "keywords": [
        "test_estimate_step_with_deploy_transaction",
        "__wrapped__",
        "patchings",
        "TestEstimateStep",
        "test_estimate_step.py",
        "api_debug",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C6EE70>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_debug\\test_estimate_step.py",
            "lineno": 151,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 351,
            "message": "in estimate_step"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9C6EE70>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C6E990>\nmethod = 'POST', url = '/api/v3d'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"debug_estimateStep\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc6...f6b656e2f7061636b6167652e6a736f6e504b0506000000000300030085010000e00300000000\", \"params\": {\"init_supply\": \"0x2710\"}}}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3d'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3d', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9C6EE70>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9C6EE70>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_debug.test_estimate_step.TestEstimateStep testMethod=test_estimate_step_with_deploy_transaction>\n_make_id = <MagicMock name='_make_id' id='1592523155280'>\n\n    def test_estimate_step_with_deploy_transaction(self, _make_id):\n        param = {\"init_supply\": 10000}\n        deploy_transaction = (DeployTransactionBuilder()\n            .from_(self.setting[\"from\"])\n            .to(self.setting[\"to_install\"])\n            .step_limit(self.setting[\"step_limit\"])\n            .nid(self.setting[\"nid\"])\n            .nonce(self.setting[\"nonce\"])\n            .timestamp(self.setting[\"timestamp\"])\n            .content_type(self.setting[\"content_type\"])\n            .content(self.setting[\"content_install\"])\n            .params(param)\n            .version(3)\n            .build())\n    \n        with requests_mock.Mocker() as m:\n            expected_step = 1_042_767_600\n            expected_request = {\n                'jsonrpc': '2.0',\n                'method': 'debug_estimateStep',\n                'id': 1234,\n                'params': {\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'to': self.setting[\"to_install\"],\n                    'version': hex(self.version),\n                    'data': {\n                        'contentType': self.setting[\"content_type\"],\n                        'content': f'0x{self.setting[\"content_install\"].hex()}',\n                        'params': {'init_supply': hex(param[\"init_supply\"])}\n                    },\n                    'dataType': 'deploy'\n                }\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': hex(expected_step),\n                'id': 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.estimate_step(deploy_transaction)\n\ntests\\api_debug\\test_estimate_step.py:151: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:351: in estimate_step\n    result = self.__provider.make_request('debug_estimateStep', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3d', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C6EE70>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C6E990>\n_stacktrace = <traceback object at 0x00000172CA0EB880>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C6EE70>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep::test_estimate_step_with_deposit_transaction_add",
      "lineno": 205,
      "outcome": "failed",
      "keywords": [
        "test_estimate_step_with_deposit_transaction_add",
        "__wrapped__",
        "patchings",
        "TestEstimateStep",
        "test_estimate_step.py",
        "api_debug",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9F88440>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_debug\\test_estimate_step.py",
            "lineno": 245,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 351,
            "message": "in estimate_step"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9F88440>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9F892E0>\nmethod = 'POST', url = '/api/v3d'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"debug_estimateStep\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc6...710\", \"nid\": \"0x3\", \"value\": \"0x56bc75e2d63100000\", \"nonce\": \"0x3\", \"dataType\": \"deposit\", \"data\": {\"action\": \"add\"}}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3d'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3d', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9F88440>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9F88440>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_debug.test_estimate_step.TestEstimateStep testMethod=test_estimate_step_with_deposit_transaction_add>\n_make_id = <MagicMock name='_make_id' id='1592526410080'>\n\n    def test_estimate_step_with_deposit_transaction_add(self, _make_id):\n        deposit_value = 100_000_000_000_000_000_000\n        deposit_transaction = (DepositTransactionBuilder()\n            .from_(self.setting[\"from\"])\n            .to(\"cx4d6f646441a3f9c9b91019c9b98e3c342cceb114\")\n            .nid(self.setting[\"nid\"])\n            .timestamp(self.setting[\"timestamp\"])\n            .nonce(self.setting[\"nonce\"])\n            .value(deposit_value)\n            .action(\"add\")\n            .build())\n        with requests_mock.Mocker() as m:\n            expected_step = 103_200\n    \n            expected_request = {\n                'jsonrpc': '2.0',\n                'method': 'debug_estimateStep',\n                'id': 1234,\n                'params': {\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'to': \"cx4d6f646441a3f9c9b91019c9b98e3c342cceb114\",\n                    'version': hex(self.version),\n                    'value': hex(deposit_value),\n                    'dataType': 'deposit',\n                    'data': {\n                        'action': 'add'\n                    }\n                }\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': hex(expected_step),\n                'id': 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.estimate_step(deposit_transaction)\n\ntests\\api_debug\\test_estimate_step.py:245: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:351: in estimate_step\n    result = self.__provider.make_request('debug_estimateStep', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3d', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9F88440>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9F892E0>\n_stacktrace = <traceback object at 0x00000172CA27C0C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9F88440>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep::test_estimate_step_with_deposit_transaction_withdraw",
      "lineno": 250,
      "outcome": "failed",
      "keywords": [
        "test_estimate_step_with_deposit_transaction_withdraw",
        "__wrapped__",
        "patchings",
        "TestEstimateStep",
        "test_estimate_step.py",
        "api_debug",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9F76DB0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_debug\\test_estimate_step.py",
            "lineno": 290,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 351,
            "message": "in estimate_step"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9F76DB0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9F76A20>\nmethod = 'POST', url = '/api/v3d'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"debug_estimateStep\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc6...mp\": \"0x2710\", \"nid\": \"0x3\", \"nonce\": \"0x3\", \"dataType\": \"deposit\", \"data\": {\"action\": \"withdraw\", \"amount\": \"0x64\"}}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3d'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3d', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9F76DB0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9F76DB0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_debug.test_estimate_step.TestEstimateStep testMethod=test_estimate_step_with_deposit_transaction_withdraw>\n_make_id = <MagicMock name='_make_id' id='1592526414400'>\n\n    def test_estimate_step_with_deposit_transaction_withdraw(self, _make_id):\n        withdraw_amount = 100\n        deposit_transaction = (DepositTransactionBuilder()\n            .from_(self.setting[\"from\"])\n            .to(\"cx4d6f646441a3f9c9b91019c9b98e3c342cceb114\")\n            .nid(self.setting[\"nid\"])\n            .timestamp(self.setting[\"timestamp\"])\n            .nonce(self.setting[\"nonce\"])\n            .action(\"withdraw\")\n            .amount(withdraw_amount)\n            .build())\n        with requests_mock.Mocker() as m:\n            expected_step = 155_160\n    \n            expected_request = {\n                'jsonrpc': '2.0',\n                'method': 'debug_estimateStep',\n                'id': 1234,\n                'params': {\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'to': \"cx4d6f646441a3f9c9b91019c9b98e3c342cceb114\",\n                    'version': hex(self.version),\n                    'dataType': 'deposit',\n                    'data': {\n                        'action': 'withdraw',\n                        'amount': hex(withdraw_amount)\n                    }\n                }\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': hex(expected_step),\n                'id': 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.estimate_step(deposit_transaction)\n\ntests\\api_debug\\test_estimate_step.py:290: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:351: in estimate_step\n    result = self.__provider.make_request('debug_estimateStep', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3d', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9F76DB0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9F76A20>\n_stacktrace = <traceback object at 0x00000172CA2A4A40>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9F76DB0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep::test_estimate_step_with_message_transaction",
      "lineno": 63,
      "outcome": "failed",
      "keywords": [
        "test_estimate_step_with_message_transaction",
        "__wrapped__",
        "patchings",
        "TestEstimateStep",
        "test_estimate_step.py",
        "api_debug",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FC4680>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_debug\\test_estimate_step.py",
            "lineno": 101,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 351,
            "message": "in estimate_step"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9FC4680>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FC7530>\nmethod = 'POST', url = '/api/v3d'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"debug_estimateStep\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc6...c25b213145e80b7cd\", \"timestamp\": \"0x2710\", \"nid\": \"0x3\", \"nonce\": \"0x3\", \"dataType\": \"message\", \"data\": \"0x74657374\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3d'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3d', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9FC4680>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9FC4680>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_debug.test_estimate_step.TestEstimateStep testMethod=test_estimate_step_with_message_transaction>\n_make_id = <MagicMock name='_make_id' id='1592526661888'>\n\n    def test_estimate_step_with_message_transaction(self, _make_id):\n        # Checks if making an instance of message transaction correctly\n        message_transaction = (MessageTransactionBuilder()\n            .from_(self.setting[\"from\"])\n            .to(self.setting[\"to\"])\n            .step_limit(self.setting[\"step_limit\"])\n            .timestamp(self.setting[\"timestamp\"])\n            .nid(self.setting[\"nid\"])\n            .nonce(self.setting[\"nonce\"])\n            .data(self.setting[\"data\"])\n            .build())\n    \n        with requests_mock.Mocker() as m:\n            expected_step = 102_400\n            expected_request = {\n                'jsonrpc': '2.0',\n                'method': 'debug_estimateStep',\n                'id': 1234,\n                'params': {\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'to': self.setting[\"to\"],\n                    'version': hex(self.version),\n                    'data': self.setting[\"data\"],\n                    'dataType': 'message'\n                }\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': hex(expected_step),\n                'id': 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.estimate_step(message_transaction)\n\ntests\\api_debug\\test_estimate_step.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:351: in estimate_step\n    result = self.__provider.make_request('debug_estimateStep', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3d', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FC4680>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FC7530>\n_stacktrace = <traceback object at 0x00000172CA014200>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FC4680>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_debug/test_estimate_step.py::TestEstimateStep::test_estimate_step_with_send_icx_transaction",
      "lineno": 21,
      "outcome": "failed",
      "keywords": [
        "test_estimate_step_with_send_icx_transaction",
        "__wrapped__",
        "patchings",
        "TestEstimateStep",
        "test_estimate_step.py",
        "api_debug",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FD4740>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_debug\\test_estimate_step.py",
            "lineno": 58,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 351,
            "message": "in estimate_step"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9FD4740>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FD4CE0>\nmethod = 'POST', url = '/api/v3d'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"debug_estimateStep\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc6...f43a808005ffc27c25b213145e80b7cd\", \"timestamp\": \"0x2710\", \"nid\": \"0x3\", \"value\": \"0xde0b6b3a7640000\", \"nonce\": \"0x3\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3d'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3d', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9FD4740>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9FD4740>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_debug.test_estimate_step.TestEstimateStep testMethod=test_estimate_step_with_send_icx_transaction>\n_make_id = <MagicMock name='_make_id' id='1592526334736'>\n\n    def test_estimate_step_with_send_icx_transaction(self, _make_id):\n        icx_transaction = (TransactionBuilder()\n            .from_(self.setting[\"from\"])\n            .to(self.setting[\"to\"])\n            .value(self.setting[\"value\"])\n            .timestamp(self.setting[\"timestamp\"])\n            .step_limit(self.setting[\"step_limit\"])\n            .nid(self.setting[\"nid\"])\n            .nonce(self.setting[\"nonce\"])\n            .version(self.version)\n            .build())\n    \n        with requests_mock.Mocker() as m:\n            expected_step = 100_000\n            expected_request = {\n                'jsonrpc': '2.0',\n                'method': 'debug_estimateStep',\n                'id': 1234,\n                'params': {\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'to': self.setting[\"to\"],\n                    'value': hex(self.setting[\"value\"]),\n                    'version': hex(self.version)\n                }\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': hex(expected_step),\n                'id': 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.estimate_step(icx_transaction)\n\ntests\\api_debug\\test_estimate_step.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:351: in estimate_step\n    result = self.__provider.make_request('debug_estimateStep', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3d', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FD4740>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FD4CE0>\n_stacktrace = <traceback object at 0x00000172C9FF4240>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FD4740>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_debug/test_get_trace.py::TestGetTrace::test_get_trace",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_get_trace",
        "__wrapped__",
        "patchings",
        "TestGetTrace",
        "test_get_trace.py",
        "api_debug",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C6E990>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_debug\\test_get_trace.py",
            "lineno": 45,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 366,
            "message": "in get_trace"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9C6E990>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9F8B410>\nmethod = 'POST', url = '/api/v3d'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"debug_getTrace\", \"id\": 1234, \"params\": {\"txHash\": \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3d'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3d', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9C6E990>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9C6E990>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_debug.test_get_trace.TestGetTrace testMethod=test_get_trace>\n_make_id = <MagicMock name='_make_id' id='1592526407008'>\n\n    def test_get_trace(self, _make_id):\n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'debug_getTrace',\n                'params': {\n                    'txHash': TestGetTrace.TX_HASH\n                }\n            }\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": {\"logs\": [], \"status\": \"0x1\"},\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           self.icon_service.get_trace(TestGetTrace.TX_HASH)\n\ntests\\api_debug\\test_get_trace.py:45: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:366: in get_trace\n    result = self.__provider.make_request('debug_getTrace', params)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3d', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C6E990>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9F8B410>\n_stacktrace = <traceback object at 0x00000172CA0D71C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3d (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C6E990>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_debug/test_get_trace.py::TestGetTrace::test_get_trace_invalid",
      "lineno": 48,
      "outcome": "passed",
      "keywords": [
        "test_get_trace_invalid",
        "__wrapped__",
        "patchings",
        "TestGetTrace",
        "test_get_trace.py",
        "api_debug",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_balance.py::TestFullResponseGetBalance::test_get_balance_full_response",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_get_balance_full_response",
        "__wrapped__",
        "patchings",
        "TestFullResponseGetBalance",
        "test_get_balance.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E29400>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_balance.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 153,
            "message": "in get_balance"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9E29400>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E29E20>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getBalance\", \"id\": 1234, \"params\": {\"address\": \"hxe7af5fcfd8dfc67530a01a0e403882687528dfcb\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9E29400>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9E29400>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_balance.TestFullResponseGetBalance testMethod=test_get_balance_full_response>\n_make_id = <MagicMock name='_make_id' id='1592524964880'>\n\n    def test_get_balance_full_response(self, _make_id):\n    \n        # get_balance with full_response\n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'jsonrpc': '2.0',\n                'method': 'icx_getBalance',\n                'id': 1234,\n                'params': {\n                    'address': self.setting['from']\n                }\n            }\n            response_json = {\n                'jsonrpc': '2.0',\n                'result': hex(self.setting['value']),\n                'id': 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.get_balance(self.setting['from'], full_response=True)\n\ntests\\api_full_response\\test_get_balance.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:153: in get_balance\n    result = self.__provider.make_request('icx_getBalance', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E29400>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E29E20>\n_stacktrace = <traceback object at 0x00000172CA2B4700>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E29400>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_balance.py::TestFullResponseGetBalance::test_get_balance_invalid",
      "lineno": 57,
      "outcome": "passed",
      "keywords": [
        "test_get_balance_invalid",
        "__wrapped__",
        "patchings",
        "TestFullResponseGetBalance",
        "test_get_balance.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_block_by_hash.py::TestFullResponseGetBlockByHash::test_get_block_by_hash_full_response",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_get_block_by_hash_full_response",
        "__wrapped__",
        "patchings",
        "TestFullResponseGetBlockByHash",
        "test_get_block_by_hash.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9745B80>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_block_by_hash.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9745B80>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C98026F0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getBlockByHash\", \"id\": 1234, \"params\": {\"hash\": \"0x3c9d91c2ea42d6b20edd39093a5c4c6f332fa9cb381c29533399365e4c07916d\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9745B80>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9745B80>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_block_by_hash.TestFullResponseGetBlockByHash testMethod=test_get_block_by_hash_full_response>\n_make_id = <MagicMock name='_make_id' id='1592518953920'>\n\n    def test_get_block_by_hash_full_response(self, _make_id):\n        # used valid hash and got and valid block\n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'jsonrpc': '2.0',\n                'method': 'icx_getBlockByHash',\n                'id': 1234,\n                'params': {\n                    'hash': self.block_hash\n                }\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': self.block,\n                'id': 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.get_block(self.block_hash, full_response=True)\n\ntests\\api_full_response\\test_get_block_by_hash.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9745B80>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C98026F0>\n_stacktrace = <traceback object at 0x00000172C9FA61C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9745B80>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_block_by_hash.py::TestFullResponseGetBlockByHash::test_get_block_by_wrong_hash",
      "lineno": 57,
      "outcome": "failed",
      "keywords": [
        "test_get_block_by_wrong_hash",
        "__wrapped__",
        "patchings",
        "TestFullResponseGetBlockByHash",
        "test_get_block_by_hash.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FD68D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_block_by_hash.py",
            "lineno": 73,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9FD68D0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FD53D0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getBlockByHash\", \"id\": 1234, \"params\": {\"hash\": \"0x033f8d96045eb8301fd17cf078c28ae58a3ba329f6ada5cf128ee56dc2af26f7\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9FD68D0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9FD68D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_block_by_hash.TestFullResponseGetBlockByHash testMethod=test_get_block_by_wrong_hash>\n_make_id = <MagicMock name='_make_id' id='1592524964736'>\n\n    def test_get_block_by_wrong_hash(self, _make_id):\n        # used invalid hash and got and invalid block\n    \n        invalid_block_hash = \"0x033f8d96045eb8301fd17cf078c28ae58a3ba329f6ada5cf128ee56dc2af26f7\"\n        with requests_mock.Mocker() as m:\n            response_json = {\n                'jsonrpc': '2.0',\n                'error': {\n                    \"code\": -32602,\n                    \"message\": \"fail wrong block hash\"\n                },\n                'id': 1234\n            }\n    \n            m.post(self.matcher, json=response_json, status_code=400)\n>           result_dict = self.icon_service.get_block(invalid_block_hash, full_response=True)\n\ntests\\api_full_response\\test_get_block_by_hash.py:73: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FD68D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FD53D0>\n_stacktrace = <traceback object at 0x00000172CA1AFA80>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FD68D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_block_by_height.py::TestFullResponseGetBlockByHeight::test_get_block_by_height_full_response",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_get_block_by_height_full_response",
        "__wrapped__",
        "patchings",
        "TestFullResponseGetBlockByHeight",
        "test_get_block_by_height.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C94170>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_block_by_height.py",
            "lineno": 49,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9C94170>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FC6300>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getBlockByHeight\", \"id\": 1234, \"params\": {\"height\": \"0x5f00ff\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9C94170>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9C94170>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_block_by_height.TestFullResponseGetBlockByHeight testMethod=test_get_block_by_height_full_response>\n_make_id = <MagicMock name='_make_id' id='1592526666592'>\n\n    def test_get_block_by_height_full_response(self, _make_id):\n        # used valid hash and got and valid block\n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'jsonrpc': '2.0',\n                'method': 'icx_getBlockByHeight',\n                'id': 1234,\n                'params': {\n                    'height': hex(self.block_height)\n                }\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': self.block,\n                'id': 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.get_block(self.block_height, full_response=True)\n\ntests\\api_full_response\\test_get_block_by_height.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C94170>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FC6300>\n_stacktrace = <traceback object at 0x00000172CA2269C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C94170>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_block_by_height.py::TestFullResponseGetBlockByHeight::test_get_block_by_wrong_height",
      "lineno": 57,
      "outcome": "failed",
      "keywords": [
        "test_get_block_by_wrong_height",
        "__wrapped__",
        "patchings",
        "TestFullResponseGetBlockByHeight",
        "test_get_block_by_height.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C976E0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_block_by_height.py",
            "lineno": 73,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9C976E0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C956A0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getBlockByHeight\", \"id\": 1234, \"params\": {\"height\": \"0x5\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9C976E0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9C976E0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_block_by_height.TestFullResponseGetBlockByHeight testMethod=test_get_block_by_wrong_height>\n_make_id = <MagicMock name='_make_id' id='1592523316336'>\n\n    def test_get_block_by_wrong_height(self, _make_id):\n        # used invalid hash and got and invalid block\n    \n        invalid_block_height = 5\n        with requests_mock.Mocker() as m:\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"error\": {\n                    \"code\": -32602,\n                    \"message\": \"fail wrong block height\"\n                },\n                \"id\": 1234\n            }\n    \n            m.post(self.matcher, json=response_json, status_code=400)\n>           result_dict = self.icon_service.get_block(invalid_block_height, full_response=True)\n\ntests\\api_full_response\\test_get_block_by_height.py:73: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C976E0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C956A0>\n_stacktrace = <traceback object at 0x00000172CA2E0500>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C976E0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_last_block.py::TestFullResponseGetBlockByHeight::test_get_last_block_full_response",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_get_last_block_full_response",
        "__wrapped__",
        "patchings",
        "TestFullResponseGetBlockByHeight",
        "test_get_last_block.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9CC7C80>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_last_block.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9CC7C80>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9CC4740>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getLastBlock\", \"id\": 1234}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9CC7C80>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9CC7C80>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_last_block.TestFullResponseGetBlockByHeight testMethod=test_get_last_block_full_response>\n_make_id = <MagicMock name='_make_id' id='1592526661936'>\n\n    def test_get_last_block_full_response(self, _make_id):\n        # used valid hash and got and valid block\n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'jsonrpc': '2.0',\n                'method': 'icx_getLastBlock',\n                'id': 1234,\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': self.block,\n                'id': 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.get_block(\"latest\", full_response=True)\n\ntests\\api_full_response\\test_get_last_block.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9CC7C80>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9CC4740>\n_stacktrace = <traceback object at 0x00000172C9D1C180>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9CC7C80>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_score_api.py::TestFullResponseGetScoreAPI::test_get_score_api_by_wrong_address",
      "lineno": 50,
      "outcome": "failed",
      "keywords": [
        "test_get_score_api_by_wrong_address",
        "__wrapped__",
        "patchings",
        "TestFullResponseGetScoreAPI",
        "test_get_score_api.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9CB8470>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_score_api.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 178,
            "message": "in get_score_api"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9CB8470>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9CC5A90>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getScoreApi\", \"id\": 1234, \"params\": {\"address\": \"cxb0776ee37f5b45bfaea8cff1d8232fbb6122ec32\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9CB8470>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9CB8470>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_score_api.TestFullResponseGetScoreAPI testMethod=test_get_score_api_by_wrong_address>\n_make_id = <MagicMock name='_make_id' id='1592523508048'>\n\n    def test_get_score_api_by_wrong_address(self, _make_id):\n        with requests_mock.Mocker() as m:\n            wrong_address = \"cxb0776ee37f5b45bfaea8cff1d8232fbb6122ec32\"\n    \n            response_json: dict = {\n                \"jsonrpc\": \"2.0\",\n                \"error\": {\n                    \"code\": -32002,\n                    \"message\": f\"SCORE not found: {wrong_address}\"\n                },\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json, status_code=400)\n>           result_dict = self.icon_service.get_score_api(wrong_address, full_response=True)\n\ntests\\api_full_response\\test_get_score_api.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:178: in get_score_api\n    return self.__provider.make_request('icx_getScoreApi', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9CB8470>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9CC5A90>\n_stacktrace = <traceback object at 0x00000172CA303500>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9CB8470>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_score_api.py::TestFullResponseGetScoreAPI::test_get_score_api_full_response",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_get_score_api_full_response",
        "__wrapped__",
        "patchings",
        "TestFullResponseGetScoreAPI",
        "test_get_score_api.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C9C3B0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_score_api.py",
            "lineno": 43,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 178,
            "message": "in get_score_api"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9C9C3B0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9CBBBF0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getScoreApi\", \"id\": 1234, \"params\": {\"address\": \"cx0000000000000000000000000000000000000001\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9C9C3B0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9C9C3B0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_score_api.TestFullResponseGetScoreAPI testMethod=test_get_score_api_full_response>\n_make_id = <MagicMock name='_make_id' id='1592523458848'>\n\n    def test_get_score_api_full_response(self, _make_id):\n        governance_address = \"cx0000000000000000000000000000000000000001\"\n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getScoreApi',\n                'params': {\n                    'address': governance_address\n                }\n            }\n    \n            m.post(self.matcher, json=response_governance_json)\n>           result_dict = self.icon_service.get_score_api(governance_address, full_response=True)\n\ntests\\api_full_response\\test_get_score_api.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:178: in get_score_api\n    return self.__provider.make_request('icx_getScoreApi', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C9C3B0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9CBBBF0>\n_stacktrace = <traceback object at 0x00000172CA1B64C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C9C3B0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_total_supply.py::TesFullResponseGetTotalSupply::test_get_total_supply",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_get_total_supply",
        "__wrapped__",
        "patchings",
        "TesFullResponseGetTotalSupply",
        "test_get_total_supply.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C9EA50>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_total_supply.py",
            "lineno": 44,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 131,
            "message": "in get_total_supply"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9C9EA50>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C9F320>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getTotalSupply\", \"id\": 1234}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9C9EA50>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9C9EA50>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_total_supply.TesFullResponseGetTotalSupply testMethod=test_get_total_supply>\n_make_id = <MagicMock name='_make_id' id='1592523356304'>\n\n    def test_get_total_supply(self, _make_id):\n        with requests_mock.Mocker() as m:\n            supply = 1_000_000_000\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getTotalSupply',\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': hex(supply),\n                'id': 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.get_total_supply(full_response=True)\n\ntests\\api_full_response\\test_get_total_supply.py:44: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:131: in get_total_supply\n    result = self.__provider.make_request('icx_getTotalSupply', params, full_response=full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C9EA50>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C9F320>\n_stacktrace = <traceback object at 0x00000172CA080400>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C9EA50>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_transaction_by_hash.py::TestFullResponseGetTransactionByHash::test_get_transaction_by_hash",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_get_transaction_by_hash",
        "__wrapped__",
        "patchings",
        "TestFullResponseGetTransactionByHash",
        "test_get_transaction_by_hash.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA16E540>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_transaction_by_hash.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 253,
            "message": "in get_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA16E540>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA16C230>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getTransactionByHash\", \"id\": 1234, \"params\": {\"txHash\": \"0x33db06f38424207daa69c9df153649fd3913c21e162f16f4839c9c3318e44388\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA16E540>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA16E540>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_transaction_by_hash.TestFullResponseGetTransactionByHash testMethod=test_get_transaction_by_hash>\n_make_id = <MagicMock name='_make_id' id='1592528393168'>\n\n    def test_get_transaction_by_hash(self, _make_id):\n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getTransactionByHash',\n                'params': {\n                    'txHash': self.transaction_hash\n                }\n            }\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": self.transaction,\n                \"id\": 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.get_transaction(self.transaction_hash, full_response=True)\n\ntests\\api_full_response\\test_get_transaction_by_hash.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:253: in get_transaction\n    result = self.__provider.make_request('icx_getTransactionByHash', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA16E540>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA16C230>\n_stacktrace = <traceback object at 0x00000172CA3A3D00>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA16E540>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_transaction_by_hash.py::TestFullResponseGetTransactionByHash::test_get_transaction_wrong_hash",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_get_transaction_wrong_hash",
        "__wrapped__",
        "patchings",
        "TestFullResponseGetTransactionByHash",
        "test_get_transaction_by_hash.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA191D90>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_transaction_by_hash.py",
            "lineno": 67,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA191D90>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA193530>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getBlockByHash\", \"id\": 1234, \"params\": {\"hash\": \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA191D90>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA191D90>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_transaction_by_hash.TestFullResponseGetTransactionByHash testMethod=test_get_transaction_wrong_hash>\n_make_id = <MagicMock name='_make_id' id='1592528548160'>\n\n    def test_get_transaction_wrong_hash(self, _make_id):\n        with requests_mock.Mocker() as m:\n            wrong_tx_hash = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"error\": {\n                    \"code\": -32602,\n                    \"message\": \"Invalid params txHash\"\n                },\n                \"id\": 1234\n            }\n    \n            m.post(self.matcher, json=response_json, status_code=400)\n>           result_dict = self.icon_service.get_block(wrong_tx_hash, full_response=True)\n\ntests\\api_full_response\\test_get_transaction_by_hash.py:67: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA191D90>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA193530>\n_stacktrace = <traceback object at 0x00000172CA370400>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA191D90>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_transaction_result.py::TestGetTransactionResult::test_get_transaction_result",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_get_transaction_result",
        "__wrapped__",
        "patchings",
        "TestGetTransactionResult",
        "test_get_transaction_result.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA124320>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_transaction_result.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 211,
            "message": "in get_transaction_result"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA124320>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA192720>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getTransactionResult\", \"id\": 1234, \"params\": {\"txHash\": \"0x33db06f38424207daa69c9df153649fd3913c21e162f16f4839c9c3318e44388\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA124320>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA124320>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_transaction_result.TestGetTransactionResult testMethod=test_get_transaction_result>\n_make_id = <MagicMock name='_make_id' id='1592528391920'>\n\n    def test_get_transaction_result(self, _make_id):\n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getTransactionResult',\n                'params': {\n                    'txHash': self.transaction_hash\n                }\n            }\n    \n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": self.receipt,\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.get_transaction_result(self.transaction_hash, full_response=True)\n\ntests\\api_full_response\\test_get_transaction_result.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:211: in get_transaction_result\n    result = self.__provider.make_request('icx_getTransactionResult', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA124320>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA192720>\n_stacktrace = <traceback object at 0x00000172CA06B240>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA124320>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_get_transaction_result.py::TestGetTransactionResult::test_get_transaction_result_wrong_hash",
      "lineno": 53,
      "outcome": "failed",
      "keywords": [
        "test_get_transaction_result_wrong_hash",
        "__wrapped__",
        "patchings",
        "TestGetTransactionResult",
        "test_get_transaction_result.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C9E870>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_get_transaction_result.py",
            "lineno": 67,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9C9E870>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C9F410>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getBlockByHash\", \"id\": 1234, \"params\": {\"hash\": \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9C9E870>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9C9E870>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_get_transaction_result.TestGetTransactionResult testMethod=test_get_transaction_result_wrong_hash>\n_make_id = <MagicMock name='_make_id' id='1592528546432'>\n\n    def test_get_transaction_result_wrong_hash(self, _make_id):\n        wrong_tx_hash: str = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n        with requests_mock.Mocker() as m:\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"error\": {\n                    \"code\": -32602,\n                    \"message\": \"Invalid params txHash\"\n                },\n                \"id\": 1234\n            }\n    \n            m.post(self.matcher, json=response_json, status_code=400)\n>           result_dict = self.icon_service.get_block(wrong_tx_hash, full_response=True)\n\ntests\\api_full_response\\test_get_transaction_result.py:67: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C9E870>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C9F410>\n_stacktrace = <traceback object at 0x00000172CA235280>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C9E870>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_send_call.py::TesFullResponseSendDeploy::test_send_call",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_send_call",
        "__wrapped__",
        "patchings",
        "TesFullResponseSendDeploy",
        "test_send_call.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9CC7080>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_send_call.py",
            "lineno": 50,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9CC7080>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9CC5B50>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_sendTransaction\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc...e\": \"0x1\"}}, \"signature\": \"r+pO+3lrmRa+xrtHwiWZnhdBXyTxVKv8X6UZOZHfH0tCp5rwmWfV+FoKIJWzsfWcsfCoriBMi9sh8MYxma2A3AA=\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9CC7080>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9CC7080>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_send_call.TesFullResponseSendDeploy testMethod=test_send_call>\n_make_id = <MagicMock name='_make_id' id='1592523460096'>\n\n    def test_send_call(self, _make_id):\n        call_transaction_without_step_limit = CallTransactionBuilder()\\\n            .from_(self.setting[\"from\"])\\\n            .to(self.setting[\"to\"]) \\\n            .nid(self.setting[\"nid\"])\\\n            .step_limit(self.setting[\"step_limit\"])\\\n            .nonce(self.setting[\"nonce\"]) \\\n            .method(self.setting[\"method\"])\\\n            .params(self.setting[\"params_call\"])\\\n            .build()\n        signed_transaction = SignedTransaction(call_transaction_without_step_limit, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            response_json = {\n                'jsonrpc': '2.0',\n                'id': 1234,\n                'result': '0x4bf74e6aeeb43bde5dc8d5b62537a33ac8eb7605ebbdb51b015c1881b45b3aed'\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.send_transaction(signed_transaction, full_response=True)\n\ntests\\api_full_response\\test_send_call.py:50: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9CC7080>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9CC5B50>\n_stacktrace = <traceback object at 0x00000172C9E62900>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9CC7080>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_send_call.py::TesFullResponseSendDeploy::test_send_call_wrong_address",
      "lineno": 56,
      "outcome": "failed",
      "keywords": [
        "test_send_call_wrong_address",
        "__wrapped__",
        "patchings",
        "TesFullResponseSendDeploy",
        "test_send_call.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C97C41D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_send_call.py",
            "lineno": 81,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C97C41D0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C95340>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_sendTransaction\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc...e\": \"0x1\"}}, \"signature\": \"KoFx5tKBvBDTzxT4p4zKdS5LBxCkhQN+WSXrGSYBYzQdFXBJ2tYDyCEiIhBzK6PyLhjE60h9qspsDkveVyco2wA=\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C97C41D0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C97C41D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_send_call.TesFullResponseSendDeploy testMethod=test_send_call_wrong_address>\n_make_id = <MagicMock name='_make_id' id='1592523511600'>\n\n    def test_send_call_wrong_address(self, _make_id):\n        wrong_address = \"hx5bfdb090f43a808005ffc27c25b213145e8\"\n        call_transaction_without_step_limit = CallTransactionBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(wrong_address) \\\n            .nid(self.setting[\"nid\"]) \\\n            .step_limit(self.setting[\"step_limit\"]) \\\n            .nonce(self.setting[\"nonce\"]) \\\n            .method(self.setting[\"method\"]) \\\n            .params(self.setting[\"params_call\"]) \\\n            .build()\n        signed_transaction = SignedTransaction(call_transaction_without_step_limit, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            response_json = {\n                'jsonrpc': '2.0',\n                'id': 1234,\n                'error': {\n                    'code': -32601,\n                    'message': 'Method not found'\n                }\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.send_transaction(signed_transaction, full_response=True)\n\ntests\\api_full_response\\test_send_call.py:81: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C97C41D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C95340>\n_stacktrace = <traceback object at 0x00000172CA054200>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C97C41D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_send_deploy.py::TesFullResponseSendDeploy::test_deploy_wrong_address",
      "lineno": 58,
      "outcome": "failed",
      "keywords": [
        "test_deploy_wrong_address",
        "__wrapped__",
        "patchings",
        "TesFullResponseSendDeploy",
        "test_send_deploy.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C16750>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_send_deploy.py",
            "lineno": 84,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9C16750>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C6E9F0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_sendTransaction\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc... \"0x2710\"}}, \"signature\": \"L5dxqt7yYUv6q0LgqQSfTUuKp6TWh7vI1hnzI4P3NeIM4iVDdjC6EBRf3IHPK1Yn7swPTdgl5Dvc2zeHrRjyfAE=\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9C16750>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9C16750>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_send_deploy.TesFullResponseSendDeploy testMethod=test_deploy_wrong_address>\n_make_id = <MagicMock name='_make_id' id='1592526405952'>\n\n    def test_deploy_wrong_address(self, _make_id):\n        wrong_address = \"hx5bfdb090f43a808005ffc27c25b213145e8\"\n        deploy_transaction = DeployTransactionBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(wrong_address) \\\n            .step_limit(self.setting[\"step_limit\"]) \\\n            .nid(self.setting[\"nid\"]) \\\n            .nonce(self.setting[\"nonce\"]) \\\n            .content_type(self.setting[\"content_type\"]) \\\n            .content(self.setting[\"content_install\"]) \\\n            .params(self.setting[\"params_install\"]) \\\n            .build()\n        signed_transaction = SignedTransaction(deploy_transaction, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            response_json = {\n                'jsonrpc': '2.0',\n                'id': 1234,\n                'error': {\n                    \"code\": -32600,\n                    \"message\": f'Not a system SCORE {wrong_address}'\n                }\n            }\n    \n            m.post(self.matcher, json=response_json, status_code=400)\n>           result_dict = self.icon_service.send_transaction(signed_transaction, full_response=True)\n\ntests\\api_full_response\\test_send_deploy.py:84: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C16750>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9C6E9F0>\n_stacktrace = <traceback object at 0x00000172CA241A80>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C16750>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_send_deploy.py::TesFullResponseSendDeploy::test_send_deploy",
      "lineno": 30,
      "outcome": "failed",
      "keywords": [
        "test_send_deploy",
        "__wrapped__",
        "patchings",
        "TesFullResponseSendDeploy",
        "test_send_deploy.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E2B5F0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_send_deploy.py",
            "lineno": 52,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9E2B5F0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E2A240>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_sendTransaction\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc... \"0x2710\"}}, \"signature\": \"oBMUqwpYizlRlfQxNCjF5Rt7skzDRZzq0I2xyNF0xTkTu+ZIyXE3FHvObMYuoMWZpPqWZEk6fAR75uh2XUAmxgA=\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9E2B5F0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9E2B5F0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_send_deploy.TesFullResponseSendDeploy testMethod=test_send_deploy>\n_make_id = <MagicMock name='_make_id' id='1592523322528'>\n\n    def test_send_deploy(self, _make_id):\n        deploy_transaction = DeployTransactionBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(self.setting[\"to_install\"]) \\\n            .step_limit(self.setting[\"step_limit\"]) \\\n            .nid(self.setting[\"nid\"]) \\\n            .nonce(self.setting[\"nonce\"]) \\\n            .content_type(self.setting[\"content_type\"]) \\\n            .content(self.setting[\"content_install\"]) \\\n            .params(self.setting[\"params_install\"]) \\\n            .build()\n        signed_transaction = SignedTransaction(deploy_transaction, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1234,\n                \"result\": \"0x4bf74e6aeeb43bde5dc8d5b62537a33ac8eb7605ebbdb51b015c1881b45b3aed\"\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.send_transaction(signed_transaction, full_response=True)\n\ntests\\api_full_response\\test_send_deploy.py:52: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E2B5F0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E2A240>\n_stacktrace = <traceback object at 0x00000172CA32B440>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E2B5F0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_send_deposit.py::TesFullResponseSendDeposit::test_add_deposit",
      "lineno": 30,
      "outcome": "failed",
      "keywords": [
        "test_add_deposit",
        "__wrapped__",
        "patchings",
        "TesFullResponseSendDeposit",
        "test_send_deposit.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FD49B0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_send_deposit.py",
            "lineno": 75,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9FD49B0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FD4F20>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_sendTransaction\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc...on\": \"add\"}, \"signature\": \"6btEHlOoPMbF315mwx+sdULfWjV0Cbc6rr5H3EzXfhR1zii8vNi0JPmo1F44fXIPjzAI0dx6deS1miHGHm/6CAA=\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9FD49B0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9FD49B0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_send_deposit.TesFullResponseSendDeposit testMethod=test_add_deposit>\n_make_id = <MagicMock name='_make_id' id='1592524975248'>\n\n    def test_add_deposit(self, _make_id):\n        # transaction instance for add action\n        action = \"add\"\n        deposit_transaction = DepositTransactionBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(self.setting[\"to\"]) \\\n            .value(self.setting[\"value\"]) \\\n            .timestamp(self.setting[\"timestamp\"]) \\\n            .step_limit(self.setting[\"step_limit\"]) \\\n            .nid(self.setting[\"nid\"]) \\\n            .nonce(self.setting[\"nonce\"]) \\\n            .action(action) \\\n            .build()\n        signed_transaction = SignedTransaction(deposit_transaction, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            tx_hash = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_sendTransaction',\n                'params': {\n                    'data': {\n                        'action': action\n                    },\n                    'dataType': 'deposit',\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'signature': signed_transaction.signed_transaction_dict[\"signature\"],\n                    'stepLimit': hex(self.setting[\"step_limit\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'to': self.setting[\"to\"],\n                    'value': hex(self.setting[\"value\"]),\n                    'version': hex(3)\n                }\n            }\n    \n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": tx_hash,\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.send_transaction(signed_transaction, full_response=True)\n\ntests\\api_full_response\\test_send_deposit.py:75: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FD49B0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FD4F20>\n_stacktrace = <traceback object at 0x00000172C9C44E00>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FD49B0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_send_message.py::TestFullResponseSendMessage::test_send_message",
      "lineno": 31,
      "outcome": "failed",
      "keywords": [
        "test_send_message",
        "__wrapped__",
        "patchings",
        "TestFullResponseSendMessage",
        "test_send_message.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA125190>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_send_message.py",
            "lineno": 74,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA125190>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FD5DF0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_sendTransaction\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc...0x74657374\", \"signature\": \"QoiktuTfE8Lus7YcOchVYS2feGTgtMW8nwwDYVHhak5KifgI3jXW8hit2z992/rrJ4hfrFf/RhNwM7YZss6JeQA=\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA125190>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA125190>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_send_message.TestFullResponseSendMessage testMethod=test_send_message>\n_make_id = <MagicMock name='_make_id' id='1592526335504'>\n\n    def test_send_message(self, _make_id):\n        message_transaction = MessageTransactionBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(self.setting[\"to\"]) \\\n            .step_limit(self.setting[\"step_limit\"]) \\\n            .nid(self.setting[\"nid\"]) \\\n            .nonce(self.setting[\"nonce\"]) \\\n            .data(self.setting[\"data\"]) \\\n            .timestamp(self.setting[\"timestamp\"]) \\\n            .build()\n    \n        tx_dict = SignedTransaction.convert_tx_to_jsonrpc_request(message_transaction)\n        self.assertTrue(is_message_transaction(tx_dict))\n        signed_transaction = SignedTransaction(message_transaction, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            tx_hash = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_sendTransaction',\n                'params': {\n                    'data': self.setting[\"data\"],\n                    'dataType': 'message',\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'signature': signed_transaction.signed_transaction_dict[\"signature\"],\n                    'stepLimit': hex(self.setting[\"step_limit\"]),\n                    'to': self.setting[\"to\"],\n                    'version': hex(3)\n                }\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': tx_hash,\n                'id': 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.send_transaction(signed_transaction, full_response=True)\n\ntests\\api_full_response\\test_send_message.py:74: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA125190>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FD5DF0>\n_stacktrace = <traceback object at 0x00000172C9E2D480>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA125190>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_full_response/test_send_transfer.py::TestFullResponseSendTransfer::test_send_transfer",
      "lineno": 31,
      "outcome": "failed",
      "keywords": [
        "test_send_transfer",
        "__wrapped__",
        "patchings",
        "TestFullResponseSendTransfer",
        "test_send_transfer.py",
        "api_full_response",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D534A0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_full_response\\test_send_transfer.py",
            "lineno": 54,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9D534A0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA1279E0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_sendTransaction\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc...nce\": \"0x3\", \"signature\": \"qBRjUUR28g7QUcixD0YKSgV6kDrJgyNuoBYgfLeaMQlWzyKunRLwox95wDXpRz1tn53NdFt9EtNwl6wnwKo2wgE=\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9D534A0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9D534A0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_full_response.test_send_transfer.TestFullResponseSendTransfer testMethod=test_send_transfer>\n_make_id = <MagicMock name='_make_id' id='1592528103296'>\n\n    def test_send_transfer(self, _make_id):\n        icx_transaction = TransactionBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(self.setting[\"to\"]) \\\n            .value(self.setting[\"value\"]) \\\n            .step_limit(self.setting[\"step_limit\"]) \\\n            .nid(3) \\\n            .nonce(self.setting[\"nonce\"]) \\\n            .version(3) \\\n            .timestamp(self.setting[\"timestamp\"]) \\\n            .build()\n    \n        signed_transaction = SignedTransaction(icx_transaction, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            response_json: dict = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\",\n                \"id\": 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result_dict = self.icon_service.send_transaction(signed_transaction, full_response=True)\n\ntests\\api_full_response\\test_send_transfer.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D534A0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA1279E0>\n_stacktrace = <traceback object at 0x00000172C9C46D00>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D534A0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_btp2.py::TestBTP2::test_get_btp_header",
      "lineno": 93,
      "outcome": "failed",
      "keywords": [
        "test_get_btp_header",
        "__wrapped__",
        "patchings",
        "TestBTP2",
        "test_btp2.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D517F0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_btp2.py",
            "lineno": 101,
            "message": ""
          },
          {
            "path": "tests\\api_get\\test_btp2.py",
            "lineno": 61,
            "message": "in run_test"
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 499,
            "message": "in get_btp_header"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9D517F0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D52690>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"btp_getHeader\", \"id\": 1234, \"params\": {\"height\": \"0x64\", \"networkID\": \"0x1\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9D517F0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9D517F0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_btp2.TestBTP2 testMethod=test_get_btp_header>\n_make_id = <MagicMock name='_make_id' id='1592524090992'>\n\n    def test_get_btp_header(self, _make_id):\n        func = self.icon_service.get_btp_header\n        method = \"btp_getHeader\"\n        params = {\n            'height': self.HEIGHT,\n            'network_id': self.ID,\n        }\n>       self.run_test(_make_id, func, method, params)\n\ntests\\api_get\\test_btp2.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\api_get\\test_btp2.py:61: in run_test\n    func(**params)\niconsdk\\icon_service.py:499: in get_btp_header\n    return self.__provider.make_request('btp_getHeader', params)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D517F0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D52690>\n_stacktrace = <traceback object at 0x00000172C9FF36C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D517F0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_btp2.py::TestBTP2::test_get_btp_messages",
      "lineno": 84,
      "outcome": "failed",
      "keywords": [
        "test_get_btp_messages",
        "__wrapped__",
        "patchings",
        "TestBTP2",
        "test_btp2.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D77B60>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_btp2.py",
            "lineno": 92,
            "message": ""
          },
          {
            "path": "tests\\api_get\\test_btp2.py",
            "lineno": 61,
            "message": "in run_test"
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 486,
            "message": "in get_btp_messages"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9D77B60>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D745F0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"btp_getMessages\", \"id\": 1234, \"params\": {\"height\": \"0x64\", \"networkID\": \"0x1\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9D77B60>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9D77B60>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_btp2.TestBTP2 testMethod=test_get_btp_messages>\n_make_id = <MagicMock name='_make_id' id='1592524236768'>\n\n    def test_get_btp_messages(self, _make_id):\n        func = self.icon_service.get_btp_messages\n        method = \"btp_getMessages\"\n        params = {\n            'height': self.HEIGHT,\n            'network_id': self.ID,\n        }\n>       self.run_test(_make_id, func, method, params)\n\ntests\\api_get\\test_btp2.py:92: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\api_get\\test_btp2.py:61: in run_test\n    func(**params)\niconsdk\\icon_service.py:486: in get_btp_messages\n    return self.__provider.make_request('btp_getMessages', params)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D77B60>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D745F0>\n_stacktrace = <traceback object at 0x00000172CA474100>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D77B60>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_btp2.py::TestBTP2::test_get_btp_network_info",
      "lineno": 66,
      "outcome": "failed",
      "keywords": [
        "test_get_btp_network_info",
        "__wrapped__",
        "patchings",
        "TestBTP2",
        "test_btp2.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D85B50>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_btp2.py",
            "lineno": 71,
            "message": ""
          },
          {
            "path": "tests\\api_get\\test_btp2.py",
            "lineno": 61,
            "message": "in run_test"
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 458,
            "message": "in get_btp_network_info"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9D85B50>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D843B0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"btp_getNetworkInfo\", \"id\": 1234, \"params\": {\"id\": \"0x1\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9D85B50>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9D85B50>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_btp2.TestBTP2 testMethod=test_get_btp_network_info>\n_make_id = <MagicMock name='_make_id' id='1592524095072'>\n\n    def test_get_btp_network_info(self, _make_id):\n        func = self.icon_service.get_btp_network_info\n        method = \"btp_getNetworkInfo\"\n        params = {'id': self.ID}\n>       self.run_test(_make_id, func, method, params)\n\ntests\\api_get\\test_btp2.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\api_get\\test_btp2.py:61: in run_test\n    func(**params)\niconsdk\\icon_service.py:458: in get_btp_network_info\n    return self.__provider.make_request('btp_getNetworkInfo', params)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D85B50>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D843B0>\n_stacktrace = <traceback object at 0x00000172CA37A940>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D85B50>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_btp2.py::TestBTP2::test_get_btp_network_type_info",
      "lineno": 75,
      "outcome": "failed",
      "keywords": [
        "test_get_btp_network_type_info",
        "__wrapped__",
        "patchings",
        "TestBTP2",
        "test_btp2.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D00A40>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_btp2.py",
            "lineno": 80,
            "message": ""
          },
          {
            "path": "tests\\api_get\\test_btp2.py",
            "lineno": 61,
            "message": "in run_test"
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 473,
            "message": "in get_btp_network_type_info"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9D00A40>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D000B0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"btp_getNetworkTypeInfo\", \"id\": 1234, \"params\": {\"id\": \"0x1\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9D00A40>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9D00A40>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_btp2.TestBTP2 testMethod=test_get_btp_network_type_info>\n_make_id = <MagicMock name='_make_id' id='1592524298032'>\n\n    def test_get_btp_network_type_info(self, _make_id):\n        func = self.icon_service.get_btp_network_type_info\n        method = \"btp_getNetworkTypeInfo\"\n        params = {'id': self.ID}\n>       self.run_test(_make_id, func, method, params)\n\ntests\\api_get\\test_btp2.py:80: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\api_get\\test_btp2.py:61: in run_test\n    func(**params)\niconsdk\\icon_service.py:473: in get_btp_network_type_info\n    return self.__provider.make_request('btp_getNetworkTypeInfo', params)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D00A40>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D000B0>\n_stacktrace = <traceback object at 0x00000172CA4A0100>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D00A40>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_btp2.py::TestBTP2::test_get_btp_proof",
      "lineno": 102,
      "outcome": "failed",
      "keywords": [
        "test_get_btp_proof",
        "__wrapped__",
        "patchings",
        "TestBTP2",
        "test_btp2.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D24260>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_btp2.py",
            "lineno": 110,
            "message": ""
          },
          {
            "path": "tests\\api_get\\test_btp2.py",
            "lineno": 61,
            "message": "in run_test"
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 512,
            "message": "in get_btp_proof"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9D24260>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D03020>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"btp_getProof\", \"id\": 1234, \"params\": {\"height\": \"0x64\", \"networkID\": \"0x1\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9D24260>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9D24260>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_btp2.TestBTP2 testMethod=test_get_btp_proof>\n_make_id = <MagicMock name='_make_id' id='1592523757696'>\n\n    def test_get_btp_proof(self, _make_id):\n        func = self.icon_service.get_btp_proof\n        method = \"btp_getProof\"\n        params = {\n            'height': self.HEIGHT,\n            'network_id': self.ID,\n        }\n>       self.run_test(_make_id, func, method, params)\n\ntests\\api_get\\test_btp2.py:110: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\api_get\\test_btp2.py:61: in run_test\n    func(**params)\niconsdk\\icon_service.py:512: in get_btp_proof\n    return self.__provider.make_request('btp_getProof', params)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D24260>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D03020>\n_stacktrace = <traceback object at 0x00000172CA4C03C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D24260>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_btp2.py::TestBTP2::test_get_btp_source_information",
      "lineno": 111,
      "outcome": "failed",
      "keywords": [
        "test_get_btp_source_information",
        "__wrapped__",
        "patchings",
        "TestBTP2",
        "test_btp2.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D76150>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_btp2.py",
            "lineno": 116,
            "message": ""
          },
          {
            "path": "tests\\api_get\\test_btp2.py",
            "lineno": 63,
            "message": "in run_test"
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 522,
            "message": "in get_btp_source_information"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9D76150>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D87B60>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"btp_getSourceInformation\", \"id\": 1234}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9D76150>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9D76150>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_btp2.TestBTP2 testMethod=test_get_btp_source_information>\n_make_id = <MagicMock name='_make_id' id='1592524293136'>\n\n    def test_get_btp_source_information(self, _make_id):\n        func = self.icon_service.get_btp_source_information\n        method = \"btp_getSourceInformation\"\n        params = None\n>       self.run_test(_make_id, func, method, params)\n\ntests\\api_get\\test_btp2.py:116: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\api_get\\test_btp2.py:63: in run_test\n    func()\niconsdk\\icon_service.py:522: in get_btp_source_information\n    return self.__provider.make_request('btp_getSourceInformation')\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D76150>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D87B60>\n_stacktrace = <traceback object at 0x00000172C9F8D900>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D76150>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_balance.py::TestGetBalance::test_get_balance_from_wallet",
      "lineno": 27,
      "outcome": "failed",
      "keywords": [
        "test_get_balance_from_wallet",
        "__wrapped__",
        "patchings",
        "TestGetBalance",
        "test_get_balance.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9F76570>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_balance.py",
            "lineno": 46,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 153,
            "message": "in get_balance"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9F76570>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D52CF0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getBalance\", \"id\": 1234, \"params\": {\"address\": \"hxe7af5fcfd8dfc67530a01a0e403882687528dfcb\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9F76570>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9F76570>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_balance.TestGetBalance testMethod=test_get_balance_from_wallet>\n_make_id = <MagicMock name='_make_id' id='1592524239408'>\n\n    def test_get_balance_from_wallet(self, _make_id):\n        # case 0: get balance from wallet or score successfully.\n        with requests_mock.Mocker() as m:\n            expected_result = 0\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getBalance',\n                'params': {\n                    'address': self.setting[\"from\"]\n                }\n            }\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": hex(0),\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.get_balance(self.setting[\"from\"])\n\ntests\\api_get\\test_get_balance.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:153: in get_balance\n    result = self.__provider.make_request('icx_getBalance', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9F76570>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D52CF0>\n_stacktrace = <traceback object at 0x00000172C9FB9980>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9F76570>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_balance.py::TestGetBalance::test_get_balance_invalid",
      "lineno": 55,
      "outcome": "passed",
      "keywords": [
        "test_get_balance_invalid",
        "__wrapped__",
        "patchings",
        "TestGetBalance",
        "test_get_balance.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_block_by_hash.py::TestGetBlockByHash::test_get_block_by_hash",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_get_block_by_hash",
        "__wrapped__",
        "patchings",
        "TestGetBlockByHash",
        "test_get_block_by_hash.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C942C0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_block_by_hash.py",
            "lineno": 71,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9C942C0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E2A8D0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getBlockByHash\", \"id\": 1234, \"params\": {\"hash\": \"0x033f8d96045eb8301fd17cf078c28ae58a3ba329f6ada5cf128ee56dc2af26f7\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9C942C0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9C942C0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_block_by_hash.TestGetBlockByHash testMethod=test_get_block_by_hash>\n_make_id = <MagicMock name='_make_id' id='1592526720944'>\n\n    def test_get_block_by_hash(self, _make_id):\n        with requests_mock.Mocker() as m:\n            block_hash = \"0x033f8d96045eb8301fd17cf078c28ae58a3ba329f6ada5cf128ee56dc2af26f7\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getBlockByHash',\n                'params': {\n                    'hash': block_hash\n                }\n            }\n    \n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": {\n                    \"version\": \"0.1a\",\n                    \"prev_block_hash\": \"cf43b3fd45981431a0e64f79d07bfcf703e064b73b802c5f32834eec72142190\",\n                    \"merkle_tree_root_hash\": \"375540830d475a73b704cf8dee9fa9eba2798f9d2af1fa55a85482e48daefd3b\",\n                    \"time_stamp\": 1516819217223222,\n                    \"confirmed_transaction_list\": [\n                        {\n                            \"from\": \"hx54f7853dc6481b670caf69c5a27c7c8fe5be8269\",\n                            \"to\": \"hx49a23bd156932485471f582897bf1bec5f875751\",\n                            \"value\": \"0x56bc75e2d63100000\",\n                            \"fee\": \"0x2386f26fc10000\",\n                            \"nonce\": \"0x1\",\n                            \"tx_hash\": \"375540830d475a73b704cf8dee9fa9eba2798f9d2af1fa55a85482e48daefd3b\",\n                            \"signature\": \"bjarKeF3izGy469dpSciP3TT9caBQVYgHdaNgjY+8wJTOVSFm4o/ODXycFOdXUJcIwqvcE9If8x6Zmgt//XmkQE=\",\n                            \"method\": \"icx_sendTransaction\"\n                        }\n                    ],\n                    \"block_hash\": \"3add53134014e940f6f6010173781c4d8bd677d9931a697f962483e04a685e5c\",\n                    \"height\": 1,\n                    \"peer_id\": \"hx7e1a1ece096ef3fa44ac9692394c2e11d0017e4a\",\n                    \"signature\": \"liAIa7aPYvBRdZAdBz6zt2Gc9vVo/4+gkDz5uscS8Mw+B5gkp6zQeHhD5sNpyWcIsq5c9OxwOCUaBp0vu8eAgwE=\",\n                    \"next_leader\": \"\"\n                },\n                \"id\": 1234\n            }\n    \n            # case 0: when hash value of latest block is valid\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.get_block(block_hash)\n\ntests\\api_get\\test_get_block_by_hash.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C942C0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E2A8D0>\n_stacktrace = <traceback object at 0x00000172CA099040>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C942C0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_block_by_hash.py::TestGetBlockByHash::test_get_block_by_wrong_hash",
      "lineno": 79,
      "outcome": "failed",
      "keywords": [
        "test_get_block_by_wrong_hash",
        "__wrapped__",
        "patchings",
        "TestGetBlockByHash",
        "test_get_block_by_hash.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C6EDB0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_block_by_hash.py",
            "lineno": 101,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9C6EDB0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9C6EDB0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9C6EDB0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_block_by_hash.TestGetBlockByHash testMethod=test_get_block_by_wrong_hash>\n_make_id = <MagicMock name='_make_id' id='1592524080144'>\n\n    def test_get_block_by_wrong_hash(self, _make_id):\n        with requests_mock.Mocker() as m:\n            invalid_block_hash = \"0x033f8d96045eb8301fd17cf078c28ae58a3ba329f6ada5cf128ee56dc2af26f7\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getBlockByHash',\n                'params': {\n                    'hash': invalid_block_hash\n                }\n            }\n    \n            response_json = {\n                'id': 1234,\n                \"jsonrpc\": \"2.0\",\n                \"error\": {\n                     \"code\": -32602,\n                     \"message\": \"fail wrong block hash\"\n                 },\n            }\n            m.post(self.matcher, json=response_json, status_code=400)\n>           self.assertRaises(JSONRPCException, self.icon_service.get_block, invalid_block_hash)\n\ntests\\api_get\\test_get_block_by_hash.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C6EDB0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_block_by_height.py::TestGetBlockByHeight::test_get_block_by_height",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_get_block_by_height",
        "__wrapped__",
        "patchings",
        "TestGetBlockByHeight",
        "test_get_block_by_height.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9CBB740>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_block_by_height.py",
            "lineno": 70,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9CBB740>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9CBBD70>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getBlockByHeight\", \"id\": 1234, \"params\": {\"height\": \"0x1\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9CBB740>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9CBB740>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_block_by_height.TestGetBlockByHeight testMethod=test_get_block_by_height>\n_make_id = <MagicMock name='_make_id' id='1592517654000'>\n\n    def test_get_block_by_height(self, _make_id):\n        with requests_mock.Mocker() as m:\n            height = 1\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getBlockByHeight',\n                'params': {\n                    'height': hex(height)\n                }\n            }\n    \n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": {\n                    \"version\": \"0.1a\",\n                    \"prev_block_hash\": \"cf43b3fd45981431a0e64f79d07bfcf703e064b73b802c5f32834eec72142190\",\n                    \"merkle_tree_root_hash\": \"375540830d475a73b704cf8dee9fa9eba2798f9d2af1fa55a85482e48daefd3b\",\n                    \"time_stamp\": 1516819217223222,\n                    \"confirmed_transaction_list\": [\n                        {\n                            \"from\": \"hx54f7853dc6481b670caf69c5a27c7c8fe5be8269\",\n                            \"to\": \"hx49a23bd156932485471f582897bf1bec5f875751\",\n                            \"value\": \"0x56bc75e2d63100000\",\n                            \"fee\": \"0x2386f26fc10000\",\n                            \"nonce\": \"0x1\",\n                            \"tx_hash\": \"375540830d475a73b704cf8dee9fa9eba2798f9d2af1fa55a85482e48daefd3b\",\n                            \"signature\": \"bjarKeF3izGy469dpSciP3TT9caBQVYgHdaNgjY+8wJTOVSFm4o/ODXycFOdXUJcIwqvcE9If8x6Zmgt//XmkQE=\",\n                            \"method\": \"icx_sendTransaction\"\n                        }\n                    ],\n                    \"block_hash\": \"3add53134014e940f6f6010173781c4d8bd677d9931a697f962483e04a685e5c\",\n                    \"height\": 1,\n                    \"peer_id\": \"hx7e1a1ece096ef3fa44ac9692394c2e11d0017e4a\",\n                    \"signature\": \"liAIa7aPYvBRdZAdBz6zt2Gc9vVo/4+gkDz5uscS8Mw+B5gkp6zQeHhD5sNpyWcIsq5c9OxwOCUaBp0vu8eAgwE=\",\n                    \"next_leader\": \"\"\n                },\n                \"id\": 1234\n            }\n            # case 0: when height is 0\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.get_block(height)\n\ntests\\api_get\\test_get_block_by_height.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9CBB740>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9CBBD70>\n_stacktrace = <traceback object at 0x00000172CA481580>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9CBB740>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_block_by_height.py::TestGetBlockByHeight::test_get_block_by_height_invalid",
      "lineno": 74,
      "outcome": "passed",
      "keywords": [
        "test_get_block_by_height_invalid",
        "__wrapped__",
        "patchings",
        "TestGetBlockByHeight",
        "test_get_block_by_height.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_block_by_height.py::TestGetBlockByHeight::test_get_block_by_wrong_height",
      "lineno": 79,
      "outcome": "failed",
      "keywords": [
        "test_get_block_by_wrong_height",
        "__wrapped__",
        "patchings",
        "TestGetBlockByHeight",
        "test_get_block_by_height.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA125400>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_block_by_height.py",
            "lineno": 100,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA125400>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA125400>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA125400>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_block_by_height.TestGetBlockByHeight testMethod=test_get_block_by_wrong_height>\n_make_id = <MagicMock name='_make_id' id='1592528543072'>\n\n    def test_get_block_by_wrong_height(self, _make_id):\n        with requests_mock.Mocker() as m:\n            wrong_height = 5\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getBlockByHeight',\n                'params': {\n                    'height': hex(wrong_height)\n                }\n            }\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"error\": {\n                    \"code\": -32602,\n                    \"message\": \"fail wrong block hash\"\n                },\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json, status_code=400)\n>           self.assertRaises(JSONRPCException, self.icon_service.get_block, wrong_height)\n\ntests\\api_get\\test_get_block_by_height.py:100: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA125400>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_last_block.py::TestGetLastBlock::test_get_block_by_height",
      "lineno": 27,
      "outcome": "failed",
      "keywords": [
        "test_get_block_by_height",
        "__wrapped__",
        "patchings",
        "TestGetLastBlock",
        "test_get_last_block.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA127290>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_last_block.py",
            "lineno": 64,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA127290>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA125850>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getLastBlock\", \"id\": 1234}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA127290>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA127290>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_last_block.TestGetLastBlock testMethod=test_get_block_by_height>\n_make_id = <MagicMock name='_make_id' id='1592528391200'>\n\n    def test_get_block_by_height(self, _make_id):\n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getLastBlock',\n            }\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": {\n                    \"version\": \"0.1a\",\n                    \"prev_block_hash\": \"cf43b3fd45981431a0e64f79d07bfcf703e064b73b802c5f32834eec72142190\",\n                    \"merkle_tree_root_hash\": \"375540830d475a73b704cf8dee9fa9eba2798f9d2af1fa55a85482e48daefd3b\",\n                    \"time_stamp\": 1516819217223222,\n                    \"confirmed_transaction_list\": [\n                        {\n                            \"from\": \"hx54f7853dc6481b670caf69c5a27c7c8fe5be8269\",\n                            \"to\": \"hx49a23bd156932485471f582897bf1bec5f875751\",\n                            \"value\": \"0x56bc75e2d63100000\",\n                            \"fee\": \"0x2386f26fc10000\",\n                            \"nonce\": \"0x1\",\n                            \"tx_hash\": \"375540830d475a73b704cf8dee9fa9eba2798f9d2af1fa55a85482e48daefd3b\",\n                            \"signature\": \"bjarKeF3izGy469dpSciP3TT9caBQVYgHdaNgjY+8wJTOVSFm4o/ODXycFOdXUJcIwqvcE9If8x6Zmgt//XmkQE=\",\n                            \"method\": \"icx_sendTransaction\"\n                        }\n                    ],\n                    \"block_hash\": \"3add53134014e940f6f6010173781c4d8bd677d9931a697f962483e04a685e5c\",\n                    \"height\": 1,\n                    \"peer_id\": \"hx7e1a1ece096ef3fa44ac9692394c2e11d0017e4a\",\n                    \"signature\": \"liAIa7aPYvBRdZAdBz6zt2Gc9vVo/4+gkDz5uscS8Mw+B5gkp6zQeHhD5sNpyWcIsq5c9OxwOCUaBp0vu8eAgwE=\",\n                    \"next_leader\": \"\"\n                },\n                \"id\": 1234\n            }\n            # case 0: when param is `latest`\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.get_block(\"latest\")\n\ntests\\api_get\\test_get_last_block.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA127290>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA125850>\n_stacktrace = <traceback object at 0x00000172CA4F15C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA127290>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_last_block.py::TestGetLastBlock::test_get_last_block_invalid",
      "lineno": 68,
      "outcome": "passed",
      "keywords": [
        "test_get_last_block_invalid",
        "__wrapped__",
        "patchings",
        "TestGetLastBlock",
        "test_get_last_block.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_score_api.py::TestGetScoreApi::test_get_score_api",
      "lineno": 28,
      "outcome": "failed",
      "keywords": [
        "test_get_score_api",
        "__wrapped__",
        "patchings",
        "TestGetScoreApi",
        "test_get_score_api.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D27470>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_score_api.py",
            "lineno": 43,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 178,
            "message": "in get_score_api"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9D27470>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D25220>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getScoreApi\", \"id\": 1234, \"params\": {\"address\": \"cx0000000000000000000000000000000000000001\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9D27470>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9D27470>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_score_api.TestGetScoreApi testMethod=test_get_score_api>\n_make_id = <MagicMock name='_make_id' id='1592523909664'>\n\n    def test_get_score_api(self, _make_id):\n        with requests_mock.Mocker() as m:\n            governance_address = \"cx0000000000000000000000000000000000000001\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getScoreApi',\n                'params': {\n                    'address': governance_address\n                }\n            }\n    \n            m.post(self.matcher, json=response_governance_json)\n            # case 0: when getting score apis successfully\n>           result = self.icon_service.get_score_api(governance_address)\n\ntests\\api_get\\test_get_score_api.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:178: in get_score_api\n    return self.__provider.make_request('icx_getScoreApi', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D27470>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D25220>\n_stacktrace = <traceback object at 0x00000172C9D8C9C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D27470>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_score_api.py::TestGetScoreApi::test_get_score_api_by_wrong_address",
      "lineno": 61,
      "outcome": "failed",
      "keywords": [
        "test_get_score_api_by_wrong_address",
        "__wrapped__",
        "patchings",
        "TestGetScoreApi",
        "test_get_score_api.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9EA7C80>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_score_api.py",
            "lineno": 84,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 178,
            "message": "in get_score_api"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9EA7C80>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9EA7C80>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9EA7C80>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_score_api.TestGetScoreApi testMethod=test_get_score_api_by_wrong_address>\n_make_id = <MagicMock name='_make_id' id='1592523914080'>\n\n    def test_get_score_api_by_wrong_address(self, _make_id):\n        with requests_mock.Mocker() as m:\n            wrong_address = \"cxb0776ee37f5b45bfaea8cff1d8232fbb6122ec32\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getScoreApi',\n                'params': {\n                    'address': wrong_address\n                }\n            }\n    \n            response_json: dict = {\n                \"jsonrpc\": \"2.0\",\n                \"error\": {\n                    \"code\": -32002,\n                    \"message\": f\"SCORE not found: {wrong_address}\"\n                },\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json, status_code=400)\n            # case 3: when the address is not score id\n>           self.assertRaises(JSONRPCException, self.icon_service.get_score_api, wrong_address)\n\ntests\\api_get\\test_get_score_api.py:84: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:178: in get_score_api\n    return self.__provider.make_request('icx_getScoreApi', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9EA7C80>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_score_api.py::TestGetScoreApi::test_get_score_api_invalid",
      "lineno": 53,
      "outcome": "passed",
      "keywords": [
        "test_get_score_api_invalid",
        "__wrapped__",
        "patchings",
        "TestGetScoreApi",
        "test_get_score_api.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_total_supply.py::TestGetTotalSupply::test_get_total_supply",
      "lineno": 26,
      "outcome": "failed",
      "keywords": [
        "test_get_total_supply",
        "__wrapped__",
        "patchings",
        "TestGetTotalSupply",
        "test_get_total_supply.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E903B0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_total_supply.py",
            "lineno": 43,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 131,
            "message": "in get_total_supply"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9E903B0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E91E20>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getTotalSupply\", \"id\": 1234}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9E903B0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9E903B0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_total_supply.TestGetTotalSupply testMethod=test_get_total_supply>\n_make_id = <MagicMock name='_make_id' id='1592525485840'>\n\n    def test_get_total_supply(self, _make_id):\n        with requests_mock.Mocker() as m:\n            supply = 1_000_000_000\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getTotalSupply',\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': hex(supply),\n                'id': 1234\n            }\n            m.post(self.matcher, json=response_json)\n            # case 0: when calling the method successfully\n>           result = self.icon_service.get_total_supply()\n\ntests\\api_get\\test_get_total_supply.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:131: in get_total_supply\n    result = self.__provider.make_request('icx_getTotalSupply', params, full_response=full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E903B0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E91E20>\n_stacktrace = <traceback object at 0x00000172CA2770C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E903B0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_transaction_by_hash.py::TestGetTransactionByHash::test_get_transaction_by_hash",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_get_transaction_by_hash",
        "__wrapped__",
        "patchings",
        "TestGetTransactionByHash",
        "test_get_transaction_by_hash.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E92690>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_transaction_by_hash.py",
            "lineno": 63,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 253,
            "message": "in get_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9E92690>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E92F30>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getTransactionByHash\", \"id\": 1234, \"params\": {\"txHash\": \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9E92690>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9E92690>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_transaction_by_hash.TestGetTransactionByHash testMethod=test_get_transaction_by_hash>\n_make_id = <MagicMock name='_make_id' id='1592525403728'>\n\n    def test_get_transaction_by_hash(self, _make_id):\n        with requests_mock.Mocker() as m:\n            tx_hash = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getTransactionByHash',\n                'params': {\n                    'txHash': tx_hash\n                }\n            }\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": {\n                    \"version\": \"0x3\",\n                    \"from\": self.setting[\"from\"],\n                    \"to\": self.setting[\"to\"],\n                    \"stepLimit\": hex(self.setting[\"step_limit\"]),\n                    \"value\": \"0x470de4df820000\",\n                    \"nid\": hex(self.setting[\"nid\"]),\n                    \"timestamp\": \"1517999520286000\",\n                    \"signature\": \"sILBL1MPwOou8ItM4s0Vqx21l62QyucgTLsEQ51BGi5v/IJ1hOCT/P/rz1V1pDSGAnTQ7rGw9rSOVM5TAGbJOAE=\",\n                    \"method\": \"icx_sendTransaction\",\n                    \"txHash\": tx_hash,\n                    \"txIndex\": \"0x0\",\n                    \"blockHeight\": \"0xa\",\n                    \"blockHash\": \"0x9a39a75d7075687f746d61191baf1a1ff3b5bc0acc4a8df0bb872e53e13cdc17\"\n                },\n                \"id\": 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n            # case 0: when tx_hash is valid\n>           result = self.icon_service.get_transaction(tx_hash)\n\ntests\\api_get\\test_get_transaction_by_hash.py:63: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:253: in get_transaction\n    result = self.__provider.make_request('icx_getTransactionByHash', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E92690>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9E92F30>\n_stacktrace = <traceback object at 0x00000172CA2106C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9E92690>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_transaction_by_hash.py::TestGetTransactionByHash::test_get_transaction_invalid",
      "lineno": 67,
      "outcome": "passed",
      "keywords": [
        "test_get_transaction_invalid",
        "__wrapped__",
        "patchings",
        "TestGetTransactionByHash",
        "test_get_transaction_by_hash.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_transaction_by_hash.py::TestGetTransactionByHash::test_get_transaction_wrong_hash",
      "lineno": 77,
      "outcome": "failed",
      "keywords": [
        "test_get_transaction_wrong_hash",
        "__wrapped__",
        "patchings",
        "TestGetTransactionByHash",
        "test_get_transaction_by_hash.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA1EF650>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_transaction_by_hash.py",
            "lineno": 91,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 253,
            "message": "in get_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA1EF650>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA1EF650>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA1EF650>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_transaction_by_hash.TestGetTransactionByHash testMethod=test_get_transaction_wrong_hash>\n_make_id = <MagicMock name='_make_id' id='1592528922160'>\n\n    def test_get_transaction_wrong_hash(self, _make_id):\n        with requests_mock.Mocker() as m:\n            wrong_tx_hash = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"error\": {\n                    \"code\": -32602,\n                    \"message\": \"Invalid params txHash\"\n                },\n                \"id\": 1234\n            }\n    \n            m.post(self.matcher, json=response_json, status_code=400)\n>           self.assertRaises(JSONRPCException, self.icon_service.get_transaction, wrong_tx_hash)\n\ntests\\api_get\\test_get_transaction_by_hash.py:91: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:253: in get_transaction\n    result = self.__provider.make_request('icx_getTransactionByHash', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA1EF650>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_transaction_result.py::TestGetTransactionResult::test_get_transaction_result",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_get_transaction_result",
        "__wrapped__",
        "patchings",
        "TestGetTransactionResult",
        "test_get_transaction_result.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA2944D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_transaction_result.py",
            "lineno": 69,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 211,
            "message": "in get_transaction_result"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA2944D0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA2965A0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getTransactionResult\", \"id\": 1234, \"params\": {\"txHash\": \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA2944D0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA2944D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_transaction_result.TestGetTransactionResult testMethod=test_get_transaction_result>\n_make_id = <MagicMock name='_make_id' id='1592528923456'>\n\n    def test_get_transaction_result(self, _make_id):\n        tx_hash: str = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getTransactionResult',\n                'params': {\n                    'txHash': tx_hash\n                }\n            }\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": {\n                    \"txHash\": \"0x33db06f38424207daa69c9df153649fd3913c21e162f16f4839c9c3318e44388\",\n                    \"blockHeight\": \"0x13f\",\n                    \"blockHash\": \"0x069e8a2431ae2c7e55924af477be87518476aa1eb1b2e7d1ee8d61d7874ea907\",\n                    \"txIndex\": \"0x1\",\n                    \"to\": \"cx0000000000000000000000000000000000000000\",\n                    \"stepUsed\": \"0x263b8\",\n                    \"stepPrice\": \"0x2540be400\",\n                    \"cumulativeStepUsed\": \"0x263b8\",\n                    \"eventLogs\": [\n                        {\n                            \"scoreAddress\": \"cx0000000000000000000000000000000000000000\",\n                            \"indexed\": [\n                                \"PRepSet(Address)\"\n                            ],\n                            \"data\": [\n                                \"hx86aba2210918a9b116973f3c4b27c41a54d5dafe\"\n                            ]\n                        }\n                    ],\n                    \"logsBloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000080000000000000000000000000000000000000000000000000000000000020000000000000008000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n                    \"status\": \"0x1\"\n                },\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.get_transaction_result(tx_hash)\n\ntests\\api_get\\test_get_transaction_result.py:69: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:211: in get_transaction_result\n    result = self.__provider.make_request('icx_getTransactionResult', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA2944D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA2965A0>\n_stacktrace = <traceback object at 0x00000172CA59C9C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA2944D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_transaction_result.py::TestGetTransactionResult::test_get_transaction_result_invalid",
      "lineno": 98,
      "outcome": "passed",
      "keywords": [
        "test_get_transaction_result_invalid",
        "__wrapped__",
        "patchings",
        "TestGetTransactionResult",
        "test_get_transaction_result.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_get_transaction_result.py::TestGetTransactionResult::test_get_transaction_result_wrong_hash",
      "lineno": 73,
      "outcome": "failed",
      "keywords": [
        "test_get_transaction_result_wrong_hash",
        "__wrapped__",
        "patchings",
        "TestGetTransactionResult",
        "test_get_transaction_result.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA20DAF0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_get_transaction_result.py",
            "lineno": 95,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 211,
            "message": "in get_transaction_result"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA20DAF0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA20DAF0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA20DAF0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_get_transaction_result.TestGetTransactionResult testMethod=test_get_transaction_result_wrong_hash>\n_make_id = <MagicMock name='_make_id' id='1592529059424'>\n\n    def test_get_transaction_result_wrong_hash(self, _make_id):\n        wrong_tx_hash: str = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getTransactionResult',\n                'params': {\n                    'txHash': wrong_tx_hash\n                }\n            }\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"error\": {\n                    \"code\": -32602,\n                    \"message\": \"Invalid params txHash\"\n                },\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json, status_code=400)\n            # case 4: when tx_hash is invalid - not exist\n>           self.assertRaises(JSONRPCException, self.icon_service.get_transaction_result, wrong_tx_hash)\n\ntests\\api_get\\test_get_transaction_result.py:95: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:211: in get_transaction_result\n    result = self.__provider.make_request('icx_getTransactionResult', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA20DAF0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_wait_transaction_result.py::TestWaitTransactionResult::test_wait_transaction_result",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_wait_transaction_result",
        "__wrapped__",
        "patchings",
        "TestWaitTransactionResult",
        "test_wait_transaction_result.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA1EEC00>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_get\\test_wait_transaction_result.py",
            "lineno": 69,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 233,
            "message": "in wait_transaction_result"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA1EEC00>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA1EC770>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_waitTransactionResult\", \"id\": 1234, \"params\": {\"txHash\": \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA1EEC00>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA1EEC00>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_get.test_wait_transaction_result.TestWaitTransactionResult testMethod=test_wait_transaction_result>\n_make_id = <MagicMock name='_make_id' id='1592529602848'>\n\n    def test_wait_transaction_result(self, _make_id):\n        tx_hash: str = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_waitTransactionResult',\n                'params': {\n                    'txHash': tx_hash\n                }\n            }\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": {\n                    \"txHash\": \"0x33db06f38424207daa69c9df153649fd3913c21e162f16f4839c9c3318e44388\",\n                    \"blockHeight\": \"0x13f\",\n                    \"blockHash\": \"0x069e8a2431ae2c7e55924af477be87518476aa1eb1b2e7d1ee8d61d7874ea907\",\n                    \"txIndex\": \"0x1\",\n                    \"to\": \"cx0000000000000000000000000000000000000000\",\n                    \"stepUsed\": \"0x263b8\",\n                    \"stepPrice\": \"0x2540be400\",\n                    \"cumulativeStepUsed\": \"0x263b8\",\n                    \"eventLogs\": [\n                        {\n                            \"scoreAddress\": \"cx0000000000000000000000000000000000000000\",\n                            \"indexed\": [\n                                \"PRepSet(Address)\"\n                            ],\n                            \"data\": [\n                                \"hx86aba2210918a9b116973f3c4b27c41a54d5dafe\"\n                            ]\n                        }\n                    ],\n                    \"logsBloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000080000000000000000000000000000000000000000000000000000000000020000000000000008000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n                    \"status\": \"0x1\"\n                },\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           self.icon_service.wait_transaction_result(tx_hash)\n\ntests\\api_get\\test_wait_transaction_result.py:69: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:233: in wait_transaction_result\n    result = self.__provider.make_request('icx_waitTransactionResult', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA1EEC00>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA1EC770>\n_stacktrace = <traceback object at 0x00000172CA329480>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA1EEC00>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_get/test_wait_transaction_result.py::TestWaitTransactionResult::test_wait_transaction_result_invalid",
      "lineno": 72,
      "outcome": "passed",
      "keywords": [
        "test_wait_transaction_result_invalid",
        "__wrapped__",
        "patchings",
        "TestWaitTransactionResult",
        "test_wait_transaction_result.py",
        "api_get",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_send_deposit.py::TestSendDeposit::test_add_deposit",
      "lineno": 14,
      "outcome": "failed",
      "keywords": [
        "test_add_deposit",
        "__wrapped__",
        "patchings",
        "TestSendDeposit",
        "test_send_deposit.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9EA43E0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_send\\test_send_deposit.py",
            "lineno": 59,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9EA43E0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9EA7230>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_sendTransaction\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc...on\": \"add\"}, \"signature\": \"6btEHlOoPMbF315mwx+sdULfWjV0Cbc6rr5H3EzXfhR1zii8vNi0JPmo1F44fXIPjzAI0dx6deS1miHGHm/6CAA=\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9EA43E0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9EA43E0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_send.test_send_deposit.TestSendDeposit testMethod=test_add_deposit>\n_make_id = <MagicMock name='_make_id' id='1592525389952'>\n\n    def test_add_deposit(self, _make_id):\n        # transaction instance for add action\n        action = \"add\"\n        deposit_transaction = DepositTransactionBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(self.setting[\"to\"]) \\\n            .value(self.setting[\"value\"]) \\\n            .timestamp(self.setting[\"timestamp\"]) \\\n            .step_limit(self.setting[\"step_limit\"]) \\\n            .nid(self.setting[\"nid\"]) \\\n            .nonce(self.setting[\"nonce\"]) \\\n            .action(\"add\") \\\n            .build()\n        signed_transaction = SignedTransaction(deposit_transaction, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            tx_hash = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_sendTransaction',\n                'params': {\n                    'data': {\n                        'action': action\n                    },\n                    'dataType': 'deposit',\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'signature': signed_transaction.signed_transaction_dict[\"signature\"],\n                    'stepLimit': hex(self.setting[\"step_limit\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'to': self.setting[\"to\"],\n                    'value': hex(self.setting[\"value\"]),\n                    'version': hex(3)\n                }\n            }\n    \n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": tx_hash,\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.send_transaction(signed_transaction)\n\ntests\\api_send\\test_send_deposit.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9EA43E0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9EA7230>\n_stacktrace = <traceback object at 0x00000172CA19BD40>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9EA43E0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_send_deposit.py::TestSendDeposit::test_withdraw_deposit",
      "lineno": 68,
      "outcome": "failed",
      "keywords": [
        "test_withdraw_deposit",
        "__wrapped__",
        "patchings",
        "TestSendDeposit",
        "test_send_deposit.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA127050>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_send\\test_send_deposit.py",
            "lineno": 114,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA127050>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA127140>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_sendTransaction\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc...092b5f3dc\"}, \"signature\": \"2qIqubSJb3TDdRTqaev3W3bH1U6ZjY/fXVdbOjGej/MRwNxpGC3PfqrnTlE48eOcfz+0/vo26NMlsAdNKqzl7wA=\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA127050>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA127050>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_send.test_send_deposit.TestSendDeposit testMethod=test_withdraw_deposit>\n_make_id = <MagicMock name='_make_id' id='1592525405120'>\n\n    def test_withdraw_deposit(self, _make_id):\n        # transaction instance for withdraw action\n        action = 'withdraw'\n        withdraw_transaction = DepositTransactionBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(self.setting[\"to\"]) \\\n            .step_limit(self.setting[\"step_limit\"]) \\\n            .timestamp(self.setting[\"timestamp\"]) \\\n            .nid(self.setting[\"nid\"]) \\\n            .nonce(self.setting[\"nonce\"]) \\\n            .id(self.setting[\"id\"]) \\\n            .action(action) \\\n            .build()\n        signed_transaction = SignedTransaction(withdraw_transaction, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            tx_hash = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_sendTransaction',\n                'params': {\n                    'data': {\n                        'action': action,\n                        'id': self.setting[\"id\"],\n                    },\n                    'dataType': 'deposit',\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'signature': signed_transaction.signed_transaction_dict[\"signature\"],\n                    'stepLimit': hex(self.setting[\"step_limit\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'to': self.setting[\"to\"],\n                    'version': hex(3)\n                }\n            }\n    \n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": tx_hash,\n                \"id\": 1234\n            }\n            # Checks if sending transaction correctly\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.send_transaction(signed_transaction)\n\ntests\\api_send\\test_send_deposit.py:114: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA127050>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA127140>\n_stacktrace = <traceback object at 0x00000172C9D18140>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA127050>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_send_message.py::TestSendMessage::test_get_block",
      "lineno": 113,
      "outcome": "failed",
      "keywords": [
        "test_get_block",
        "__wrapped__",
        "patchings",
        "TestSendMessage",
        "test_send_message.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C6F6E0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_send\\test_send_message.py",
            "lineno": 167,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 109,
            "message": "in get_block"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9C6F6E0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9CB8BF0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getBlockByHeight\", \"id\": 1234, \"params\": {\"height\": \"0x13f\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9C6F6E0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9C6F6E0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_send.test_send_message.TestSendMessage testMethod=test_get_block>\n_make_id = <MagicMock name='_make_id' id='1592523345264'>\n\n    def test_get_block(self, _make_id):\n        with requests_mock.Mocker() as m:\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": {\n                    \"version\": \"0.5\",\n                    \"height\": int('0x13f', 16),\n                    \"signature\": \"yO4YWy0+pM6IFad3exORZWhFD+4RLNSmhCwzIc5aJ3wfazGJH2e2sBWtGRDjiVK+xnw7SDWVUzik/aq3DmJLeQE=\",\n                    \"prev_block_hash\": \"6399543b290eef968b68f88459190a4d6aedba1a3fafcc5169dc20184d01932a\",\n                    \"merkle_tree_root_hash\": \"72bd9b1572a608e9108c285fbe7b34e3e814a1b263dd76065bd90e5b43d390f3\",\n                    \"time_stamp\": 1612856659125677,\n                    \"confirmed_transaction_list\": [\n                        {\n                            \"version\": \"0x3\",\n                            \"timestamp\": \"0x5bae2743da5ad\",\n                            \"dataType\": \"base\",\n                            \"data\": {\n                                \"prep\": {\n                                    \"irep\": \"0x21e19e0c9bab2400000\",\n                                    \"rrep\": \"0x1b0\",\n                                    \"totalDelegation\": \"0x105e700bc013de49eb56d3e\",\n                                    \"value\": \"0x2b2609c5e9b67ee3\"\n                                },\n                                \"result\": {\n                                    \"coveredByFee\": \"0x228c61981e4800\",\n                                    \"coveredByOverIssuedICX\": \"0x0\",\n                                    \"issue\": \"0x2b037d64519836e3\"\n                                }\n                            },\n                            \"txHash\": \"0xd92cce2a115d74544f2561db73a7b525cbb11b2cc95c0691acedfa2cd637fe44\"\n                        },\n                        {\n                            \"version\": \"0x3\",\n                            \"from\": self.setting['from'],\n                            \"to\": self.setting['to'],\n                            \"value\": self.setting['value'],\n                            \"stepLimit\": self.setting['step_limit'],\n                            \"nid\": self.setting['nid'],\n                            \"timestamp\": self.setting['nid'],\n                            \"nonce\": self.setting['nonce'],\n                            \"signature\": \"gc5mS40dRlqs7qndNDhOZFDU/V6KpGAWc10zcXM4ukp1p7sCFKkMzJY0dVmzxIyE67cW8ybbcgjUa/Bp+yf0JwE=\",\n                            \"txHash\": \"0x33db06f38424207daa69c9df153649fd3913c21e162f16f4839c9c3318e44388\",\n                            'data': self.setting['data']\n                        }\n                    ],\n                    \"block_hash\": \"1ad6d9651bc6038ff330cda87ddefecfa7674d441a4aa7de164237ad43006e22\",\n                    \"peer_id\": \"hx49ce06eab947cb5ba2475781044d305af9d8d9d5\",\n                    \"next_leader\": \"hx49ce06eab947cb5ba2475781044d305af9d8d9d5\"\n                },\n                \"id\": 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.get_block(int('0x13f', 16))\n\ntests\\api_send\\test_send_message.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:109: in get_block\n    result = self.__provider.make_request(method, params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C6F6E0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9CB8BF0>\n_stacktrace = <traceback object at 0x00000172CA3DF1C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9C6F6E0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_send_message.py::TestSendMessage::test_get_transaction_result",
      "lineno": 76,
      "outcome": "failed",
      "keywords": [
        "test_get_transaction_result",
        "__wrapped__",
        "patchings",
        "TestSendMessage",
        "test_send_message.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FD7380>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_send\\test_send_message.py",
            "lineno": 108,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 211,
            "message": "in get_transaction_result"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9FD7380>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FD6EA0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getTransactionResult\", \"id\": 1234, \"params\": {\"txHash\": \"0x33db06f38424207daa69c9df153649fd3913c21e162f16f4839c9c3318e44388\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9FD7380>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9FD7380>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_send.test_send_message.TestSendMessage testMethod=test_get_transaction_result>\n_make_id = <MagicMock name='_make_id' id='1592524966896'>\n\n    def test_get_transaction_result(self, _make_id):\n        with requests_mock.Mocker() as m:\n            tx_hash = \"0x33db06f38424207daa69c9df153649fd3913c21e162f16f4839c9c3318e44388\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_getTransactionResult',\n                'params': {\n                    'txHash': tx_hash\n                }\n            }\n    \n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": {\n                    \"txHash\": \"0x33db06f38424207daa69c9df153649fd3913c21e162f16f4839c9c3318e44388\",\n                    \"blockHeight\": \"0x13f\",\n                    \"blockHash\": \"0x069e8a2431ae2c7e55924af477be87518476aa1eb1b2e7d1ee8d61d7874ea907\",\n                    \"txIndex\": \"0x1\",\n                    \"to\": self.setting['to'],\n                    \"stepUsed\": \"0x263b8\",\n                    \"stepPrice\": \"0x2540be400\",\n                    \"cumulativeStepUsed\": \"0x263b8\",\n                    \"eventLogs\": [],\n                    \"logsBloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000080000000000000000000000000000000000000000000000000000000000020000000000000008000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n                    \"status\": \"0x1\"\n                },\n                \"id\": 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.get_transaction_result(tx_hash)\n\ntests\\api_send\\test_send_message.py:108: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:211: in get_transaction_result\n    result = self.__provider.make_request('icx_getTransactionResult', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FD7380>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9FD6EA0>\n_stacktrace = <traceback object at 0x00000172CA5F9180>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9FD7380>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_send_message.py::TestSendMessage::test_invalid",
      "lineno": 170,
      "outcome": "failed",
      "keywords": [
        "test_invalid",
        "__wrapped__",
        "patchings",
        "TestSendMessage",
        "test_send_message.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D86E10>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_send\\test_send_message.py",
            "lineno": 198,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9D86E10>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9D86E10>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9D86E10>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_send.test_send_message.TestSendMessage testMethod=test_invalid>\n_make_id = <MagicMock name='_make_id' id='1592523510208'>\n\n    def test_invalid(self, _make_id):\n        # When data is not hex string\n        with requests_mock.Mocker() as m:\n            message_transaction = MessageTransactionBuilder() \\\n                .from_(self.setting[\"from\"]) \\\n                .to(self.setting[\"to\"]) \\\n                .step_limit(self.setting[\"step_limit\"]) \\\n                .nid(self.setting[\"nid\"]) \\\n                .nonce(self.setting[\"nonce\"]) \\\n                .data(\"test\")\n    \n            # Raise DataTypeException\n            self.assertRaises(DataTypeException, message_transaction.build)\n    \n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"error\": {\n                    \"code\": -32602,\n                    \"message\": \"Server error\"\n                },\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json, status_code=400)\n            # When address is wrong\n            message_transaction = MessageTransactionBuilder().from_(self.setting[\"from\"]).to(self.setting[\"to\"][2:]) \\\n                .step_limit(self.setting[\"step_limit\"]).nid(self.setting[\"nid\"]).data(self.setting[\"data\"]).build()\n            signed_transaction = SignedTransaction(message_transaction, self.wallet)\n>           self.assertRaises(JSONRPCException, self.icon_service.send_transaction, signed_transaction)\n\ntests\\api_send\\test_send_message.py:198: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D86E10>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_send_message.py::TestSendMessage::test_send_message",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_send_message",
        "__wrapped__",
        "patchings",
        "TestSendMessage",
        "test_send_message.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D03D40>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_send\\test_send_message.py",
            "lineno": 72,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172C9D03D40>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D010A0>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_sendTransaction\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc...0x74657374\", \"signature\": \"QoiktuTfE8Lus7YcOchVYS2feGTgtMW8nwwDYVHhak5KifgI3jXW8hit2z992/rrJ4hfrFf/RhNwM7YZss6JeQA=\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172C9D03D40>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172C9D03D40>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_send.test_send_message.TestSendMessage testMethod=test_send_message>\n_make_id = <MagicMock name='_make_id' id='1592524977840'>\n\n    def test_send_message(self, _make_id):\n        message_transaction = MessageTransactionBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(self.setting[\"to\"]) \\\n            .step_limit(self.setting[\"step_limit\"]) \\\n            .nid(self.setting[\"nid\"]) \\\n            .nonce(self.setting[\"nonce\"]) \\\n            .data(self.setting[\"data\"]) \\\n            .timestamp(self.setting[\"timestamp\"]) \\\n            .build()\n    \n        tx_dict = SignedTransaction.convert_tx_to_jsonrpc_request(message_transaction)\n        self.assertTrue(is_message_transaction(tx_dict))\n        signed_transaction = SignedTransaction(message_transaction, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            tx_hash = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_sendTransaction',\n                'params': {\n                    'data': self.setting[\"data\"],\n                    'dataType': 'message',\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'signature': signed_transaction.signed_transaction_dict[\"signature\"],\n                    'stepLimit': hex(self.setting[\"step_limit\"]),\n                    'to': self.setting[\"to\"],\n                    'version': hex(3)\n                }\n            }\n    \n            response_json = {\n                'jsonrpc': '2.0',\n                'result': tx_hash,\n                'id': 1234\n            }\n    \n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.send_transaction(signed_transaction)\n\ntests\\api_send\\test_send_message.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D03D40>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172C9D010A0>\n_stacktrace = <traceback object at 0x00000172CA08EE80>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172C9D03D40>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_send_transfer.py::TestSendTransfer::test_invalid_transfer1",
      "lineno": 74,
      "outcome": "passed",
      "keywords": [
        "test_invalid_transfer1",
        "__wrapped__",
        "patchings",
        "TestSendTransfer",
        "test_send_transfer.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_send_transfer.py::TestSendTransfer::test_invalid_transfer2",
      "lineno": 87,
      "outcome": "failed",
      "keywords": [
        "test_invalid_transfer2",
        "__wrapped__",
        "patchings",
        "TestSendTransfer",
        "test_send_transfer.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA389E50>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_send\\test_send_transfer.py",
            "lineno": 126,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA389E50>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA389E50>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA389E50>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_send.test_send_transfer.TestSendTransfer testMethod=test_invalid_transfer2>\n_make_id = <MagicMock name='_make_id' id='1592529057216'>\n\n    def test_invalid_transfer2(self, _make_id):\n        icx_transaction = TransactionBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(self.setting[\"to\"][2:]) \\\n            .value(self.setting[\"value\"]) \\\n            .step_limit(self.setting[\"step_limit\"]) \\\n            .nid(self.setting[\"nid\"]) \\\n            .timestamp(self.setting[\"timestamp\"]) \\\n            .build()\n        signed_transaction = SignedTransaction(icx_transaction, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_sendTransaction',\n                'params': {\n                    'from': self.setting[\"from\"],\n                    'to': self.setting[\"to\"][2:],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'signature': signed_transaction.signed_transaction_dict[\"signature\"],\n                    'stepLimit': hex(self.setting[\"step_limit\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'value': hex(self.setting[\"value\"]),\n                    'version': '0x3'\n                }\n            }\n    \n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"error\": {\n                    \"code\": -32602,\n                    \"message\": \"Server error\"\n                },\n                \"id\": 5\n            }\n    \n            m.post(self.matcher, json=response_json, status_code=500)\n>           self.assertRaises(JSONRPCException, self.icon_service.send_transaction, signed_transaction)\n\ntests\\api_send\\test_send_transfer.py:126: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA389E50>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_send_transfer.py::TestSendTransfer::test_transfer",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_transfer",
        "__wrapped__",
        "patchings",
        "TestSendTransfer",
        "test_send_transfer.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA3881D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_send\\test_send_transfer.py",
            "lineno": 70,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 301,
            "message": "in send_transaction"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA3881D0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA389040>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_sendTransaction\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5fcfd8dfc...nce\": \"0x3\", \"signature\": \"qBRjUUR28g7QUcixD0YKSgV6kDrJgyNuoBYgfLeaMQlWzyKunRLwox95wDXpRz1tn53NdFt9EtNwl6wnwKo2wgE=\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA3881D0>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA3881D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_send.test_send_transfer.TestSendTransfer testMethod=test_transfer>\n_make_id = <MagicMock name='_make_id' id='1592523914320'>\n\n    def test_transfer(self, _make_id):\n        icx_transaction = TransactionBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(self.setting[\"to\"]) \\\n            .value(self.setting[\"value\"]) \\\n            .step_limit(self.setting[\"step_limit\"]) \\\n            .nid(3) \\\n            .nonce(self.setting[\"nonce\"]) \\\n            .version(3) \\\n            .timestamp(self.setting[\"timestamp\"]) \\\n            .build()\n        tx_dict = SignedTransaction.convert_tx_to_jsonrpc_request(icx_transaction)\n        self.assertTrue(is_icx_transaction(tx_dict))\n        signed_transaction = SignedTransaction(icx_transaction, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            tx_hash: str = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_sendTransaction',\n                'params': {\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'signature': signed_transaction.signed_transaction_dict[\"signature\"],\n                    'stepLimit': hex(self.setting[\"step_limit\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'to': self.setting[\"to\"],\n                    'value': hex(self.setting[\"value\"]),\n                    'version': '0x3'\n                }\n            }\n    \n            response_json: dict = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": tx_hash,\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           result = self.icon_service.send_transaction(signed_transaction)\n\ntests\\api_send\\test_send_transfer.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:301: in send_transaction\n    return self.__provider.make_request('icx_sendTransaction', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA3881D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA389040>\n_stacktrace = <traceback object at 0x00000172C9ECCF00>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA3881D0>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_send_tx_wait.py::TestSendAndWait::test_transfer",
      "lineno": 29,
      "outcome": "failed",
      "keywords": [
        "test_transfer",
        "__wrapped__",
        "patchings",
        "TestSendAndWait",
        "test_send_tx_wait.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA3C9370>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\api_send\\test_send_tx_wait.py",
            "lineno": 70,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 313,
            "message": "in send_transaction_and_wait"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA3C9370>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA3C8650>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_sendTransactionAndWait\", \"id\": 1234, \"params\": {\"version\": \"0x3\", \"from\": \"hxe7af5f...nce\": \"0x3\", \"signature\": \"qBRjUUR28g7QUcixD0YKSgV6kDrJgyNuoBYgfLeaMQlWzyKunRLwox95wDXpRz1tn53NdFt9EtNwl6wnwKo2wgE=\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA3C9370>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA3C9370>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_send.test_send_tx_wait.TestSendAndWait testMethod=test_transfer>\n_make_id = <MagicMock name='_make_id' id='1592530606208'>\n\n    def test_transfer(self, _make_id):\n        icx_transaction = TransactionBuilder() \\\n            .from_(self.setting[\"from\"]) \\\n            .to(self.setting[\"to\"]) \\\n            .value(self.setting[\"value\"]) \\\n            .step_limit(self.setting[\"step_limit\"]) \\\n            .nid(3) \\\n            .nonce(self.setting[\"nonce\"]) \\\n            .version(3) \\\n            .timestamp(self.setting[\"timestamp\"]) \\\n            .build()\n        tx_dict = SignedTransaction.convert_tx_to_jsonrpc_request(icx_transaction)\n        self.assertTrue(is_icx_transaction(tx_dict))\n        signed_transaction = SignedTransaction(icx_transaction, self.wallet)\n    \n        with requests_mock.Mocker() as m:\n            tx_hash: str = \"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"\n            expected_request = {\n                'id': 1234,\n                'jsonrpc': '2.0',\n                'method': 'icx_sendTransactionAndWait',\n                'params': {\n                    'from': self.setting[\"from\"],\n                    'nid': hex(self.setting[\"nid\"]),\n                    'nonce': hex(self.setting[\"nonce\"]),\n                    'signature': signed_transaction.signed_transaction_dict[\"signature\"],\n                    'stepLimit': hex(self.setting[\"step_limit\"]),\n                    'timestamp': hex(self.setting[\"timestamp\"]),\n                    'to': self.setting[\"to\"],\n                    'value': hex(self.setting[\"value\"]),\n                    'version': '0x3'\n                }\n            }\n    \n            response_json: dict = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": tx_hash,\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           self.icon_service.send_transaction_and_wait(signed_transaction)\n\ntests\\api_send\\test_send_tx_wait.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:313: in send_transaction_and_wait\n    result = self.__provider.make_request('icx_sendTransactionAndWait', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA3C9370>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA3C8650>\n_stacktrace = <traceback object at 0x00000172CA63D600>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA3C9370>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_convert_tx_to_jsonrpc_request_for_add_deposit_transaction",
      "lineno": 116,
      "outcome": "passed",
      "keywords": [
        "test_convert_tx_to_jsonrpc_request_for_add_deposit_transaction",
        "TestSignedTransaction",
        "test_signed_transaction.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_convert_tx_to_jsonrpc_request_for_call_transaction",
      "lineno": 90,
      "outcome": "passed",
      "keywords": [
        "test_convert_tx_to_jsonrpc_request_for_call_transaction",
        "TestSignedTransaction",
        "test_signed_transaction.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_convert_tx_to_jsonrpc_request_for_deploy_transaction",
      "lineno": 63,
      "outcome": "passed",
      "keywords": [
        "test_convert_tx_to_jsonrpc_request_for_deploy_transaction",
        "TestSignedTransaction",
        "test_signed_transaction.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_convert_tx_to_jsonrpc_request_for_icx_transaction",
      "lineno": 28,
      "outcome": "passed",
      "keywords": [
        "test_convert_tx_to_jsonrpc_request_for_icx_transaction",
        "TestSignedTransaction",
        "test_signed_transaction.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_convert_tx_to_jsonrpc_request_for_message_transaction",
      "lineno": 104,
      "outcome": "passed",
      "keywords": [
        "test_convert_tx_to_jsonrpc_request_for_message_transaction",
        "TestSignedTransaction",
        "test_signed_transaction.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_convert_tx_to_jsonrpc_request_for_withdraw_deposit_transaction",
      "lineno": 130,
      "outcome": "passed",
      "keywords": [
        "test_convert_tx_to_jsonrpc_request_for_withdraw_deposit_transaction",
        "TestSignedTransaction",
        "test_signed_transaction.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_signed_transaction_with_call_transaction_without_step_limit",
      "lineno": 170,
      "outcome": "passed",
      "keywords": [
        "test_signed_transaction_with_call_transaction_without_step_limit",
        "TestSignedTransaction",
        "test_signed_transaction.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_signed_transaction_with_deploy_transaction_without_step_limit",
      "lineno": 156,
      "outcome": "passed",
      "keywords": [
        "test_signed_transaction_with_deploy_transaction_without_step_limit",
        "TestSignedTransaction",
        "test_signed_transaction.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_signed_transaction_with_deposit_transaction_of_add_action_without_step_limit",
      "lineno": 194,
      "outcome": "passed",
      "keywords": [
        "test_signed_transaction_with_deposit_transaction_of_add_action_without_step_limit",
        "TestSignedTransaction",
        "test_signed_transaction.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_signed_transaction_with_deposit_transaction_of_deposit_action_without_step_limit",
      "lineno": 207,
      "outcome": "passed",
      "keywords": [
        "test_signed_transaction_with_deposit_transaction_of_deposit_action_without_step_limit",
        "TestSignedTransaction",
        "test_signed_transaction.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_signed_transaction_with_icx_transaction_without_step_limit",
      "lineno": 144,
      "outcome": "passed",
      "keywords": [
        "test_signed_transaction_with_icx_transaction_without_step_limit",
        "TestSignedTransaction",
        "test_signed_transaction.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/api_send/test_signed_transaction.py::TestSignedTransaction::test_signed_transaction_with_message_transaction_without_step_limit",
      "lineno": 183,
      "outcome": "passed",
      "keywords": [
        "test_signed_transaction_with_message_transaction_without_step_limit",
        "TestSignedTransaction",
        "test_signed_transaction.py",
        "api_send",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/builder/test_call_builder.py::TestCallBuilder::test_make_call_builder",
      "lineno": 22,
      "outcome": "passed",
      "keywords": [
        "test_make_call_builder",
        "TestCallBuilder",
        "test_call_builder.py",
        "builder",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/builder/test_call_builder.py::TestCallBuilder::test_make_call_builder_changed",
      "lineno": 59,
      "outcome": "passed",
      "keywords": [
        "test_make_call_builder_changed",
        "TestCallBuilder",
        "test_call_builder.py",
        "builder",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/builder/test_call_builder.py::TestCallBuilder::test_make_call_builder_from_dict_to_dict",
      "lineno": 45,
      "outcome": "passed",
      "keywords": [
        "test_make_call_builder_from_dict_to_dict",
        "TestCallBuilder",
        "test_call_builder.py",
        "builder",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/builder/test_transaction_builder.py::TestTransactionBuilder::test_deposit_transaction_id_and_amount_at_same_time_for_withdraw_action",
      "lineno": 307,
      "outcome": "passed",
      "keywords": [
        "test_deposit_transaction_id_and_amount_at_same_time_for_withdraw_action",
        "TestTransactionBuilder",
        "test_transaction_builder.py",
        "builder",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/builder/test_transaction_builder.py::TestTransactionBuilder::test_deposit_transaction_to_dict_for_add_action",
      "lineno": 212,
      "outcome": "passed",
      "keywords": [
        "test_deposit_transaction_to_dict_for_add_action",
        "TestTransactionBuilder",
        "test_transaction_builder.py",
        "builder",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/builder/test_transaction_builder.py::TestTransactionBuilder::test_deposit_transaction_to_dict_for_withdraw_action",
      "lineno": 266,
      "outcome": "passed",
      "keywords": [
        "test_deposit_transaction_to_dict_for_withdraw_action",
        "TestTransactionBuilder",
        "test_transaction_builder.py",
        "builder",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/builder/test_transaction_builder.py::TestTransactionBuilder::test_transaction_builder_from_dict",
      "lineno": 129,
      "outcome": "passed",
      "keywords": [
        "test_transaction_builder_from_dict",
        "TestTransactionBuilder",
        "test_transaction_builder.py",
        "builder",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/converter/test_converter.py::TestConverter::test_converter_blocks",
      "lineno": 122,
      "outcome": "skipped",
      "keywords": [
        "test_converter_blocks",
        "TestConverter",
        "test_converter.py",
        "converter",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\\\tests\\\\converter\\\\test_converter.py', 123, 'Skipped: TestConverter MUST work without network')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/converter/test_converter.py::TestConverter::test_converter_transactions",
      "lineno": 143,
      "outcome": "skipped",
      "keywords": [
        "test_converter_transactions",
        "TestConverter",
        "test_converter.py",
        "converter",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\\\tests\\\\converter\\\\test_converter.py', 144, 'Skipped: TestConverter MUST work without network')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/converter/test_converter.py::TestConverter::test_converter_tx_results",
      "lineno": 151,
      "outcome": "skipped",
      "keywords": [
        "test_converter_tx_results",
        "TestConverter",
        "test_converter.py",
        "converter",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\\\tests\\\\converter\\\\test_converter.py', 152, 'Skipped: TestConverter MUST work without network')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/converter/test_converter.py::TestConverter::test_integrate_converter",
      "lineno": 157,
      "outcome": "skipped",
      "keywords": [
        "test_integrate_converter",
        "TestConverter",
        "test_converter.py",
        "converter",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "skipped",
        "longrepr": "('D:\\\\repos\\\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\\\tests\\\\converter\\\\test_converter.py', 158, 'Skipped: TestConverter MUST work without network')"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/libs/test_in_memory_zip.py::TestInMemoryZip::test_in_memory_zip",
      "lineno": 23,
      "outcome": "failed",
      "keywords": [
        "test_in_memory_zip",
        "TestInMemoryZip",
        "test_in_memory_zip.py",
        "libs",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\unittest\\case.py",
          "lineno": 721,
          "message": "AssertionError: True is not false"
        },
        "traceback": [
          {
            "path": "tests\\libs\\test_in_memory_zip.py",
            "lineno": 31,
            "message": "AssertionError"
          }
        ],
        "longrepr": "self = <tests.libs.test_in_memory_zip.TestInMemoryZip testMethod=test_in_memory_zip>\n\n    def test_in_memory_zip(self):\n        current_dir_path = path.abspath(path.dirname(__file__))\n        score_path = path.join(current_dir_path, 'sample_token')\n        tests_path = path.join(current_dir_path, 'sample_token','tests')\n        # bytes of sample_token's content\n        content_bytes = gen_deploy_data_content(score_path)\n        content_bytes_as_str = str(content_bytes)\n>       self.assertFalse('test_integrate_sample_token.py' in content_bytes_as_str )\nE       AssertionError: True is not false\n\ntests\\libs\\test_in_memory_zip.py:31: AssertionError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/libs/test_serializer.py::TestSerializer::test_for_serialize_case_for_calling",
      "lineno": 31,
      "outcome": "passed",
      "keywords": [
        "test_for_serialize_case_for_calling",
        "TestSerializer",
        "test_serializer.py",
        "libs",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/libs/test_serializer.py::TestSerializer::test_for_serialize_case_for_sending_normal_tx",
      "lineno": 23,
      "outcome": "passed",
      "keywords": [
        "test_for_serialize_case_for_sending_normal_tx",
        "TestSerializer",
        "test_serializer.py",
        "libs",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/libs/test_signer.py::TestIcxSigner::test_verify_recoverable_sign",
      "lineno": 33,
      "outcome": "passed",
      "keywords": [
        "test_verify_recoverable_sign",
        "TestIcxSigner",
        "test_signer.py",
        "libs",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/providers/test_http_provider.py::TestHTTPProvider::test_set_http_provider_by_new_initializer_with_invalid_url",
      "lineno": 70,
      "outcome": "passed",
      "keywords": [
        "test_set_http_provider_by_new_initializer_with_invalid_url",
        "TestHTTPProvider",
        "test_http_provider.py",
        "providers",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/providers/test_http_provider.py::TestHTTPProvider::test_set_http_provider_by_the_initializer_with_valid_url",
      "lineno": 57,
      "outcome": "passed",
      "keywords": [
        "test_set_http_provider_by_the_initializer_with_valid_url",
        "TestHTTPProvider",
        "test_http_provider.py",
        "providers",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/providers/test_http_provider.py::TestHTTPProvider::test_set_http_provider_with_param",
      "lineno": 27,
      "outcome": "passed",
      "keywords": [
        "test_set_http_provider_with_param",
        "TestHTTPProvider",
        "test_http_provider.py",
        "providers",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/providers/test_http_provider.py::TestHTTPProvider::test_set_http_provider_with_request_kwargs",
      "lineno": 37,
      "outcome": "passed",
      "keywords": [
        "test_set_http_provider_with_request_kwargs",
        "TestHTTPProvider",
        "test_http_provider.py",
        "providers",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/utils/test_convert_type.py::TestConvertType::test_convert_hex_str_to_bytes",
      "lineno": 50,
      "outcome": "passed",
      "keywords": [
        "test_convert_hex_str_to_bytes",
        "TestConvertType",
        "test_convert_type.py",
        "utils",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/utils/test_convert_type.py::TestConvertType::test_convert_negative_value_to_hex_str",
      "lineno": 23,
      "outcome": "passed",
      "keywords": [
        "test_convert_negative_value_to_hex_str",
        "TestConvertType",
        "test_convert_type.py",
        "utils",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/utils/test_convert_type.py::TestConvertType::test_convert_positive_value_to_hex_str",
      "lineno": 32,
      "outcome": "passed",
      "keywords": [
        "test_convert_positive_value_to_hex_str",
        "TestConvertType",
        "test_convert_type.py",
        "utils",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/utils/test_convert_type.py::TestConvertType::test_convert_zero_value_to_hex_str",
      "lineno": 41,
      "outcome": "passed",
      "keywords": [
        "test_convert_zero_value_to_hex_str",
        "TestConvertType",
        "test_convert_type.py",
        "utils",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/utils/test_hexadecimal.py::TestHexadecimal::test_is_hex_string_prefixed_with_0x",
      "lineno": 46,
      "outcome": "passed",
      "keywords": [
        "test_is_hex_string_prefixed_with_0x",
        "TestHexadecimal",
        "test_hexadecimal.py",
        "utils",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/utils/test_hexadecimal.py::TestHexadecimal::test_is_lowercase_hex_string",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_is_lowercase_hex_string",
        "TestHexadecimal",
        "test_hexadecimal.py",
        "utils",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/utils/test_validation.py::TestValidation::test_method_has_keys",
      "lineno": 36,
      "outcome": "passed",
      "keywords": [
        "test_method_has_keys",
        "TestValidation",
        "test_validation.py",
        "utils",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/utils/test_validation.py::TestValidation::test_method_validate_keystore_file",
      "lineno": 29,
      "outcome": "passed",
      "keywords": [
        "test_method_validate_keystore_file",
        "TestValidation",
        "test_validation.py",
        "utils",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/utils/test_validation.py::TestValidation::test_validate_keystore_file_is_for_icon",
      "lineno": 70,
      "outcome": "passed",
      "keywords": [
        "test_validate_keystore_file_is_for_icon",
        "TestValidation",
        "test_validation.py",
        "utils",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_get_public_key[True-True-str-33]",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_get_public_key[True-True-str-33]",
        "parametrize",
        "pytestmark",
        "True-True-str-33",
        "TestKeyWallet",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed",
        "stdout": "022c8faef740447401a46abed7e10778e909ce9f2c8c905e6990acff15c2be3661\n"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_get_public_key[True-False-bytes-33]",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_get_public_key[True-False-bytes-33]",
        "parametrize",
        "pytestmark",
        "True-False-bytes-33",
        "TestKeyWallet",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_get_public_key[False-True-str-65]",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_get_public_key[False-True-str-65]",
        "parametrize",
        "pytestmark",
        "False-True-str-65",
        "TestKeyWallet",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed",
        "stdout": "049a4748c1ec152b1d8687ba479ec42cb19d203fe75be6e666d66659c18902b70b4d93b0dbd177dbc7f46e9b276eb4db37d395e5d3f5a38abe7562deb20ed745b1\n"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_get_public_key[False-False-bytes-65]",
      "lineno": 11,
      "outcome": "passed",
      "keywords": [
        "test_get_public_key[False-False-bytes-65]",
        "parametrize",
        "pytestmark",
        "False-False-bytes-65",
        "TestKeyWallet",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_get_private_key",
      "lineno": 31,
      "outcome": "passed",
      "keywords": [
        "test_get_private_key",
        "TestKeyWallet",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_private_key",
      "lineno": 41,
      "outcome": "passed",
      "keywords": [
        "test_private_key",
        "TestKeyWallet",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_public_key",
      "lineno": 49,
      "outcome": "passed",
      "keywords": [
        "test_public_key",
        "TestKeyWallet",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_to_dict",
      "lineno": 55,
      "outcome": "passed",
      "keywords": [
        "test_to_dict",
        "TestKeyWallet",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_copy",
      "lineno": 65,
      "outcome": "passed",
      "keywords": [
        "test_copy",
        "TestKeyWallet",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::TestKeyWallet::test_hash",
      "lineno": 73,
      "outcome": "passed",
      "keywords": [
        "test_hash",
        "TestKeyWallet",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::test_public_key_to_address",
      "lineno": 79,
      "outcome": "passed",
      "keywords": [
        "test_public_key_to_address",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::test_convert_public_key_format[True-True-33]",
      "lineno": 89,
      "outcome": "passed",
      "keywords": [
        "test_convert_public_key_format[True-True-33]",
        "parametrize",
        "pytestmark",
        "True-True-33",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::test_convert_public_key_format[True-False-65]",
      "lineno": 89,
      "outcome": "passed",
      "keywords": [
        "test_convert_public_key_format[True-False-65]",
        "parametrize",
        "pytestmark",
        "True-False-65",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::test_convert_public_key_format[False-True-33]",
      "lineno": 89,
      "outcome": "passed",
      "keywords": [
        "test_convert_public_key_format[False-True-33]",
        "parametrize",
        "pytestmark",
        "False-True-33",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet.py::test_convert_public_key_format[False-False-65]",
      "lineno": 89,
      "outcome": "passed",
      "keywords": [
        "test_convert_public_key_format[False-False-65]",
        "parametrize",
        "pytestmark",
        "False-False-65",
        "test_wallet.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet_create.py::TestWalletCreate::test_wallet_create_successfully",
      "lineno": 23,
      "outcome": "passed",
      "keywords": [
        "test_wallet_create_successfully",
        "TestWalletCreate",
        "test_wallet_create.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet_load_by_private_key.py::TestWalletLoadByPrivateKey::test_wallet_load_by_private_key",
      "lineno": 25,
      "outcome": "passed",
      "keywords": [
        "test_wallet_load_by_private_key",
        "TestWalletLoadByPrivateKey",
        "test_wallet_load_by_private_key.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py::TestWalletLoadFromKeystoreFile::test_wallet_load_and_call_api",
      "lineno": 63,
      "outcome": "failed",
      "keywords": [
        "test_wallet_load_and_call_api",
        "__wrapped__",
        "patchings",
        "TestWalletLoadFromKeystoreFile",
        "test_wallet_load_from_keystore_file.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
          "lineno": 594,
          "message": "urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA490830>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))"
        },
        "traceback": [
          {
            "path": "tests\\wallet\\test_wallet_load_from_keystore_file.py",
            "lineno": 82,
            "message": ""
          },
          {
            "path": "iconsdk\\icon_service.py",
            "lineno": 153,
            "message": "in get_balance"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 151,
            "message": "in make_request"
          },
          {
            "path": "iconsdk\\providers\\http_provider.py",
            "lineno": 128,
            "message": "in _make_post_request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 81,
            "message": "in request"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\request.py",
            "lineno": 173,
            "message": "in request_encode_body"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\poolmanager.py",
            "lineno": 376,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 830,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\connectionpool.py",
            "lineno": 802,
            "message": "in urlopen"
          },
          {
            "path": ".venv\\Lib\\site-packages\\urllib3\\util\\retry.py",
            "lineno": 594,
            "message": "MaxRetryError"
          }
        ],
        "longrepr": "self = <urllib3.connection.HTTPConnection object at 0x00000172CA490830>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n>           conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:95: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 9000), timeout = 10, source_address = None\nsocket_options = [(6, 1, 1)]\n\n    def create_connection(\n        address,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        source_address=None,\n        socket_options=None,\n    ):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        if host.startswith(\"[\"):\n            host = host.strip(\"[]\")\n        err = None\n    \n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n        # The original create_connection function always returns all records.\n        family = allowed_gai_family()\n    \n        try:\n            host.encode(\"idna\")\n        except UnicodeError:\n            return six.raise_from(\n                LocationParseError(u\"'%s', label empty or too long\" % host), None\n            )\n    \n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket.socket(af, socktype, proto)\n    \n                # If provided, set socket level options before connecting.\n                _set_socket_options(sock, socket_options)\n    \n                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\util\\connection.py:85: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA490050>\nmethod = 'POST', url = '/api/v3'\nbody = '{\"jsonrpc\": \"2.0\", \"method\": \"icx_getBalance\", \"id\": 1234, \"params\": {\"address\": \"hxfd7e4560ba363f5aabd32caac7317feeee70ea57\"}}'\nheaders = {'Content-Type': 'application/json'}\nretries = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nredirect = False, assert_same_host = False, timeout = 10, pool_timeout = None\nrelease_conn = True, chunked = False, body_pos = None\nresponse_kw = {'request_url': 'http://localhost:9000/api/v3'}\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v3', query=None, fragment=None)\ndestination_scheme = None, conn = None, release_this_conn = True\nhttp_tunnel_required = False, err = None, clean_exit = False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n    \n        .. note::\n    \n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n    \n        .. note::\n    \n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n    \n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n    \n        :param url:\n            The URL to perform the request on.\n    \n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n    \n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n    \n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n    \n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n    \n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n    \n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n    \n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n    \n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n    \n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n    \n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n    \n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n    \n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n    \n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n    \n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n    \n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n    \n        if headers is None:\n            headers = self.headers\n    \n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n    \n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n    \n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n    \n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n    \n        conn = None\n    \n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] <https://github.com/urllib3/urllib3/issues/651>\n        release_this_conn = release_conn\n    \n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n    \n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n    \n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n    \n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n    \n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n    \n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n    \n            conn.timeout = timeout_obj.connect_timeout\n    \n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n    \n            # Make the request on the httplib connection object.\n>           httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:416: in _make_request\n    conn.request(method, url, **httplib_request_kw)\n.venv\\Lib\\site-packages\\urllib3\\connection.py:244: in request\n    super(HTTPConnection, self).request(method, url, body=body, headers=headers)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1336: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1382: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1331: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1091: in _send_output\n    self.send(msg)\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\http\\client.py:1035: in send\n    self.connect()\n.venv\\Lib\\site-packages\\urllib3\\connection.py:205: in connect\n    conn = self._new_conn()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connection.HTTPConnection object at 0x00000172CA490830>\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n    \n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n    \n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n    \n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n    \n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n    \n        except SocketError as e:\n>           raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\nE           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000172CA490830>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it\n\n.venv\\Lib\\site-packages\\urllib3\\connection.py:186: NewConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.wallet.test_wallet_load_from_keystore_file.TestWalletLoadFromKeystoreFile testMethod=test_wallet_load_and_call_api>\n_make_id = <MagicMock name='_make_id' id='1592530120112'>\n\n    @patch('iconsdk.providers.http_provider.HTTPProvider._make_id', return_value=1234)\n    def test_wallet_load_and_call_api(self, _make_id):\n        \"\"\"Case when loading a wallet and call an api.\"\"\"\n        # Loads a wallet.\n        wallet = KeyWallet.load(self.TEST_KEYSTORE_FILE_PATH, self.TEST_KEYSTORE_FILE_PASSWORD)\n    \n        # Checks a wallet's address is correct.\n        self.assertEqual(wallet.get_address(), \"hxfd7e4560ba363f5aabd32caac7317feeee70ea57\")\n    \n        # Calls an api.\n        icon_service = IconService(HTTPProvider(BASE_DOMAIN_URL_V3_FOR_TEST, VERSION_FOR_TEST))\n        with requests_mock.Mocker() as m:\n            response_json = {\n                \"jsonrpc\": \"2.0\",\n                \"result\": hex(0),\n                \"id\": 1234\n            }\n            m.post(self.matcher, json=response_json)\n>           balance = icon_service.get_balance(wallet.get_address())\n\ntests\\wallet\\test_wallet_load_from_keystore_file.py:82: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\niconsdk\\icon_service.py:153: in get_balance\n    result = self.__provider.make_request('icx_getBalance', params, full_response)\niconsdk\\providers\\http_provider.py:151: in make_request\n    response = self._make_post_request(request_url, rpc_dict, **self._get_request_kwargs())\niconsdk\\providers\\http_provider.py:128: in _make_post_request\n    response = http.request(\n.venv\\Lib\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n.venv\\Lib\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n.venv\\Lib\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:830: in urlopen\n    return self.urlopen(\n.venv\\Lib\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Retry(total=0, connect=None, read=None, redirect=None, status=None)\nmethod = 'POST', url = '/api/v3', response = None\nerror = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA490830>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it')\n_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000172CA490050>\n_stacktrace = <traceback object at 0x00000172CA29A8C0>\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n    \n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n    \n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n    \n        total = self.total\n        if total is not None:\n            total -= 1\n    \n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n    \n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n    \n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n    \n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n    \n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n    \n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n    \n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n    \n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n    \n        if new_retry.is_exhausted():\n>           raise MaxRetryError(_pool, url, error or ResponseError(cause))\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=9000): Max retries exceeded with url: /api/v3 (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000172CA490830>: Failed to establish a new connection: [WinError 10061] No connection could be made because the target machine actively refused it'))\n\n.venv\\Lib\\site-packages\\urllib3\\util\\retry.py:594: MaxRetryError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py::TestWalletLoadFromKeystoreFile::test_wallet_load_from_invalid_directory",
      "lineno": 53,
      "outcome": "passed",
      "keywords": [
        "test_wallet_load_from_invalid_directory",
        "TestWalletLoadFromKeystoreFile",
        "test_wallet_load_from_keystore_file.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py::TestWalletLoadFromKeystoreFile::test_wallet_load_from_keystore_file",
      "lineno": 37,
      "outcome": "passed",
      "keywords": [
        "test_wallet_load_from_keystore_file",
        "TestWalletLoadFromKeystoreFile",
        "test_wallet_load_from_keystore_file.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet_load_from_keystore_file.py::TestWalletLoadFromKeystoreFile::test_wallet_load_with_invalid_password",
      "lineno": 58,
      "outcome": "passed",
      "keywords": [
        "test_wallet_load_with_invalid_password",
        "TestWalletLoadFromKeystoreFile",
        "test_wallet_load_from_keystore_file.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet_store.py::TestWalletStore::test_wallet_store_on_the_wrong_path",
      "lineno": 41,
      "outcome": "passed",
      "keywords": [
        "test_wallet_store_on_the_wrong_path",
        "TestWalletStore",
        "test_wallet_store.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet_store.py::TestWalletStore::test_wallet_store_overwriting",
      "lineno": 52,
      "outcome": "passed",
      "keywords": [
        "test_wallet_store_overwriting",
        "TestWalletStore",
        "test_wallet_store.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet_store.py::TestWalletStore::test_wallet_store_successfully",
      "lineno": 32,
      "outcome": "passed",
      "keywords": [
        "test_wallet_store_successfully",
        "TestWalletStore",
        "test_wallet_store.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/wallet/test_wallet_store.py::TestWalletStore::test_wallet_store_with_wrong_password",
      "lineno": 47,
      "outcome": "passed",
      "keywords": [
        "test_wallet_store_with_wrong_password",
        "TestWalletStore",
        "test_wallet_store.py",
        "wallet",
        "tests",
        "icon-project@icon-sdk-python__50c75a50__requests__urllib3",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    }
  ],
  "warnings": [
    {
      "message": "pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html",
      "category": "DeprecationWarning",
      "when": "collect",
      "filename": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\eth_keyfile\\__init__.py",
      "lineno": 3
    },
    {
      "message": "'collections.abc.ByteString' is deprecated and slated for removal in Python 3.14",
      "category": "DeprecationWarning",
      "when": "collect",
      "filename": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\eth_keys\\datatypes.py",
      "lineno": 116
    },
    {
      "message": "'collections.abc.ByteString' is deprecated and slated for removal in Python 3.14",
      "category": "DeprecationWarning",
      "when": "collect",
      "filename": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\eth_keys\\datatypes.py",
      "lineno": 164
    },
    {
      "message": "'collections.abc.ByteString' is deprecated and slated for removal in Python 3.14",
      "category": "DeprecationWarning",
      "when": "collect",
      "filename": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\eth_keys\\datatypes.py",
      "lineno": 244
    },
    {
      "message": "'collections.abc.ByteString' is deprecated and slated for removal in Python 3.14",
      "category": "DeprecationWarning",
      "when": "collect",
      "filename": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\eth_keys\\datatypes.py",
      "lineno": 273
    },
    {
      "message": "'collections.abc.ByteString' is deprecated and slated for removal in Python 3.14",
      "category": "DeprecationWarning",
      "when": "collect",
      "filename": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\eth_keys\\datatypes.py",
      "lineno": 358
    },
    {
      "message": "'collections.abc.ByteString' is deprecated and slated for removal in Python 3.14",
      "category": "DeprecationWarning",
      "when": "collect",
      "filename": "D:\\repos\\icon-project@icon-sdk-python__50c75a50__requests__urllib3\\.venv\\Lib\\site-packages\\eth_keys\\datatypes.py",
      "lineno": 427
    }
  ]
}