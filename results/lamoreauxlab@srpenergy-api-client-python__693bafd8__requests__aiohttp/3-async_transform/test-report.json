{
  "exitcode": 1,
  "summary": {
    "passed": 24,
    "failed": 19,
    "total": 43,
    "collected": 43
  },
  "collectors": [
    {
      "nodeid": "",
      "outcome": "passed",
      "result": [
        {
          "nodeid": ".",
          "type": "Dir"
        }
      ]
    },
    {
      "nodeid": "docs",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "script",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "srpenergy",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "srpenergy.egg-info",
      "outcome": "passed",
      "result": []
    },
    {
      "nodeid": "tests/test_client.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_client.py::test_none_accountid",
          "type": "Function",
          "lineno": 135
        },
        {
          "nodeid": "tests/test_client.py::test_none_username",
          "type": "Function",
          "lineno": 141
        },
        {
          "nodeid": "tests/test_client.py::test_none_password",
          "type": "Function",
          "lineno": 147
        },
        {
          "nodeid": "tests/test_client.py::test_blank_accountid",
          "type": "Function",
          "lineno": 153
        },
        {
          "nodeid": "tests/test_client.py::test_blank_username",
          "type": "Function",
          "lineno": 159
        },
        {
          "nodeid": "tests/test_client.py::test_blank_password",
          "type": "Function",
          "lineno": 165
        },
        {
          "nodeid": "tests/test_client.py::test_bad_parameter_account_id_hyphens",
          "type": "Function",
          "lineno": 171
        },
        {
          "nodeid": "tests/test_client.py::test_bad_parameter_start_date_string",
          "type": "Coroutine",
          "lineno": 179
        },
        {
          "nodeid": "tests/test_client.py::test_bad_parameter_end_date_string",
          "type": "Coroutine",
          "lineno": 195
        },
        {
          "nodeid": "tests/test_client.py::test_bad_parameter_start_date_after_now",
          "type": "Coroutine",
          "lineno": 211
        },
        {
          "nodeid": "tests/test_client.py::test_bad_parameter_start_date_after_end_date",
          "type": "Coroutine",
          "lineno": 228
        },
        {
          "nodeid": "tests/test_client.py::test_get_usage",
          "type": "Coroutine",
          "lineno": 245
        },
        {
          "nodeid": "tests/test_client.py::test_single_day_usage_kw",
          "type": "Coroutine",
          "lineno": 263
        },
        {
          "nodeid": "tests/test_client.py::test_latest_day_usage_kw",
          "type": "Coroutine",
          "lineno": 286
        },
        {
          "nodeid": "tests/test_client.py::test_latest_day_usage_kw_no_total",
          "type": "Coroutine",
          "lineno": 309
        },
        {
          "nodeid": "tests/test_client.py::test_validate_user",
          "type": "Coroutine",
          "lineno": 332
        },
        {
          "nodeid": "tests/test_client.py::test_error_validate_user",
          "type": "Coroutine",
          "lineno": 347
        },
        {
          "nodeid": "tests/test_client.py::test_error_usage_payload",
          "type": "Coroutine",
          "lineno": 362
        },
        {
          "nodeid": "tests/test_client.py::test_date_timezone_error",
          "type": "Coroutine",
          "lineno": 379
        }
      ]
    },
    {
      "nodeid": "tests/test_rate.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_rate.py::test_winter_off_peak",
          "type": "Function",
          "lineno": 7
        },
        {
          "nodeid": "tests/test_rate.py::test_winter_on_peak",
          "type": "Function",
          "lineno": 16
        },
        {
          "nodeid": "tests/test_rate.py::test_summer_off_peak",
          "type": "Function",
          "lineno": 25
        },
        {
          "nodeid": "tests/test_rate.py::test_summer_on_peak",
          "type": "Function",
          "lineno": 34
        },
        {
          "nodeid": "tests/test_rate.py::test_peak_summer_off_peak",
          "type": "Function",
          "lineno": 43
        },
        {
          "nodeid": "tests/test_rate.py::test_peak_summer_on_peak",
          "type": "Function",
          "lineno": 52
        },
        {
          "nodeid": "tests/test_rate.py::test_winter_weekend",
          "type": "Function",
          "lineno": 61
        },
        {
          "nodeid": "tests/test_rate.py::test_summer_weekend",
          "type": "Function",
          "lineno": 70
        },
        {
          "nodeid": "tests/test_rate.py::test_peak_summer_weekend",
          "type": "Function",
          "lineno": 79
        },
        {
          "nodeid": "tests/test_rate.py::test_winter_new_years",
          "type": "Function",
          "lineno": 88
        },
        {
          "nodeid": "tests/test_rate.py::test_summer_memorial_day",
          "type": "Function",
          "lineno": 97
        },
        {
          "nodeid": "tests/test_rate.py::test_peak_summer_independence_day",
          "type": "Function",
          "lineno": 106
        },
        {
          "nodeid": "tests/test_rate.py::test_summer_labor_day",
          "type": "Function",
          "lineno": 115
        },
        {
          "nodeid": "tests/test_rate.py::test_winter_thanksgiving_day",
          "type": "Function",
          "lineno": 124
        },
        {
          "nodeid": "tests/test_rate.py::test_winter_christmas_day",
          "type": "Function",
          "lineno": 133
        },
        {
          "nodeid": "tests/test_rate.py::test_none_parameter",
          "type": "Function",
          "lineno": 142
        },
        {
          "nodeid": "tests/test_rate.py::test_bad_parameter",
          "type": "Function",
          "lineno": 148
        }
      ]
    },
    {
      "nodeid": "tests/test_time_of_use.py",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_time_of_use.py::test_time_of_use_summer_off_peak_usage",
          "type": "Coroutine",
          "lineno": 660
        },
        {
          "nodeid": "tests/test_time_of_use.py::test_time_of_use_summer_on_peak_usage",
          "type": "Coroutine",
          "lineno": 683
        },
        {
          "nodeid": "tests/test_time_of_use.py::test_time_of_use_peak_summer_off_peak_usage",
          "type": "Coroutine",
          "lineno": 706
        },
        {
          "nodeid": "tests/test_time_of_use.py::test_time_of_use_peak_summer_on_peak_usage",
          "type": "Coroutine",
          "lineno": 729
        },
        {
          "nodeid": "tests/test_time_of_use.py::test_time_of_use_winter_off_peak_usage",
          "type": "Coroutine",
          "lineno": 752
        },
        {
          "nodeid": "tests/test_time_of_use.py::test_time_of_use_winter_on_peak_usage",
          "type": "Coroutine",
          "lineno": 775
        },
        {
          "nodeid": "tests/test_time_of_use.py::test_daily_aggregation_tou",
          "type": "Coroutine",
          "lineno": 798
        }
      ]
    },
    {
      "nodeid": "tests",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "tests/test_client.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_rate.py",
          "type": "Module"
        },
        {
          "nodeid": "tests/test_time_of_use.py",
          "type": "Module"
        }
      ]
    },
    {
      "nodeid": ".",
      "outcome": "passed",
      "result": [
        {
          "nodeid": "docs",
          "type": "Dir"
        },
        {
          "nodeid": "script",
          "type": "Dir"
        },
        {
          "nodeid": "srpenergy",
          "type": "Package"
        },
        {
          "nodeid": "srpenergy.egg-info",
          "type": "Dir"
        },
        {
          "nodeid": "tests",
          "type": "Package"
        }
      ]
    }
  ],
  "tests": [
    {
      "nodeid": "tests/test_client.py::test_none_accountid",
      "lineno": 135,
      "outcome": "passed",
      "keywords": [
        "test_none_accountid",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_none_username",
      "lineno": 141,
      "outcome": "passed",
      "keywords": [
        "test_none_username",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_none_password",
      "lineno": 147,
      "outcome": "passed",
      "keywords": [
        "test_none_password",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_blank_accountid",
      "lineno": 153,
      "outcome": "passed",
      "keywords": [
        "test_blank_accountid",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_blank_username",
      "lineno": 159,
      "outcome": "passed",
      "keywords": [
        "test_blank_username",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_blank_password",
      "lineno": 165,
      "outcome": "passed",
      "keywords": [
        "test_blank_password",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_bad_parameter_account_id_hyphens",
      "lineno": 171,
      "outcome": "passed",
      "keywords": [
        "test_bad_parameter_account_id_hyphens",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_bad_parameter_start_date_string",
      "lineno": 179,
      "outcome": "failed",
      "keywords": [
        "test_bad_parameter_start_date_string",
        "asyncio",
        "pytestmark",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_client.py",
            "lineno": 183,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_bad_parameter_start_date_string():\n        \"\"\"Test start date is date.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_client.py:183: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_bad_parameter_end_date_string",
      "lineno": 195,
      "outcome": "failed",
      "keywords": [
        "test_bad_parameter_end_date_string",
        "asyncio",
        "pytestmark",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_client.py",
            "lineno": 199,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_bad_parameter_end_date_string():\n        \"\"\"Test end date is date.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_client.py:199: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_bad_parameter_start_date_after_now",
      "lineno": 211,
      "outcome": "failed",
      "keywords": [
        "test_bad_parameter_start_date_after_now",
        "asyncio",
        "pytestmark",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_client.py",
            "lineno": 215,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_bad_parameter_start_date_after_now():\n        \"\"\"Test start date is not after Now.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_client.py:215: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_bad_parameter_start_date_after_end_date",
      "lineno": 228,
      "outcome": "failed",
      "keywords": [
        "test_bad_parameter_start_date_after_end_date",
        "asyncio",
        "pytestmark",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_client.py",
            "lineno": 232,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_bad_parameter_start_date_after_end_date():\n        \"\"\"Test start date is not after end date.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_client.py:232: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_get_usage",
      "lineno": 245,
      "outcome": "failed",
      "keywords": [
        "test_get_usage",
        "asyncio",
        "pytestmark",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_client.py",
            "lineno": 249,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_get_usage():\n        \"\"\"Test usage.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_client.py:249: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_single_day_usage_kw",
      "lineno": 263,
      "outcome": "failed",
      "keywords": [
        "test_single_day_usage_kw",
        "asyncio",
        "pytestmark",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_client.py",
            "lineno": 267,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_single_day_usage_kw():\n        \"\"\"Test Single Day Usage for kwh.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_client.py:267: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_latest_day_usage_kw",
      "lineno": 286,
      "outcome": "failed",
      "keywords": [
        "test_latest_day_usage_kw",
        "asyncio",
        "pytestmark",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_client.py",
            "lineno": 290,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_latest_day_usage_kw():\n        \"\"\"Test Latest Day Usage for kwh.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_client.py:290: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_latest_day_usage_kw_no_total",
      "lineno": 309,
      "outcome": "failed",
      "keywords": [
        "test_latest_day_usage_kw_no_total",
        "asyncio",
        "pytestmark",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_client.py",
            "lineno": 313,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_latest_day_usage_kw_no_total():\n        \"\"\"Test Latest Day Usage for kwh.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_client.py:313: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_validate_user",
      "lineno": 332,
      "outcome": "failed",
      "keywords": [
        "test_validate_user",
        "asyncio",
        "pytestmark",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_client.py",
            "lineno": 336,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_validate_user():\n        \"\"\"Test Validation of user.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_client.py:336: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_error_validate_user",
      "lineno": 347,
      "outcome": "failed",
      "keywords": [
        "test_error_validate_user",
        "asyncio",
        "pytestmark",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_client.py",
            "lineno": 351,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_error_validate_user():\n        \"\"\"Test error Validation of user.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_client.py:351: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_error_usage_payload",
      "lineno": 362,
      "outcome": "failed",
      "keywords": [
        "test_error_usage_payload",
        "asyncio",
        "pytestmark",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_client.py",
            "lineno": 366,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_error_usage_payload():\n        \"\"\"Test error with invalid usage payload.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_client.py:366: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_client.py::test_date_timezone_error",
      "lineno": 379,
      "outcome": "failed",
      "keywords": [
        "test_date_timezone_error",
        "asyncio",
        "pytestmark",
        "test_client.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_client.py",
            "lineno": 383,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_date_timezone_error():\n        \"\"\"Test error with invalid usage payload.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_client.py:383: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_winter_off_peak",
      "lineno": 7,
      "outcome": "passed",
      "keywords": [
        "test_winter_off_peak",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_winter_on_peak",
      "lineno": 16,
      "outcome": "passed",
      "keywords": [
        "test_winter_on_peak",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_summer_off_peak",
      "lineno": 25,
      "outcome": "passed",
      "keywords": [
        "test_summer_off_peak",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_summer_on_peak",
      "lineno": 34,
      "outcome": "passed",
      "keywords": [
        "test_summer_on_peak",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_peak_summer_off_peak",
      "lineno": 43,
      "outcome": "passed",
      "keywords": [
        "test_peak_summer_off_peak",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_peak_summer_on_peak",
      "lineno": 52,
      "outcome": "passed",
      "keywords": [
        "test_peak_summer_on_peak",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_winter_weekend",
      "lineno": 61,
      "outcome": "passed",
      "keywords": [
        "test_winter_weekend",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_summer_weekend",
      "lineno": 70,
      "outcome": "passed",
      "keywords": [
        "test_summer_weekend",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_peak_summer_weekend",
      "lineno": 79,
      "outcome": "passed",
      "keywords": [
        "test_peak_summer_weekend",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_winter_new_years",
      "lineno": 88,
      "outcome": "passed",
      "keywords": [
        "test_winter_new_years",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_summer_memorial_day",
      "lineno": 97,
      "outcome": "passed",
      "keywords": [
        "test_summer_memorial_day",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_peak_summer_independence_day",
      "lineno": 106,
      "outcome": "passed",
      "keywords": [
        "test_peak_summer_independence_day",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_summer_labor_day",
      "lineno": 115,
      "outcome": "passed",
      "keywords": [
        "test_summer_labor_day",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_winter_thanksgiving_day",
      "lineno": 124,
      "outcome": "passed",
      "keywords": [
        "test_winter_thanksgiving_day",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_winter_christmas_day",
      "lineno": 133,
      "outcome": "passed",
      "keywords": [
        "test_winter_christmas_day",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_none_parameter",
      "lineno": 142,
      "outcome": "passed",
      "keywords": [
        "test_none_parameter",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_rate.py::test_bad_parameter",
      "lineno": 148,
      "outcome": "passed",
      "keywords": [
        "test_bad_parameter",
        "test_rate.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "passed"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_time_of_use.py::test_time_of_use_summer_off_peak_usage",
      "lineno": 660,
      "outcome": "failed",
      "keywords": [
        "test_time_of_use_summer_off_peak_usage",
        "asyncio",
        "pytestmark",
        "test_time_of_use.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_time_of_use.py",
            "lineno": 664,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_time_of_use_summer_off_peak_usage():\n        \"\"\"Test Time of Use for summer Off Peak Usage for kwh.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_time_of_use.py:664: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_time_of_use.py::test_time_of_use_summer_on_peak_usage",
      "lineno": 683,
      "outcome": "failed",
      "keywords": [
        "test_time_of_use_summer_on_peak_usage",
        "asyncio",
        "pytestmark",
        "test_time_of_use.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_time_of_use.py",
            "lineno": 687,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_time_of_use_summer_on_peak_usage():\n        \"\"\"Test Time of Use for summer on Peak Usage for kwh.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_time_of_use.py:687: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_time_of_use.py::test_time_of_use_peak_summer_off_peak_usage",
      "lineno": 706,
      "outcome": "failed",
      "keywords": [
        "test_time_of_use_peak_summer_off_peak_usage",
        "asyncio",
        "pytestmark",
        "test_time_of_use.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_time_of_use.py",
            "lineno": 710,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_time_of_use_peak_summer_off_peak_usage():\n        \"\"\"Test Time of Use for peak summer Off Peak Usage for kwh.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_time_of_use.py:710: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_time_of_use.py::test_time_of_use_peak_summer_on_peak_usage",
      "lineno": 729,
      "outcome": "failed",
      "keywords": [
        "test_time_of_use_peak_summer_on_peak_usage",
        "asyncio",
        "pytestmark",
        "test_time_of_use.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_time_of_use.py",
            "lineno": 733,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_time_of_use_peak_summer_on_peak_usage():\n        \"\"\"Test Time of Use for peak summer on Peak Usage for kwh.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_time_of_use.py:733: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_time_of_use.py::test_time_of_use_winter_off_peak_usage",
      "lineno": 752,
      "outcome": "failed",
      "keywords": [
        "test_time_of_use_winter_off_peak_usage",
        "asyncio",
        "pytestmark",
        "test_time_of_use.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_time_of_use.py",
            "lineno": 756,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_time_of_use_winter_off_peak_usage():\n        \"\"\"Test Time of Use for winter Off Peak Usage for kwh.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_time_of_use.py:756: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_time_of_use.py::test_time_of_use_winter_on_peak_usage",
      "lineno": 775,
      "outcome": "failed",
      "keywords": [
        "test_time_of_use_winter_on_peak_usage",
        "asyncio",
        "pytestmark",
        "test_time_of_use.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_time_of_use.py",
            "lineno": 779,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_time_of_use_winter_on_peak_usage():\n        \"\"\"Test Time of Use for winter on Peak Usage for kwh.\"\"\"\n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_time_of_use.py:779: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    },
    {
      "nodeid": "tests/test_time_of_use.py::test_daily_aggregation_tou",
      "lineno": 798,
      "outcome": "failed",
      "keywords": [
        "test_daily_aggregation_tou",
        "asyncio",
        "pytestmark",
        "test_time_of_use.py",
        "tests",
        "lamoreauxlab@srpenergy-api-client-python__693bafd8__requests__aiohttp",
        ""
      ],
      "setup": {
        "outcome": "passed"
      },
      "call": {
        "outcome": "failed",
        "crash": {
          "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
          "lineno": 715,
          "message": "AttributeError: module 'srpenergy.client' has no attribute 'requests'"
        },
        "traceback": [
          {
            "path": "tests\\test_time_of_use.py",
            "lineno": 819,
            "message": ""
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py",
            "lineno": 1430,
            "message": "in __enter__"
          },
          {
            "path": "C:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py",
            "lineno": 715,
            "message": "AttributeError"
          }
        ],
        "longrepr": "@pytest.mark.asyncio\n    async def test_daily_aggregation_tou():\n        \"\"\"Test that hourly roll up matches SRP Daily.\"\"\"\n        # \"dailyReadList\": [{\n        #             \"day\": \"2018-06-28T07:00:00Z\",\n        #             \"date\": \"2018-06-28T07:00:00Z\",\n        #             \"meterReadDate\": \"2018-06-29T00:00:00-07:00\",\n        #             \"superOffPeakKwh\": 0.0,\n        #             \"shoulderKwh\": 0.0,\n        #             \"offPeakKwh\": 61.0,\n        #             \"onPeakKwh\": 39.0,\n        #             \"totalKwh\": 0.0,\n        #             \"onPeakCost\": 9.33,\n        #             \"offPeakCost\": 5.51,\n        #             \"shoulderCost\": 0.0,\n        #             \"superOffPeakCost\": 0.0,\n        #             \"totalCost\": 0.0,\n        #             \"dailyCost\": 14.84\n        #         }\n    \n>       with patch(PATCH_GET) as session_get, patch(PATCH_POST) as session_post:\n\ntests\\test_time_of_use.py:819: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\unittest\\mock.py:1430: in __enter__\n    self.target = self.getter()\n                  ^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nname = 'srpenergy.client.requests.Session'\n\n    def resolve_name(name):\n        \"\"\"\n        Resolve a name to an object.\n    \n        It is expected that `name` will be a string in one of the following\n        formats, where W is shorthand for a valid Python identifier and dot stands\n        for a literal period in these pseudo-regexes:\n    \n        W(.W)*\n        W(.W)*:(W(.W)*)?\n    \n        The first form is intended for backward compatibility only. It assumes that\n        some part of the dotted name is a package, and the rest is an object\n        somewhere within that package, possibly nested inside other objects.\n        Because the place where the package stops and the object hierarchy starts\n        can't be inferred by inspection, repeated attempts to import must be done\n        with this form.\n    \n        In the second form, the caller makes the division point clear through the\n        provision of a single colon: the dotted name to the left of the colon is a\n        package to be imported, and the dotted name to the right is the object\n        hierarchy within that package. Only one import is needed in this form. If\n        it ends with the colon, then a module object is returned.\n    \n        The function will return an object (which might be a module), or raise one\n        of the following exceptions:\n    \n        ValueError - if `name` isn't in a recognised format\n        ImportError - if an import failed when it shouldn't have\n        AttributeError - if a failure occurred when traversing the object hierarchy\n                         within the imported package to get to the desired object.\n        \"\"\"\n        global _NAME_PATTERN\n        if _NAME_PATTERN is None:\n            # Lazy import to speedup Python startup time\n            import re\n            dotted_words = r'(?!\\d)(\\w+)(\\.(?!\\d)(\\w+))*'\n            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'\n                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',\n                                       re.UNICODE)\n    \n        m = _NAME_PATTERN.match(name)\n        if not m:\n            raise ValueError(f'invalid format: {name!r}')\n        gd = m.groupdict()\n        if gd.get('cln'):\n            # there is a colon - a one-step import is all that's needed\n            mod = importlib.import_module(gd['pkg'])\n            parts = gd.get('obj')\n            parts = parts.split('.') if parts else []\n        else:\n            # no colon - have to iterate to find the package boundary\n            parts = name.split('.')\n            modname = parts.pop(0)\n            # first part *must* be a module/package.\n            mod = importlib.import_module(modname)\n            while parts:\n                p = parts[0]\n                s = f'{modname}.{p}'\n                try:\n                    mod = importlib.import_module(s)\n                    parts.pop(0)\n                    modname = s\n                except ImportError:\n                    break\n        # if we reach this point, mod is the module, already imported, and\n        # parts is the list of parts in the object hierarchy to be traversed, or\n        # an empty list if just the module is wanted.\n        result = mod\n        for p in parts:\n>           result = getattr(result, p)\n                     ^^^^^^^^^^^^^^^^^^\nE           AttributeError: module 'srpenergy.client' has no attribute 'requests'\n\nC:\\Users\\Mohay\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\pkgutil.py:715: AttributeError"
      },
      "teardown": {
        "outcome": "passed"
      }
    }
  ]
}